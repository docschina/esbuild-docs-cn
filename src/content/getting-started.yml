title: 快速入门
body:
  - h1: 快速入门

  - h2: 安装 esbuild <#install-esbuild>

  - p: >
      首先，下载并本地安装 esbuild， A prebuilt
      可以通过 npm 安装预编译的原生可执行文件：

  - pre: |
      npm install esbuild

  - p: >
      此命令应该会将 esbuild 安装到你本地的 `node_modules` 中。
      你可以运行如下命令，来检测 esbuild 的原生可执行文件
      是否正常：

  - pre: |
      npx esbuild --version

  - p: >
      This uses the `npx` command which should have been installed when you
      installed npm. It provides a cross-platform way to manually run package
      executables, and is used here for simplicity. However, it adds additional
      overhead so you shouldn't use it when writing scripts inside `package.json`.

  - p: >
      The recommended way to install esbuild is to install the native executable
      using npm. But if you don't want to do that, there are also some
      [other ways to install](#other-ways-to-install).

  - h2: 首次构建 <#your-first-bundle>

  - p: >
      这是一个简易的真实案例，用于说明 esbuild 的能力以及如何使用它。
      首先，请安装 `react` 和 `react-dom` 的 package：

  - pre: |
      npm install react react-dom

  - p: >
      接下来，创建名为 `app.jsx` 的文件并包含如下代码：

  - pre.js: |
      import * as React from 'react'
      import * as Server from 'react-dom/server'

      let Greet = () => <h1>Hello, world!</h1>
      console.log(Server.renderToString(<Greet />))

  - p: >
      最后，运行 esbuild 打包此文件：

  - pre: |
      npx esbuild app.jsx --bundle --outfile=out.js

  - p: >
      不出意外的话，上述命令执行后悔创建一个名为 `out.js` 的文件，
      其中包含你的代码以及 React 库的代码。
      代码完全独立，无需再依赖你的 `node_modules`。
      如果你使用 `node out.js` 运行代码，你应该能看到如下内容：


  - pre.html: |
      <h1 data-reactroot="">Hello, world!</h1>

  - p: >
      注意，esbuild 除了识别 `jsx` 扩展名之外，
      未进行任何配置就将 JSX 语法转换为 JavaScript。
      虽然 esbuild 可以进行配置，
      但它试图提供合理的默认值，以便在常见的情况下自动完成构建。
      如果你想在 `.js` 文件中使用 JSX 语法，你可以通过设置 `--loader:.js=jsx` 选项，
      来告诉 esbuild 对 js 文件进行 jsx 的编译。
      更多关于可用配置项的说明，请参阅 [API 文档](/api/)。

  - h2: 构建脚本 <#build-scripts>

  - p: >
      构建命令会反复执行，因此，通常我们会简化它。
      常见的做法是在 `package.json` 中添加构建脚本，
      具体代码如下：

  - pre.json: |
      {
        "scripts": {
          "build": "esbuild app.jsx --bundle --outfile=out.js"
        }
      }

  - p: >
      注意，这里不需要使用 `npx` 命令。
      在 `scripts` 部分中的所有内容都应该通过路径来使用 `esbuild`，
      所以这里无需使用 `npx`，
      使用它只会让你的构建变慢。

  - p: >
      使用方式如下：

  - pre: |
      npm run build

  - p: >
      但是，如果需要向 esbuild 传递许多选项，
      这会使得命令看起来非常笨重。如果将 esbuild 用于较为复杂的情况，
      你可能会用到 esbuild 的 JavaScript API，
      即在 JavaScript 中编写构建脚本。具体代码如下：

  - example:
      in:
        app.jsx: '<div/>'

      js: |
        require('esbuild').build({
          entryPoints: ['app.jsx'],
          bundle: true,
          outfile: 'out.js',
        }).catch(() => process.exit(1))

  - p: >
      `build` 函数会在子进程中运行 esbuild 的可执行文件，并返回一个 Promise，
      当构建完成后，该 Promise 将被 resolves。
      上述代码并未打印捕获的异常，
      因为异常中的任何错误信息默认会被打印到控制台（如果你不需要这个功能，
      可以通过修改 [log level](/api/#log-level) 来关闭此功能）。

  - p: >
      尽管有个同步的 `buildSync` API，
      但异步 API 对于构建脚本来说更为合适，
      因为[插件](/plugins/)只与异步 API 协同工作。
      你可以在 [API 文档](/api/#build-api) 中了解更多关于构建 API 的配置项。

  - h2: 针对浏览器环境的构建 <#bundling-for-the-browser>

  - p: >
      构建工具默认为浏览器输出代码，
      所以无需额外配置就可以完成构建。
      对于开发版本，你可能需要使用 `--sourcemap` 以启用 source map，
      对于生产版本，你可能需要使用 `--minify` 启用压缩。
      有时，你可能还需要为你支持的浏览器配置 target。
      所以具体命令会像如下所示：

  - example:
      in:
        app.jsx: '<div/>'

      cli: |
        esbuild app.jsx --bundle --minify --sourcemap --target=chrome58,firefox57,safari11,edge16

      js: |
        require('esbuild').buildSync({
          entryPoints: ['app.jsx'],
          bundle: true,
          minify: true,
          sourcemap: true,
          target: ['chrome58', 'firefox57', 'safari11', 'edge16'],
          outfile: 'out.js',
        })

      go: |
        package main

        import "github.com/evanw/esbuild/pkg/api"
        import "os"

        func main() {
          result := api.Build(api.BuildOptions{
            EntryPoints:       []string{"app.jsx"},
            Bundle:            true,
            MinifyWhitespace:  true,
            MinifyIdentifiers: true,
            MinifySyntax:      true,
            Engines: []api.Engine{
              {api.EngineChrome, "58"},
              {api.EngineFirefox, "57"},
              {api.EngineSafari, "11"},
              {api.EngineEdge, "16"},
            },
            Write: true,
          })

          if len(result.Errors) > 0 {
            os.Exit(1)
          }
        }

  - p: >
      有些你想使用的 npm 包，可能并非被设计成在浏览器中运行的。
      这时你可以使用 esbuild 的配置项来解决一些问题，并成功构建 bundle。
      例如，`react` 库中包含了检查 
      <code>process<wbr>.env<wbr>.NODE_ENV</code> 值的代码。
      在浏览器中崩溃，因为名为 `process` 的变量只存在于 node 中，
      而非浏览器中。为了解决此问题，
      你可以在构建时为此变量 [define](/api/#define) 一个自定义的值：

  - example:
      in:
        app.jsx: '<div/>'

      cli: |
        esbuild app.jsx --bundle --define:process.env.NODE_ENV=\"production\"

      js: |
        require('esbuild').buildSync({
          entryPoints: ['app.jsx'],
          bundle: true,
          outfile: 'out.js',
          define: {
            'process.env.NODE_ENV': '"production"',
          },
        })

      go: |
        package main

        import "github.com/evanw/esbuild/pkg/api"
        import "os"

        func main() {
          result := api.Build(api.BuildOptions{
            EntryPoints: []string{"app.jsx"},
            Outfile:     "out.js",
            Bundle:      true,
            Define: map[string]string{
              "process.env.NODE_ENV": `"production"`,
            },
            Write: true,
          })

          if len(result.Errors) > 0 {
            os.Exit(1)
          }
        }

  - p: >
      有时，你使用的包可能会引入另一个仅允许在 node 上的可用包，
      例如 node 内置的 `path` 包。
      当发生这种情况时，你可以通过在 `package.json` 中使用 
      [browser 字段](https://github.com/defunctzombie/package-browser-field-spec)
      来将此包替换成对浏览器友好的包，具体如下：

  - pre.json: |
      {
        "browser": {
          "path": "path-browserify"
        }
      }

  - h2: 针对 Node 环境的构建 <#bundling-for-node>

  - p: >
      尽管在使用 Node 时，无需构建，但有时在 Node 代码运行前，
      用 esbuild 处理下代码还是有好处的。
      构建工具可以自动剥离 TypeScript 的类型，
      将 ECMAScript 模块语法转换为 CommonJS 语法，
      同时将 JavaScript 语法转换为特定版本 Node 的旧语法。
      并且这也有利于代码发布前对你的 package 进行构建，
      以保证其下载体积更小，从而保证加载时文件系统读取它的时间更少。

  - p: >
      如果你正在构建需要运行于 Node 环境的代码，
      你需要通过将 <code>--platform=<wbr>node</code> 传递给 esbuild 以为其配置 [platform](/api/#platform)。
      这同时会将一些不同的配置，统一改为对 Node 更为友好的默认值。
      例如，所有 node 的内置包，如 `fs`，都会自动标记为外部（external）包，这样 esbuild 就不会尝试对它们进行构建。
      此设置也会禁用 `package.json` 中的浏览器字段。

  - p: >
      如果你在代码中使用了较新的 JavaScript 语法，而这些语法在你的 Node 版本中并不适用，
      你将需要配置 Node 的目标版本：

  - example:
      in:
        app.js: '1 + 2'

      cli: |
        esbuild app.js --bundle --platform=node --target=node10.4

      js: |
        require('esbuild').buildSync({
          entryPoints: ['app.js'],
          bundle: true,
          platform: 'node',
          target: ['node10.4'],
          outfile: 'out.js',
        })

      go: |
        package main

        import "github.com/evanw/esbuild/pkg/api"
        import "os"

        func main() {
          result := api.Build(api.BuildOptions{
            EntryPoints: []string{"app.js"},
            Bundle:      true,
            Platform:    api.PlatformNode,
            Engines: []api.Engine{
              {api.EngineNode, "10.4"},
            },
            Write: true,
          })

          if len(result.Errors) > 0 {
            os.Exit(1)
          }
        }

  - p: >
      有时，你所使用的包中包含的代码由于某些原因的关系不能参与构建。
      常见的情况是对原生包进行扩展的包，比如 `fsevents`。
      或者，你可能因为某些原因想把一个包从构建中剔除。
      此时可以通过将该包设置为外部（external）包来实现：

  - example:
      in:
        app.jsx: '<div/>'

      cli: |
        esbuild app.jsx --bundle --platform=node --external:fsevents

      js: |
        require('esbuild').buildSync({
          entryPoints: ['app.jsx'],
          bundle: true,
          platform: 'node',
          external: ['fsevents'],
          outfile: 'out.js',
        })

      go: |
        package main

        import "github.com/evanw/esbuild/pkg/api"
        import "os"

        func main() {
          result := api.Build(api.BuildOptions{
            EntryPoints: []string{"app.jsx"},
            Bundle:      true,
            Platform:    api.PlatformNode,
            External:    []string{"fsevents"},
            Write:       true,
          })

          if len(result.Errors) > 0 {
            os.Exit(1)
          }
        }

  - h2: Other ways to install <#other-ways-to-install>

  - p: >
      The recommended way to install esbuild is to [install the native executable using npm](#install-esbuild).
      But you can also install esbuild in these ways:

  - h3: Install the WASM version <#install-the-wasm-version>

  - p: >
      In addition to the `esbuild` npm package, there is also an `esbuild-wasm`
      package that functions similarly but that uses WebAssembly instead of
      native code. Installing it will also install an executable called `esbuild`:

  - pre: |
      npm install esbuild-wasm

  - p: >
      **Why this is not recommended:**
      The WebAssembly version is much, much slower than the native version. In
      many cases it is an order of magnitude (i.e. 10x) slower. This is for
      various reasons including a) it's compiled from scratch on every run, b)
      the WebAssembly compilation approach is single-threaded, and c) node has
      WebAssembly bugs that can delay the exiting of the process by many seconds.
      The WebAssembly version also excludes some features such as the local
      file server. You should only use the WebAssembly package like this if
      there is no other option, such as when you want to use esbuild on an
      unsupported platform. The WebAssembly package is primarily intended
      to only be used [in the browser](/api/#running-in-the-browser).

  - h3: Build from source <#build-from-source>

  - p: >
      To build esbuild from source:

  - ol:
    - |
      Install the Go compiler:
      <p>[https://golang.org/dl/](https://golang.org/dl/)</p>

    - |
      Download the source code:
      <pre>
      git clone --depth 1 --branch vCURRENT_ESBUILD_VERSION https://github.com/evanw/esbuild.git
      cd esbuild
      </pre>

    - |
      Build the `esbuild` executable (it will be `esbuild.exe` on Windows):
      <pre>go build ./cmd/esbuild</pre>

  - p: >
      If you want to build for other platforms, you can just prefix the build
      command with the platform information. For example, you can build the
      32-bit Linux version using this command:

  - pre: |
      GOOS=linux GOARCH=386 go build ./cmd/esbuild

  - p: >
      **Why this is not recommended:**
      The native version can only be used via the command-line interface, which
      can be unergonomic for complex use cases and which does not support [plugins](/plugins/).
      You will need to write JavaScript or Go code and use [esbuild's API](/api/)
      to use plugins.

  - h3: Download a build <#download-a-build>

  - p: >
      Although the precompiled native executables are hosted using npm, you don't
      actually need npm installed to download them. The npm package registry is
      a normal HTTP server and packages are normal gzipped tar files.

  - p: >
      Here is an example of downloading a binary executable directly:

  - example:
      noCheck: true

      cli:
        - $: |
            curl -O https://registry.npmjs.org/esbuild-darwin-64/-/esbuild-darwin-64-CURRENT_ESBUILD_VERSION.tgz
        - $: |
            tar xf ./esbuild-darwin-64-CURRENT_ESBUILD_VERSION.tgz
        - $: |
            ./package/bin/esbuild
        - expect: |
            Usage:
              esbuild [options] [entry points]

            ...

  - p: >
      The native executable in the `esbuild-darwin-64` package is for the macOS
      operating system and the x86-64 architecture. As of writing, this is the
      full list of native executable packages for the platforms esbuild supports:

  - table: |
      | Package name             | OS        | Architecture   |
      |--------------------------|-----------|----------------|
      | `esbuild-darwin-64`      | `darwin`  | `x64`          |
      | `esbuild-darwin-arm64`   | `darwin`  | `arm64`        |
      | `esbuild-freebsd-64`     | `freebsd` | `x64`          |
      | `esbuild-freebsd-arm64`  | `freebsd` | `arm64`        |
      | `esbuild-linux-32`       | `linux`   | `ia32`         |
      | `esbuild-linux-64`       | `linux`   | `x64`          |
      | `esbuild-linux-arm`      | `linux`   | `arm`          |
      | `esbuild-linux-arm64`    | `linux`   | `arm64`        |
      | `esbuild-linux-mips64le` | `linux`   | `mips64el`     |
      | `esbuild-linux-ppc64le`  | `linux`   | `ppc64`        |
      | `esbuild-windows-32`     | `win32`   | `ia32`         |
      | `esbuild-windows-64`     | `win32`   | `x64`          |

  - p: >
      **Why this is not recommended:**
      This relies on internal implementation details of esbuild's native
      executable installer. These details may change at some point, in which
      case this approach will no longer work for new esbuild versions. This
      is only a minor drawback though since the approach should still work
      forever for existing esbuild versions since packages published to npm
      are immutable. An additional drawback is that you cannot use [plugins](/plugins/)
      with the native version.
