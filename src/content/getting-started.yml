title: 快速入门
body:
  - h1: 快速入门

  - h2: 安装 esbuild <#install-esbuild>

  - p: >
      首先，下载并本地安装 esbuild， A prebuilt
      可以通过 npm 安装预编译的二进制文件：

  - pre: |
      npm install esbuild

  - p: >
      此命令应该会将 esbuild 安装到你本地的 `node_modules` 中。
      你可以运行如下命令，来检测 esbuild 二进制文件是否正常：


  - pre: |
      ./node_modules/.bin/esbuild --version

  - h2: 首次构建 <#your-first-bundle>

  - p: >
      这是一个简易的真实案例，用于说明 esbuild 的能力以及如何使用它。
      首先，请安装 `react` 和 `react-dom` 的 package：

  - pre: |
      npm install react react-dom

  - p: >
      接下来，创建名为 `app.jsx` 的文件并包含如下代码：

  - pre.js: |
      import * as React from 'react'
      import * as Server from 'react-dom/server'

      let Greet = () => <h1>Hello, world!</h1>
      console.log(Server.renderToString(<Greet />))

  - p: >
      最后，运行 esbuild 打包此文件：

  - pre: |
      ./node_modules/.bin/esbuild app.jsx --bundle --outfile=out.js

  - p: >
      不出意外的话，上述命令执行后悔创建一个名为 `out.js` 的文件，
      其中包含你的代码以及 React 库的代码。
      代码完全独立，无需再依赖你的 `node_modules`。
      如果你使用 `node out.js` 运行代码，你应该能看到如下内容：


  - pre.html: |
      <h1 data-reactroot="">Hello, world!</h1>

  - p: >
      注意，esbuild 除了识别 `jsx` 扩展名之外，
      未进行任何配置就将 JSX 语法转换为 JavaScript。
      虽然 esbuild 可以进行配置，
      但它试图提供合理的默认值，以便在常见的情况下自动完成构建。
      如果你想在 `.js` 文件中使用 JSX 语法，你可以通过设置 `--loader:.js=jsx` 选项，
      来告诉 esbuild 对 js 文件进行 jsx 的编译。
      更多关于可用配置项的说明，请参阅 [API 文档](/api/)。

  - h2: 构建脚本 <#build-scripts>

  - p: >
      构建命令会反复执行，因此，通常我们会简化它。
      常见的做法是在 `package.json` 中添加构建脚本，
      具体代码如下：

  - pre.json: |
      {
        "scripts": {
          "build": "esbuild app.jsx --bundle --outfile=out.js"
        }
      }

  - p: >
      使用方式如下：

  - pre: |
      npm run build

  - p: >
      但是，如果需要向 esbuild 传递许多选项，
      这会使得命令看起来非常笨重。如果将 esbuild 用于较为复杂的情况，
      你可能会用到 esbuild 的 JavaScript API，
      即在 JavaScript 中编写构建脚本。具体代码如下：

  - example:
      in:
        app.jsx: '<div/>'

      js: |
        require('esbuild').build({
          entryPoints: ['app.jsx'],
          bundle: true,
          outfile: 'out.js',
        }).catch(() => process.exit(1))

  - p: >
      `build` 函数会在子进程中运行 esbuild 的二进制文件，并返回一个 Promise，
      当构建完成后，该 Promise 将被 resolves。
      上述代码并未打印捕获的异常，
      因为异常中的任何错误信息默认会被打印到控制台（如果你不需要这个功能，
      可以通过修改 [log level](/api/#log-level) 来关闭此功能）。

  - p: >
      尽管有个同步的 `buildSync` API，
      但异步 API 对于构建脚本来说更为合适，
      因为[插件](/plugins/)只与异步 API 协同工作。
      你可以在 [API 文档](/api/#build-api) 中了解更多关于构建 API 的配置项。

  - h2: 针对浏览器环境的构建 <#bundling-for-the-browser>

  - p: >
      构建工具默认为浏览器输出代码，
      所以无需额外配置就可以完成构建。
      对于开发版本，你可能需要使用 `--sourcemap` 以启用 source map，
      对于生产版本，你可能需要使用 `--minify` 启用压缩。
      有时，你可能还需要为你支持的浏览器配置 target。
      所以具体命令会像如下所示：

  - example:
      in:
        app.jsx: '<div/>'

      cli: |
        esbuild app.jsx --bundle --minify --sourcemap --target=chrome58,firefox57,safari11,edge16

      js: |
        require('esbuild').buildSync({
          entryPoints: ['app.jsx'],
          bundle: true,
          minify: true,
          sourcemap: true,
          target: ['chrome58', 'firefox57', 'safari11', 'edge16'],
          outfile: 'out.js',
        })

      go: |
        package main

        import "github.com/evanw/esbuild/pkg/api"
        import "os"

        func main() {
          result := api.Build(api.BuildOptions{
            EntryPoints:       []string{"app.jsx"},
            Bundle:            true,
            MinifyWhitespace:  true,
            MinifyIdentifiers: true,
            MinifySyntax:      true,
            Engines: []api.Engine{
              {api.EngineChrome, "58"},
              {api.EngineFirefox, "57"},
              {api.EngineSafari, "11"},
              {api.EngineEdge, "16"},
            },
            Write: true,
          })

          if len(result.Errors) > 0 {
            os.Exit(1)
          }
        }

  - p: >
      有些你想使用的 npm 包，可能并非被设计成在浏览器中运行的。
      这时你可以使用 esbuild 的配置项来解决一些问题，并成功构建 bundle。
      例如，`react` 库中包含了检查 
      <code>process<wbr>.env<wbr>.NODE_ENV</code> 值的代码。
      在浏览器中崩溃，因为名为 `process` 的变量只存在于 node 中，
      而非浏览器中。为了解决此问题，
      你可以在构建时为此变量 [define](/api/#define) 一个自定义的值：

  - example:
      in:
        app.jsx: '<div/>'

      cli: |
        esbuild app.jsx --bundle --define:process.env.NODE_ENV=\"production\"

      js: |
        require('esbuild').buildSync({
          entryPoints: ['app.jsx'],
          bundle: true,
          outfile: 'out.js',
          define: {
            'process.env.NODE_ENV': '"production"',
          },
        })

      go: |
        package main

        import "github.com/evanw/esbuild/pkg/api"
        import "os"

        func main() {
          result := api.Build(api.BuildOptions{
            EntryPoints: []string{"app.jsx"},
            Outfile:     "out.js",
            Bundle:      true,
            Define: map[string]string{
              "process.env.NODE_ENV": `"production"`,
            },
            Write: true,
          })

          if len(result.Errors) > 0 {
            os.Exit(1)
          }
        }

  - p: >
      有时，你使用的包可能会引入另一个仅允许在 node 上的可用包，
      例如 node 内置的 `path` 包。
      当发生这种情况时，你可以通过在 `package.json` 中使用 
      [browser 字段](https://github.com/defunctzombie/package-browser-field-spec)
      来将此包替换成对浏览器友好的包，具体如下：

  - pre.json: |
      {
        "browser": {
          "path": "path-browserify"
        }
      }

  - h2: 针对 Node 环境的构建 <#bundling-for-node>

  - p: >
      尽管在使用 Node 时，无需构建，但有时在 Node 代码运行前，
      用 esbuild 处理下代码还是有好处的。
      构建工具可以自动剥离 TypeScript 的类型，
      将 ECMAScript 模块语法转换为 CommonJS 语法，
      同时将 JavaScript 语法转换为特定版本 Node 的旧语法。
      并且这也有利于代码发布前对你的 package 进行构建，
      以保证其下载体积更小，从而保证加载时文件系统读取它的时间更少。

  - p: >
      如果你正在构建需要运行于 Node 环境的代码，
      你需要通过将 <code>--platform=<wbr>node</code> 传递给 esbuild 以为其配置 [platform](/api/#platform)。
      这同时会将一些不同的配置，统一改为对 Node 更为友好的默认值。
      例如，所有 node 的内置包，如 `fs`，都会自动标记为外部（external）包，这样 esbuild 就不会尝试对它们进行构建。
      此设置也会禁用 `package.json` 中的浏览器字段。

  - p: >
      如果你在代码中使用了较新的 JavaScript 语法，而这些语法在你的 Node 版本中并不适用，
      你将需要配置 Node 的目标版本：

  - example:
      in:
        app.js: '1 + 2'

      cli: |
        esbuild app.js --bundle --platform=node --target=node10.4

      js: |
        require('esbuild').buildSync({
          entryPoints: ['app.js'],
          bundle: true,
          platform: 'node',
          target: ['node10.4'],
          outfile: 'out.js',
        })

      go: |
        package main

        import "github.com/evanw/esbuild/pkg/api"
        import "os"

        func main() {
          result := api.Build(api.BuildOptions{
            EntryPoints: []string{"app.js"},
            Bundle:      true,
            Platform:    api.PlatformNode,
            Engines: []api.Engine{
              {api.EngineNode, "10.4"},
            },
            Write: true,
          })

          if len(result.Errors) > 0 {
            os.Exit(1)
          }
        }

  - p: >
      有时，你所使用的包中包含的代码由于某些原因的关系不能参与构建。
      常见的情况是对原生包进行扩展的包，比如 `fsevents`。
      或者，你可能因为某些原因想把一个包从构建中剔除。
      此时可以通过将该包设置为外部（external）包来实现：

  - example:
      in:
        app.jsx: '<div/>'

      cli: |
        esbuild app.jsx --bundle --platform=node --external:fsevents

      js: |
        require('esbuild').buildSync({
          entryPoints: ['app.jsx'],
          bundle: true,
          platform: 'node',
          external: ['fsevents'],
          outfile: 'out.js',
        })

      go: |
        package main

        import "github.com/evanw/esbuild/pkg/api"
        import "os"

        func main() {
          result := api.Build(api.BuildOptions{
            EntryPoints: []string{"app.jsx"},
            Bundle:      true,
            Platform:    api.PlatformNode,
            External:    []string{"fsevents"},
            Write:       true,
          })

          if len(result.Errors) > 0 {
            os.Exit(1)
          }
        }
