title: FAQ
body:
  - h1: FAQ

  - p: >
      本文是 esbuild 常见问题的集合。
      你也可以在 [GitHub issue 上提问](https://github.com/evanw/esbuild/issues)。

  - toc: true

  - h2: 为何 esbuild 如此之快？<#why-is-esbuild-fast>

  - p: >
      若干原因：

  - ul:
    - >
      <p>
      它由 [Go](https://golang.org/) 编写，并被编译成原生代码。
      </p>
      <p>
      大多数构建工具都是用 JavaScript 编写的，
      但对于需要 JIT（即时）编译的语言来说，命令行程序的性能是他们的噩梦。
      每次运行你的构建工具时，对于 JavaScript 虚拟机来说，都是第一次运行你的代码，
      没有任何优化提示。
      当 esbuild 忙着解析你代码的 JavaScript 时，
      Node 可能还忙着解析你构建工具的 JavaScript。
      当 Node 解析完你构建工具的代码时，esbuild 可能已经退出了，
      而你的构建工具还未开始构建。
      </p>
      <p>
      此外，Go 在核心设计上就采用了并行性，而 JavaScript 却没有。
      Go 在线程间共享内存，
      而 JavaScript 必须在线程间对数据进行序列化。
      尽管 Go 和 JavaScript 都有并行的垃圾收集器，
      但 Go 的堆是所有线程之间共享的，
      而 JavaScript 则是每个线程都拥有一个单独的堆。
      根据[我的测试](https://github.com/evanw/esbuild/issues/111#issuecomment-719910381)，
      这似乎将 JavaScript 工作线程可能的并行量减少了一半。
      这大概是因为一半 CPU 的核在忙着帮另一半进行垃圾回收。
      </p>

    - >
      <p>
      极大的利用了并行性。
      </p>
      <p>
      esbuild 内部的算法经过了精心设计，在可能的情况下，
      使得所有可用的 CPU 核完全饱和。
      这过程中大概分为三个阶段：解析（parse）、链接（link）和代码生成（code generation）。
      解析和代码生成是占据了大部分的工作，
      并且完全是可并行的（链接在大部分情况下是一个固有的串行任务）。
      由于所有线程间共享内存，
      因此当构建引入相同 JavaScript 库的不同入口点时，可以很容易地共享内存。
      大多数现代计算机都有许多核，所以并行性是 esbuild 的最大优势之一。
      </p>

    - >
      <p>
      esbuild 中的所有内容都是从 0 开始编写的。
      </p>
      <p>
      完全自己编写而不使用第三方库，
      会带来很多性能上的好处。
      从 0 开始就考虑到性能，
      可以确保所有东西都采用一致的数据结构以避免昂贵的转换过程，
      在必要时进行完全地架构变更。
      当然，最大缺点就是相当的耗时。
      </p>
      <p>
      例如，许多构建工具均使用官方的 TypeScript 编译器作为解析器。
      但它是为了服务于 TypeScript 编译器团队的目标而被建立，
      他们并没有将性能作为首要指标。
      他们的代码中大量使用了 [megamorphic object shapes](https://mrale.ph/blog/2015/01/11/whats-up-with-monomorphism.html) 
      以及不必要的[动态属性访问](https://github.com/microsoft/TypeScript/issues/39247)
      (这些都是众所周知的 JavaScript 性能杀手)。
      而 TypeScript 解析器即便在类型检查被禁用的情况下，
      仍会运行类型检查器。而使用 esbuild 自定义的 TypeScript 解析器，就不会遇到上述问题。
      </p>

    - >
      <p>
      内存得到有效的利用。
      </p>
      <p>
      理想情况下的编译器，输入内容的长度大多为 O(n) 的复杂度。
      所以如果要处理大量的数据，
      内存访问速度很可能会严重影响性能。
      在数据上进行的访问次数越少（同时数据转化成的不同表现形式也要越少），
      这样你的编译器就会越快。
      </p>
      <p>
      例如，esbuild 仅访问 JavaScript 的 AST 三次：
      </p>
      <ol>
      <li>第一次用于词法、解析、作用域设置以及声明符号；</li>
      <li>第二次用于绑定符号、压缩语法、将 JSX/TS 转为 JS 以及将 ESNext 转为 ES2015；</li>
      <li>最后一次则用于对标识符进行压缩、压缩空格、生成代码以及生成 source map。</li>
      </ol>
      <p>
      当 AST 的数据仍在 CPU 热缓存（译注：术语，CPU 缓存策略分为热缓存和冷缓存）中时，
      可以最大限度地重复使用 AST 的数据。
      其他构建工具会将这些步骤分开执行，而不会交错进行。
      他们还可能会在数据的表现形式间进行转换，将多个库一同使用
      （例如 string→TS→JS→string，然后 string→JS→older JS→string，
      再然后 string→JS→minified JS→string）这将使用大量内存并使得构建变慢。
      </p>
      <p>
      而 Go 的另外一个好处是，它可以将内容紧凑的存储在内存中，
      这使得它可以使用更少的内存，更适合 CPU 缓存。
      所有的对象字段的类型和字段都紧密的包裹在一起，
      例如，几个布尔类型的标志每个只占一个字节。
      Go 还具有值语义，可以把一个对象直接嵌入到另一个对象中，
      而不需要额外分配空间。
      JavaScript 则没有这些特性，而且还有其他的缺点，
      比如 JIT 的开销（比如 hidden class slots）
      和低效的表示方式（比如非整数使用指针进行堆分配）
      </p>

  - p: >
      这些因素中每一点都只是有显著的提速，
      但综合起来，
      它们可以使得构建工具的速度比目前其他常用的构建工具快好几个数量级。

  - h2: Benchmark 详情

  - p: >
      以下是每个 benchmark 的详细信息：

  - figcaption: JavaScript benchmark
  - benchmark:
      '[esbuild](https://github.com/evanw/esbuild)': 0.37
      '[esbuild](https://github.com/evanw/esbuild) (1 thread)': 1.54
      '[rollup](https://github.com/rollup/rollup) + [terser](https://github.com/terser/terser)': 36.00
      '[webpack](https://github.com/webpack/webpack) 4': 41.91
      '[webpack](https://github.com/webpack/webpack) 5': 54.50
      '[parcel](https://github.com/parcel-bundler/parcel) 2': 56.71
      '[parcel](https://github.com/parcel-bundler/parcel) 1': 118.51

  - p: >
      This benchmark approximates a large JavaScript codebase by duplicating
      the [three.js](https://github.com/mrdoob/three.js) library 10 times
      and building a single bundle from scratch, without any caches. The
      benchmark can be run with `make bench-three` in the
      [esbuild repo](https://github.com/evanw/esbuild).

  - table: |
      | Bundler            |    Time | Relative slowdown | Absolute speed | Output size |
      | :----------------- | ------: | ----------------: | -------------: | ----------: |
      | esbuild            |   0.37s |                1x |  1479.6 kloc/s |      5.80mb |
      | esbuild (1 thread) |   1.54s |                4x |   355.5 kloc/s |      5.80mb |
      | rollup + terser    |  36.00s |               97x |    15.2 kloc/s |      5.81mb |
      | webpack 4          |  41.91s |              113x |    13.1 kloc/s |      5.97mb |
      | webpack 5          |  54.50s |              147x |    10.0 kloc/s |      5.84mb |
      | parcel 2           |  56.71s |              153x |     9.7 kloc/s |      5.92mb |
      | parcel 1           | 118.51s |              320x |     4.6 kloc/s |      5.89mb |

  - p: >
      Each time reported is the best of three runs. I'm running esbuild with
      <code>--bundle <wbr>--minify <wbr>--sourcemap</code> (the
      single-threaded version uses `GOMAXPROCS=1`). I used the
      <code>rollup-<wbr>plugin-<wbr>terser</code> plugin because Rollup
      itself doesn't support minification. Webpack uses
      <code>--mode=<wbr>production <wbr>--devtool=<wbr>sourcemap</code>.
      Parcel uses the default options. Absolute speed is based on the total
      line count including comments and blank lines, which is currently 547,441.
      The tests were done on a 6-core 2019 MacBook Pro with 16gb of RAM.

  - p: >
      Caveats:

  - ul:
      - 'Parcel 1: The bundle crashes at run time with <code>TypeError:
        <wbr>Cannot <wbr>redefine <wbr>property: <wbr>dynamic</code>'

  - figcaption: TypeScript benchmark
  - benchmark:
      '[esbuild](https://github.com/evanw/esbuild)': 0.09
      '[esbuild](https://github.com/evanw/esbuild) (1 thread)': 0.37
      '[webpack](https://github.com/webpack/webpack) 4': 18.38
      '[parcel](https://github.com/parcel-bundler/parcel) 1': 18.76
      '[webpack](https://github.com/webpack/webpack) 5': 25.12
      '[parcel](https://github.com/parcel-bundler/parcel) 2': 42.32

  - p: >
      This benchmark uses the [Rome](https://github.com/facebookexperimental/rome)
      build tool to approximate a large TypeScript codebase. All code must be
      combined into a single minified bundle with source maps and the resulting
      bundle must work correctly. The benchmark can be run with `make bench-rome`
      in the [esbuild repo](https://github.com/evanw/esbuild).

  - table: |
      | Bundler            |    Time | Relative slowdown | Absolute speed | Output size |
      | :----------------- | ------: | ----------------: | -------------: | ----------: |
      | esbuild            |   0.09s |                1x |  1464.8 kloc/s |      0.97mb |
      | esbuild (1 thread) |   0.37s |                4x |   356.3 kloc/s |      0.97mb |
      | webpack 4          |  18.38s |              204x |     7.2 kloc/s |      1.26mb |
      | parcel 1           |  18.76s |              208x |     7.0 kloc/s |      1.56mb |
      | webpack 5          |  24.57s |              273x |     5.4 kloc/s |      1.26mb |
      | parcel 2           |  42.32s |              470x |     3.1 kloc/s |      1.68mb |

  - p: >
      Each time reported is the best of three runs. I'm running esbuild with
      <code>--bundle <wbr>--minify <wbr>--sourcemap
      <wbr>--platform=<wbr>node</code> (the single-threaded version uses
      `GOMAXPROCS=1`). Webpack uses `ts-loader` with <code>transpileOnly:
      <wbr>true</code> and <code>--mode=<wbr>production
      <wbr>--devtool=<wbr>sourcemap</code>. Parcel 1 uses <code>--target
      <wbr>node --bundle-<wbr>node-<wbr>modules</code>. Parcel 2 uses
      <code>"engines": <wbr>"node"</code> in <code>package.json</code> and
      needs the <code>@parcel/<wbr>transformer-<wbr>typescript-<wbr>tsc</code>
      transformer to be able to handle the TypeScript code used in the
      benchmark. Absolute speed is based on the total line count including
      comments and blank lines, which is currently 131,836. The tests were done
      on a 6-core 2019 MacBook Pro with 16gb of RAM.

  - p: >
      The results don't include Rollup because I couldn't get it to work. I
      tried <code>rollup-<wbr>plugin-<wbr>typescript</code>,
      <code>@rollup/<wbr>plugin-<wbr>typescript</code>, and
      <code>@rollup/<wbr>plugin-<wbr>sucrase</code> and they all didn't work
      for different reasons relating to TypeScript compilation.

  - h2: Upcoming roadmap

  - p: >
      These features are already in progress and are first priority:

  - ul:
    - 'Code splitting ([#16](https://github.com/evanw/esbuild/issues/16), [docs](/api/#splitting))'
    - 'CSS content type ([#20](https://github.com/evanw/esbuild/issues/20), [docs](/content-types/#css))'
    - 'Plugin API ([#111](https://github.com/evanw/esbuild/issues/111))'

  - p: >
      These are potential future features but may not happen or may happen
      to a more limited extent:

  - ul:
    - 'HTML content type ([#31](https://github.com/evanw/esbuild/issues/31))'
    - 'Lowering to ES5 ([#297](https://github.com/evanw/esbuild/issues/297))'
    - 'Bundling top-level await ([#253](https://github.com/evanw/esbuild/issues/253))'

  - p: >
      After that point, I will consider esbuild to be relatively complete.
      I'm planning for esbuild to reach a mostly stable state and then stop
      accumulating more features. This will involve saying "no" to requests
      for adding major features to esbuild itself. I don't think esbuild
      should become an all-in-one solution for all frontend needs. In
      particular, I want to avoid the pain and problems of the "webpack
      config" model where the underlying tool is too flexible and usability
      suffers.

  - p: >
      For example, I am _not_ planning to include these features in esbuild's
      core itself:

  - ul:
    - 'Support for other frontend languages (e.g. [Elm](https://elm-lang.org/),
      [Svelte](https://svelte.dev/), [Vue](https://vuejs.org/),
      [Angular](https://angular.io/))'
    - TypeScript type checking (just run `tsc` separately)
    - An API for custom AST manipulation
    - Hot-module reloading
    - Module federation

  - p: >
      I hope that the extensibility points I'm adding to esbuild
      ([plugins](/plugins/) and the [API](/api/)) will make esbuild useful to
      include as part of more customized build workflows, but I'm not
      intending or expecting these extensibility points to cover all use
      cases. If you have very custom requirements then you should be using
      other tools. I also hope esbuild inspires other build tools to
      dramatically improve performance by overhauling their implementations
      so that everyone can benefit, not just those that use esbuild.

  - p: >
      I am planning to continue to maintain everything in esbuild's existing
      scope even after esbuild reaches stability. This means implementing
      support for newly-released JavaScript and TypeScript syntax features,
      for example.

  - h2: Production readiness

  - p: >
      This project has not yet hit version 1.0.0 and is still in active
      development. That said, it is far beyond the alpha stage and is pretty
      stable. I think of it as a late-stage beta. For some early-adopters
      that means it's good enough to use for real things. Some other people
      think this means esbuild isn't ready yet. This section doesn't try to
      convince you either way. It just tries to give you enough information
      so you can decide for yourself whether you want to use esbuild as your
      bundler.

  - p: >
      Some data points:

  - ul:
    - >
      **Used by other projects**
      <p>
      The API is already being used as a library within some other
      developer tools. For example, [Vite](https://github.com/vitejs/vite)
      and [Snowpack](https://github.com/pikapkg/snowpack) are using
      esbuild's [transform API](/api/#transform-api) to transform
      TypeScript into JavaScript. And [Hugo](https://github.com/gohugoio/hugo)
      is using esbuild's bundler to package JavaScript code during a build.
      I have also heard reports of others using it in production successfully,
      although I don't know the details. I intend to use esbuild in
      production myself once it has enough features but haven't done that yet.
      </p>

    - >
      **API stability**
      <p>
      Even though esbuild's version is not yet 1.0.0, effort is still made to
      keep the API stable. Patch versions are intended for backwards-compatible
      changes and minor versions are intended for backwards-incompatible changes
      (as [recommended by npm](https://docs.npmjs.com/misc/semver)). If you
      plan to use esbuild for something real, you should either pin the exact
      version (maximum safety) or pin the major and minor versions (only accept
      backwards-compatible upgrades).
      </p>

    - >
      **Only one main developer**
      <p>
      This tool is primarily built by [me](https://github.com/evanw). For
      some people this is fine, but for others this means esbuild is not a
      suitable tool for their organization. That's ok with me. I'm building
      esbuild because I find it fun to build and because it's the tool I'd
      want to use. I'm sharing it with the world because there are others
      that want to use it too, because the feedback makes the tool itself
      better, and because I think it will inspire the ecosystem to make
      better tools.
      </p>

    - >
      **Not always open to scope expansion**
      <p>
      I'm not planning on including major features that I'm not interested
      in building and/or maintaining. I also want to limit the project's
      scope so it doesn't get too complex and unwieldy, both from an
      architectural perspective, a testing and correctness perspective, and
      from a usability perspective. Think of esbuild as a "linker" for the
      web. It knows how to transform and bundle JavaScript and CSS. But the
      details of how your source code ends up as plain JavaScript or CSS
      may need to be 3rd-party code.
      </p>
      <p>
      I'm hoping that [plugins](/plugins/) will allow the community to add
      major features (e.g. WebAssembly import) without needing to contribute
      to esbuild itself. However, not everything is exposed in the plugin
      API and it may be the case that it's not possible to add a particular
      feature to esbuild that you may want to add. This is intentional;
      esbuild is not meant to be an all-in-one solution for all frontend
      needs.
      </p>
