title: API
body:
  - h1: API
  - p: >
<<<<<<< HEAD
      可以通过如下三种方式调用 API：在命令行中调用，在 JavaScript 中调用，
      在 Go 中调用。
      概念和参数在这三种方式中基本相同，因此本文档将三种方式的 API 文档合并显示，
      不再按照不同的使用方式来拆分文档。

  - p: >
      在 esbuild 的 API 中有两种主要的 API 调用：[transform](#transform-api)
      与 [build](#build-api)。理解使用哪一个 API 对你而言十分重要，
      因为他们的工作方式不同。

  - p: >
<<<<<<< HEAD
      如果你是用的是 JavaScript，请务必阅读下面的 [JS 特殊细节](#js-specific-details) 章节。
      你也可以查看 esbuild 的 [TypeScript 类型定义](https://github.com/evanw/esbuild/blob/master/lib/types.ts)
      作为参考，这会对你有帮助。如果正在使用 Go 语言，请务必阅读自动生成的
       [Go 文档](https://pkg.go.dev/github.com/evanw/esbuild/pkg/api)。
=======
      If you are using JavaScript be sure to check out the
      [JS-specific details](#js-specific-details) section below. You may also
      find the [TypeScript type definitions](https://github.com/evanw/esbuild/blob/master/lib/shared/types.ts)
      for esbuild helpful as a reference. If you are using Go be sure to check
      out the automatically generated [Go documentation](https://pkg.go.dev/github.com/evanw/esbuild/pkg/api).
>>>>>>> 2e131b091e6a1dd99b9a331f6f3c75534bf796be

  - p: >
      If you are using the command-line API, it may be helpful to know that the
=======
      The API can be accessed in one of three languages: on the command line, in
      JavaScript, and in Go. The concepts and parameters are largely identical
      between the three languages so they will be presented together here
      instead of having separate documentation for each language. You can switch
      between languages using the `CLI`, `JS`, and `Go` tabs in the top-right
      corner of each code example. Some specifics for each language:

  - ul:
    - >
      <p>
      **CLI:** If you are using the command-line API, it may be helpful to know that the
>>>>>>> 64a7cbf09ed21d61e6fe85529b31e5676fa14bfe
      flags come in one of three forms: `--foo`, `--foo=bar`, or `--foo:bar`.
      The form `--foo` is used for enabling boolean flags such as [`--minify`](#minify),
      the form `--foo=bar` is used for flags that have a single value and are
      only specified once such as [`--platform=`](#platform), and the form
      `--foo:bar` is used for flags that have multiple values and can be
      re-specified multiple times such as [`--external:`](#external).
      </p>

    - >
      <p>
      **JavaScript:** If you are using JavaScript be sure to check out the
      [JS-specific details](#js-details) and [browser](#browser)
      sections below. You may also find the
      [TypeScript type definitions](https://github.com/evanw/esbuild/blob/main/lib/shared/types.ts)
      for esbuild helpful as a reference.
      </p>

    - >
      <p>
      **Go:** If you are using Go, you may find the automatically generated
      Go documentation for esbuild helpful as a reference. There is separate
      documentation for both of the public Go packages:
      [`pkg/api`](https://pkg.go.dev/github.com/evanw/esbuild/pkg/api)
      and [`pkg/cli`](https://pkg.go.dev/github.com/evanw/esbuild/pkg/cli).
      </p>

  - h2: Overview

  - p: >
<<<<<<< HEAD
      transform API 操作单个字符串，而不访问文件系统。
      这使其能够比较理想地在没有文件系统的环境中使用（比如浏览器）或者作为另一个工具链的一部分。
      以下是一个比较简单的 transform 示例：
=======
      The two most commenly-used esbuild APIs are [build](#build) and [transform](#transform).
      Each is described below at a high level, followed by documentation
      for each individual API option.

  - h3: Build

  - p: >
      This is the primary interface to esbuild. You typically pass one or more
      [entry point](#entry-points) files to process along with various options,
      and then esbuild writes the results back out to the file system. Here's a
      simple example that enables [bundling](#bundle) with an [output directory](#outdir):
>>>>>>> 64a7cbf09ed21d61e6fe85529b31e5676fa14bfe

  - example:
      in:
        app.ts: '1+2'

      cli: |
        esbuild app.ts --bundle --outdir=dist

      mjs: |
        import * as esbuild from 'esbuild'

        let result = await esbuild.build({
          entryPoints: ['app.ts'],
          bundle: true,
          outdir: 'dist',
        })
        console.log(result)

      go: |
        package main

<<<<<<< HEAD
        import "fmt"
        import "github.com/evanw/esbuild/pkg/api"

        func main() {
          result := api.Transform("let x: number = 1", api.TransformOptions{
            Loader: api.LoaderTS,
          })

          if len(result.Errors) == 0 {
            fmt.Printf("%s", result.Code)
          }
        }

  - p: >
      如果没有提供输入的文件并且没有 `--bundle` 标志的话，命令行接口就会调用此 API。
      在这个用例中，输入的字符串来自标准输入（stdin），并且输出字符串转到标准输出（stdout）。
      transform API 可以使用以下配置项：

  - available-options:
<<<<<<< HEAD
      - Banner
      - Charset
      - Color
      - Define
      - Footer
      - Format
      - Global name
      - Ignore annotations
      - JSX
      - JSX factory
      - JSX fragment
      - Keep names
      - Legal comments
      - Loader
      - Log level
      - Log limit
      - Minify
      - Pure
      - Source Root
      - Sourcefile
      - Sourcemap
      - Sources Content
      - Target
      - Tree shaking
      - Tsconfig raw
=======
    - Banner
    - Charset
    - Color
    - Define
    - Drop
    - Footer
    - Format
    - Global name
    - Ignore annotations
    - JSX
    - JSX factory
    - JSX fragment
    - Keep names
    - Legal comments
    - Loader
    - Log level
    - Log limit
    - Mangle props
    - Minify
    - Pure
    - Source root
    - Sourcefile
    - Sourcemap
    - Sources content
    - Target
    - Tree shaking
    - Tsconfig raw
>>>>>>> 2e131b091e6a1dd99b9a331f6f3c75534bf796be

  - h2: Build API

  - p: >
      调用 build API 操作文件系统中的一个或多个文件。
      它允许文件互相引用并且打包在一起。
      这里是一个简单的 build 用例：

  - example:
      cli:
        - $: |
            echo 'let x: number = 1' > in.ts
        - $: |
            esbuild in.ts --outfile=out.js
        - $: |
            cat out.js
        - expect: |
            let x = 1;

      js:
        - $: |
            require('fs').writeFileSync('in.ts', 'let x: number = 1')
        - $: |
            require('esbuild').buildSync({
              entryPoints: ['in.ts'],
              outfile: 'out.js',
            })
        - expect: |
            { errors: [], warnings: [] }
        - $: |
            require('fs').readFileSync('out.js', 'utf8')
        - expect: |
            'let x = 1;\n'

      go: |
        package main

        import "io/ioutil"
=======
>>>>>>> 64a7cbf09ed21d61e6fe85529b31e5676fa14bfe
        import "github.com/evanw/esbuild/pkg/api"
        import "os"

        func main() {
          result := api.Build(api.BuildOptions{
            EntryPoints: []string{"app.ts"},
            Bundle:      true,
            Outdir:      "dist",
          })
          if len(result.Errors) != 0 {
            os.Exit(1)
          }
        }

  - p: >
<<<<<<< HEAD
      如果至少提供一个输入文件或者存在 `--bundle` 标志，
      那么命令行接口会调用该 API。
      请注意 esbuild _不会_ 默认打包。
      你必须传递 `--bundle` 标志启用打包。
      如果没有提供输入文件，则从标准化输入（stdin）读取单个输入文件。
      build API 可以使用以下配置项：

  - available-options:
<<<<<<< HEAD
      - Allow overwrite
      - Analyze
      - Asset names
      - Banner
      - Bundle
      - Charset
      - Chunk names
      - Color
      - Conditions
      - Define
      - Entry names
      - Entry points
      - External
      - Footer
      - Format
      - Global name
      - Ignore annotations
      - Incremental
      - Inject
      - JSX
      - JSX factory
      - JSX fragment
      - Keep names
      - Legal comments
      - Loader
      - Log level
      - Log limit
      - Main fields
      - Metafile
      - Minify
      - Node paths
      - Out extension
      - Outbase
      - Outdir
      - Outfile
      - Platform
      - Preserve symlinks
      - Public path
      - Pure
      - Resolve extensions
      - Serve
      - Source Root
      - Sourcefile
      - Sourcemap
      - Sources Content
      - Splitting
      - Stdin
      - Target
      - Tree shaking
      - Tsconfig
      - Watch
      - Working directory
      - Write
=======
=======
      Advanced use of the build API involves setting up a long-running build
      context. This context is an explicit object in JS and Go but is implicit
      with the CLI. All builds done with a given context share the same build
      options, and subsequent builds are done incrementally (i.e. they reuse
      some work from previous builds to improve performance). This is useful
      for development because esbuild can rebuild your app in the background
      for you while you work.

  - p: >
      There are three different incremental build APIs:

  - ul:
    - >
      [**Watch mode**](#watch) tells esbuild to watch the file system and
      automatically rebuild for you whenever you edit and save a file that
      could invalidate the build. Here's an example:

  - example:
      noCheck: true

      cli:
        - $: |
            esbuild app.ts --bundle --outdir=dist --watch
        - expect: |
            [watch] build finished, watching for changes...

      mjs: |
        let ctx = await esbuild.context({
          entryPoints: ['app.ts'],
          bundle: true,
          outdir: 'dist',
        })

        await ctx.watch()

      go: |
        ctx, err := api.Context(api.BuildOptions{
          EntryPoints: []string{"app.ts"},
          Bundle:      true,
          Outdir:      "dist",
        })

        err2 := ctx.Watch(api.WatchOptions{})

  - ul:
    - >
      [**Serve mode**](#serve) starts a local development server that serves the
      results of the latest build. Incoming requests automatically start new
      builds so your web app is always up to date when you reload the page in
      the browser. Here's an example:

  - example:
      noCheck: true

      cli:
        - $: |
            esbuild app.ts --bundle --outdir=dist --serve
        - expect: |2

             > Local:   http://127.0.0.1:8000/
             > Network: http://192.168.0.1:8000/

            127.0.0.1:61302 - "GET /" 200 [1ms]

      mjs: |
        let ctx = await esbuild.context({
          entryPoints: ['app.ts'],
          bundle: true,
          outdir: 'dist',
        })

        let { host, port } = await ctx.serve()

      go: |
        ctx, err := api.Context(api.BuildOptions{
          EntryPoints: []string{"app.ts"},
          Bundle:      true,
          Outdir:      "dist",
        })

        server, err2 := ctx.Serve(api.ServeOptions{})

  - ul:
    - >
      [**Rebuild mode**](#rebuild) lets you manually invoke a build. This is useful
      when integrating esbuild with other tools (e.g. using a custom file watcher
      or development server instead of esbuild's built-in ones). Here's an example:

  - example:
      noCheck: true

      cli: |
        # The CLI does not have an API for "rebuild"

      mjs: |
        let ctx = await esbuild.context({
          entryPoints: ['app.ts'],
          bundle: true,
          outdir: 'dist',
        })

        for (let i = 0; i < 5; i++) {
          let result = await ctx.rebuild()
        }

      go: |
        ctx, err := api.Context(api.BuildOptions{
          EntryPoints: []string{"app.ts"},
          Bundle:      true,
          Outdir:      "dist",
        })

        for i := 0; i < 5; i++ {
          result := ctx.Rebuild()
        }

  - p: >
      These three incremental build APIs can be combined. To enable [live reloading](#live-reload)
      (automatically reloading the page when you edit and save a file) you'll need
      to enable [watch](#watch) and [serve](#serve) together on the same context.

  - p: >
      When you are done with a context object, you can call `dispose()` on the
      context to wait for existing builds to finish, stop watch and/or serve mode,
      and free up resources.

  - p: >
      The build and context APIs both take the following options:

  - available-options:
    - Alias
>>>>>>> 64a7cbf09ed21d61e6fe85529b31e5676fa14bfe
    - Allow overwrite
    - Analyze
    - Asset names
    - Banner
    - Bundle
    - Charset
    - Chunk names
    - Color
    - Conditions
    - Define
    - Drop
    - Entry names
    - Entry points
    - External
    - Footer
    - Format
    - Format messages
    - Global name
    - Ignore annotations
    - Inject
    - JSX
    - JSX dev
    - JSX factory
    - JSX fragment
    - JSX import source
    - JSX side effects
    - Keep names
    - Legal comments
    - Live reload
    - Loader
    - Log level
    - Log limit
    - Log override
    - Main fields
    - Mangle props
    - Metafile
    - Minify
    - Node paths
    - Out extension
    - Outbase
    - Outdir
    - Outfile
    - Packages
    - Platform
    - Preserve symlinks
    - Public path
    - Pure
    - Rebuild
    - Resolve extensions
    - Serve
    - Source root
    - Sourcefile
    - Sourcemap
    - Sources content
    - Splitting
    - Stdin
    - Supported
    - Target
    - Tree shaking
    - Tsconfig
    - Watch
    - Working directory
    - Write
>>>>>>> 2e131b091e6a1dd99b9a331f6f3c75534bf796be

<<<<<<< HEAD
  - h2: 一般配置项
=======
  - h3: Transform

  - p: >
      This is a limited special-case of [build](#build) that transforms a string
      of code representing an in-memory file in an isolated environment that's
      completely disconnected from any other files. Common uses include minifying
      code and transforming TypeScript into JavaScript. Here's an example:

  - example:
      cli:
        - $: |
            echo 'let x: number = 1' | esbuild --loader=ts
        - expect: |
            let x = 1;

      mjs: |
        import * as esbuild from 'esbuild'

        let ts = 'let x: number = 1'
        let result = await esbuild.transform(ts, {
          loader: 'ts',
        })
        console.log(result)

      go: |
        package main

        import "fmt"
        import "github.com/evanw/esbuild/pkg/api"

        func main() {
          ts := "let x: number = 1"
          result := api.Transform(ts, api.TransformOptions{
            Loader: api.LoaderTS,
          })

          if len(result.Errors) == 0 {
            fmt.Printf("%s", result.Code)
          }
        }

  - p: >
      Taking a string instead of a file as input is more ergonomic for certain
      use cases. File system isolation has certain advantages (e.g. works in the
      browser, not affected by nearby `package.json` files) and certain
      disadvantages (e.g. can't be used with [bundling](#bundle) or
      [plugins](/plugins/)). If your use case doesn't fit the transform API then
      you should use the more general [build](#build) API instead.

  - p: >
      The transform API takes the following options:

  - available-options:
    - Banner
    - Charset
    - Color
    - Define
    - Drop
    - Footer
    - Format
    - Format messages
    - Global name
    - Ignore annotations
    - JSX
    - JSX dev
    - JSX factory
    - JSX fragment
    - JSX import source
    - JSX side effects
    - Keep names
    - Legal comments
    - Loader
    - Log level
    - Log limit
    - Log override
    - Mangle props
    - Minify
    - Platform
    - Pure
    - Source root
    - Sourcefile
    - Sourcemap
    - Sources content
    - Supported
    - Target
    - Tree shaking
    - Tsconfig raw

  - h3#js-details: JS-specific details

  - p: >
      The JS API for esbuild comes in both asynchronous and synchronous flavors.
      The [asynchronous API](#js-async) is recommended because it works in all
      environments and it's faster and more powerful. The [synchronous API](#js-sync)
      only works in node and can only do certain things, but it's sometimes
      necessary in certain node-specific situations. In detail:

  - h4#js-async: Async API

  - p: >
      Asynchronous API calls return their results using a promise. Note that
      you'll likely have to use the `.mjs` file extension in node due to the
      use of the `import` and top-level `await` keywords:

  - pre.js: |
      import * as esbuild from 'esbuild'

      let result1 = await esbuild.transform(code, options)
      let result2 = await esbuild.build(options)

  - p: >
      Pros:

  - ul:
    - >
      You can use [plugins](/plugins/) with the asynchronous API
    - >
      The current thread is not blocked so you can perform other work in the meantime
    - >
      You can run many simultaneous esbuild API calls concurrently which are
      then spread across all available CPUs for maximum performance

  - p: >
      Cons:

  - ul:
    - >
      Using promises can result in messier code, especially in CommonJS where
      [top-level await](https://v8.dev/features/top-level-await) is not available
    - >
      Doesn't work in situations that must be synchronous such as within
      <a href="https://nodejs.org/api/modules.html#requireextensions"><code>require<wbr>.extensions</code></a>

  - h4#js-sync: Sync API

  - p: >
      Synchronous API calls return their results inline:

  - pre.js: |
      let esbuild = require('esbuild')

      let result1 = esbuild.transformSync(code, options)
      let result2 = esbuild.buildSync(options)

  - p: >
      Pros:

  - ul:
    - >
      Avoiding promises can result in cleaner code, especially when
      [top-level await](https://v8.dev/features/top-level-await) is not available
    - >
      Works in situations that must be synchronous such as within
      <a href="https://nodejs.org/api/modules.html#requireextensions"><code>require<wbr>.extensions</code></a>

  - p: >
      Cons:

  - ul:
    - >
      You can't use [plugins](/plugins/) with the synchronous API since plugins are asynchronous
    - >
      It blocks the current thread so you can't perform other work in the meantime
    - >
      Using the synchronous API prevents esbuild from parallelizing esbuild API calls

  - h3#browser: In the browser

  - p: >
      The esbuild API can also run in the browser using WebAssembly in a Web
      Worker. To take advantage of this you will need to install the
      `esbuild-wasm` package instead of the `esbuild` package:

  - pre: |
      npm install esbuild-wasm

  - p: >
      The API for the browser is similar to the API for node except that you
      need to call `initialize()` first, and you need to pass the URL of
      the WebAssembly binary. The synchronous versions of the API are also
      not available. Assuming you are using a bundler, that would look
      something like this:

  - pre.js: |
      import * as esbuild from 'esbuild-wasm'

      await esbuild.initialize({
        wasmURL: './node_modules/esbuild-wasm/esbuild.wasm',
      })

      let result1 = await esbuild.transform(code, options)
      let result2 = esbuild.build(options)

  - p: >
      If you're already running this code from a worker and don't want
      `initialize` to create another worker, you can pass <code>worker: <wbr>false</code>
      to it. Then it will create a WebAssembly module in the same thread
      as the thread that calls `initialize`.

  - p: >
      You can also use esbuild's API as a script tag in a HTML file without
      needing to use a bundler by loading the `lib/browser.min.js` file with
      a `<script>` tag. In this case the API creates a global called `esbuild`
      that holds the API object:

  - pre.html: |
      <script src="./node_modules/esbuild-wasm/lib/browser.min.js"></script>
      <script>
        esbuild.initialize({
          wasmURL: './node_modules/esbuild-wasm/esbuild.wasm',
        }).then(() => {
          ...
        })
      </script>

  - p: >
      If you want to use this API with ECMAScript modules, you should import
      the `esm/browser.min.js` file instead:

  - pre.html: |
      <script type="module">
        import * as esbuild from './node_modules/esbuild-wasm/esm/browser.min.js'

        await esbuild.initialize({
          wasmURL: './node_modules/esbuild-wasm/esbuild.wasm',
        })

        ...
      </script>

  - h2: General options
>>>>>>> 64a7cbf09ed21d61e6fe85529b31e5676fa14bfe

  - h3: Bundle

  - p: >
      打包一个文件意味着将任何导入的依赖项内联到文件中。
      这个过程是递归的，因为依赖的依赖（等等）也将被内联。
      默认情况下，esbuild 将 _不会_ 打包输入的文件。
      打包必须想这样显式启用：

  - example:
      in:
        in.js: "1 + 2"

      cli: |
        esbuild in.js --bundle

      mjs: |
        import * as esbuild from 'esbuild'

        console.log(await esbuild.build({
          entryPoints: ['in.js'],
          bundle: true,
          outfile: 'out.js',
        }))

      go: |
        package main

        import "github.com/evanw/esbuild/pkg/api"
        import "os"

        func main() {
          result := api.Build(api.BuildOptions{
            EntryPoints: []string{"in.js"},
            Bundle:      true,
          })

          if len(result.Errors) > 0 {
            os.Exit(1)
          }
        }

  - p: >
      点击 [快速开始指引](/getting-started/#your-first-bundle)
      查看打包实际代码的例子。

  - p: >
      请注意打包与文件连接不同。在启用打包时向 esbuild 传递多个输入文件
      将创建两个单独的 bundle 而不是将输入文件连接在一起。
      为了使用 esbuild 将一系列文件打包在一起，
      在一个入口起点文件中引入所有文件，
      然后就像打包一个文件那样将它们打包。

  - h4: Non-analyzable imports

  - p: >
      Bundling with esbuild only works with statically-defined imports
      (i.e. when the import path is a string literal). Imports that are
      defined at run-time (i.e. imports that depend on run-time code
      evaluation) are not bundled, since bundling is a compile-time
      operation. For example:

  - pre.js: |
      // Analyzable imports (will be bundled by esbuild)
      import 'pkg';
      import('pkg');
      require('pkg');

      // Non-analyzable imports (will not be bundled by esbuild)
      import(`pkg/${foo}`);
      require(`pkg/${foo}`);
      ['pkg'].map(require);

  - p: >
      The way to work around this issue is to mark the package containing this
      problematic code as [external](#external) so that it's not included in
      the bundle. You will then need to ensure that a copy of the external
      package is available to your bundled code at run-time.

  - p: >
      Some bundlers such as [Webpack](https://webpack.js.org/) try to support
      this by including all potentially-reachable files in the bundle and then
      emulating a file system at run-time. However, run-time file system
      emulation is out of scope and will not be implemented in esbuild. If you
      really need to bundle code that does this, you will likely need to use
      another bundler instead of esbuild.

  - h3: Live reload

  - p: >
<<<<<<< HEAD
      该特性提供了一种用常量表达式替换全局标识符的方法。
      它可以在不改变代码本身的情况下改变某些构建之间代码的行为:

  - example:
      cli:
        - $: |
            echo 'hooks = DEBUG && require("hooks")' | esbuild --define:DEBUG=true
        - expect: |
            hooks = require("hooks");

        - $: |
            echo 'hooks = DEBUG && require("hooks")' | esbuild --define:DEBUG=false
        - expect: |
            hooks = false;

      js:
        - $: let js = 'hooks = DEBUG && require("hooks")'

        - $: |
            require('esbuild').transformSync(js, {
              define: { DEBUG: 'true' },
            })
        - expect: |
            {
              code: 'hooks = require("hooks");\n',
              map: '',
              warnings: []
            }

        - $: |
            require('esbuild').transformSync(js, {
              define: { DEBUG: 'false' },
            })
        - expect: |
            {
              code: 'hooks = false;\n',
              map: '',
              warnings: []
            }
=======
      Live reload is an approach to development where you have your browser
      open and visible at the same time as your code editor. When you edit
      and save your source code, the browser automatically reloads and the
      reloaded version of the app contains your changes. This means you can
      iterate faster because you don't have to manually switch to your browser,
      reload, and then switch back to your code editor after every change.
      It's very helpful when changing CSS, for example.

  - p: >
      There is no esbuild API for live reloading directly. Instead, you can
      construct live reloading by combining [watch mode](#watch) (to
      automatically start a build when you edit and save a file) and
      [serve mode](#serve) (to serve the latest build, but block until it's
      done) plus a small bit of client-side JavaScript code that you add to
      your app only during development.

  - p: >
      The first step is to enable [watch](#watch) and [serve](#serve) together:

  - example:
      noCheck: true

      cli: |
        esbuild app.ts --bundle --outdir=www --watch --servedir=www

      mjs: |
        import * as esbuild from 'esbuild'

        let ctx = await esbuild.context({
          entryPoints: ['app.ts'],
          bundle: true,
          outdir: 'www',
        })

        await ctx.watch()

        let { host, port } = await ctx.serve({
          servedir: 'www',
        })
>>>>>>> 64a7cbf09ed21d61e6fe85529b31e5676fa14bfe

      go: |
        package main

        import "github.com/evanw/esbuild/pkg/api"
        import "os"

        func main() {
<<<<<<< HEAD
          js := "hooks = DEBUG && require('hooks')"

          result1 := api.Transform(js, api.TransformOptions{
            Define: map[string]string{"DEBUG": "true"},
=======
          ctx, err := api.Context(api.BuildOptions{
            EntryPoints: []string{"app.ts"},
            Bundle:      true,
            Outdir:      "www",
>>>>>>> 64a7cbf09ed21d61e6fe85529b31e5676fa14bfe
          })
          if err != nil {
            os.Exit(1)
          }

          err2 := ctx.Watch(api.WatchOptions{})
          if err2 != nil {
            os.Exit(1)
          }

          result, err3 := ctx.Serve(api.ServeOptions{
            Servedir: "www",
          })
          if err3 != nil {
            os.Exit(1)
          }
        }

  - p: >
<<<<<<< HEAD
      替换表达式必须是一个 JSON 对象（null、boolean、number、string、array 或者 object）
      或者一个标识符。除了数组和对象之外，替换表达式是内联替换的，这意味着他们可以参与常数折叠。
      数组与对象替换表达式会被存储在一个变量中，然后被标识符引用而不是内联替换，
      这避免了替换重复复制一个值，但也意味着该值不能参与常数折叠。

  - p: >
      如果你想用字符串字面值替换某些东西，记住，传递给esbuild的替换值本身必须包含引号。
      省略引号意味着替换的值是一个标识符：
=======
      The second step is to add some code to your JavaScript that subscribes to
      the `/esbuild` [server-sent event](https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events/Using_server-sent_events)
      source. When you get the `change` event, you can reload the page to get
      the latest version of the app. You can do this in a single line of code:

  - pre.js: |
      new EventSource('/esbuild').addEventListener('change', () => location.reload())

  - p: >
      That's it! If you load your app in the browser, the page should now
      automatically reload when you edit and save a file (assuming there are
      no build errors).

  - p: >
      This should only be included during development, and should not be included
      in production. One way to remove this code in production is to guard it with
      an if statement such as `if (!window.IS_PRODUCTION)` and then use [define](#define)
      to set `window.IS_PRODUCTION` to `true` in production.

  - h4#live-reload-caveats: Live reload caveats

  - p: >
      Implementing live reloading like this has a few known caveats:

  - ul:
    - >
      <p>
      These events only trigger when esbuild's output changes. They do not trigger
      when files unrelated to the build being watched are changed. If your HTML
      file references other files that esbuild doesn't know about and those files
      are changed, you can either manually reload the page or you can implement
      your own live reloading infrastructure instead of using esbuild's built-in
      behavior.
      </p>

    - >
      <p>
      The `EventSource` API is supposed to automatically reconnect for you. However,
      there's [a bug in Firefox](https://bugzilla.mozilla.org/show_bug.cgi?id=1809332)
      that breaks this if the server is ever temporarily unreachable. Workarounds
      are to use any other browser, to manually reload the page if this happens, or
      to write more complicated code that manually closes and re-creates the
      `EventSource` object if there is a connection error.
      </p>

    - >
      <p>
      Browser vendors have decided to not implement HTTP/2 without TLS. This
      means that when using the `http://` protocol, each `/esbuild` event source
      will take up one of your precious 6 simultaneous per-domain HTTP/1.1
      connections. So if you open more than six HTTP tabs that use this
      live-reloading technique, you will be unable to use live reloading in
      some of those tabs (and other things will likely also break). The
      workaround is to [enable the `https://` protocol](#https).
      </p>


  - h4#hot-reloading-css: Hot-reloading for CSS

  - p: >
      The `change` event also contains additional information to enable more
      advanced use cases. It currently contains the `added`, `removed`, and
      `updated` arrays with the paths of the files that have changed since the
      previous build, which can be described by the following TypeScript
      interface:

  - pre.js: |
      interface ChangeEvent {
        added: string[]
        removed: string[]
        updated: string[]
      }

  - p: >
      The code sample below enables "hot reloading" for CSS, which is when the
      CSS is automatically updated in place without reloading the page. If an
      event arrives that isn't CSS-related, then the whole page will be
      reloaded as a fallback:

  - pre.js: |
      new EventSource('/esbuild').addEventListener('change', e => {
        const { added, removed, updated } = JSON.parse(e.data)

        if (!added.length && !removed.length && updated.length === 1) {
          for (const link of document.getElementsByTagName("link")) {
            const url = new URL(link.href)

            if (url.host === location.host && url.pathname === updated[0]) {
              const next = link.cloneNode()
              next.href = updated[0] + '?' + Math.random().toString(36).slice(2)
              next.onload = () => link.remove()
              link.parentNode.insertBefore(next, link.nextSibling)
              return
            }
          }
        }

        location.reload()
      })

  - h4#hot-reloading-js: Hot-reloading for JavaScript

  - p: >
      Hot-reloading for JavaScript is not currently implemented by esbuild.
      It's possible to transparently implement hot-reloading for CSS because
      CSS is stateless, but JavaScript is stateful so you cannot transparently
      implement hot-reloading for JavaScript like you can for CSS.

  - p: >
      Some other development servers implement hot-reloading for JavaScript
      anyway, but it requires additional APIs, sometimes requires framework-specific
      hacks, and sometimes introduces transient state-related bugs during an
      editing session. Doing this is outside of esbuild's scope. You are
      welcome to use other tools instead of esbuild if hot-reloading for
      JavaScript is one of your requirements.

  - p: >
      However, with esbuild's live-reloading you can persist your app's current
      JavaScript state in [`sessionStorage`](https://developer.mozilla.org/en-US/docs/Web/API/Window/sessionStorage)
      to more easily restore your app's JavaScript state after a page reload.
      If your app loads quickly (which it already should for your users' sake),
      live-reloading with JavaScript can be almost as fast as hot-reloading
      with JavaScript would be.

  - h3: Platform

  - p: >
      By default, esbuild's bundler is configured to generate code intended for
      the browser. If your bundled code is intended to run in node instead, you
      should set the platform to `node`:
>>>>>>> 64a7cbf09ed21d61e6fe85529b31e5676fa14bfe

  - example:
      in:
        app.js: '1 + 2'

      cli: |
        esbuild app.js --bundle --platform=node

      mjs: |
        import * as esbuild from 'esbuild'

        await esbuild.build({
          entryPoints: ['app.js'],
          bundle: true,
          platform: 'node',
          outfile: 'out.js',
        })

      go: |
        package main

        import "github.com/evanw/esbuild/pkg/api"
        import "os"

        func main() {
          result := api.Build(api.BuildOptions{
            EntryPoints: []string{"app.js"},
            Bundle:      true,
            Platform:    api.PlatformNode,
            Write:       true,
          })

          if len(result.Errors) > 0 {
            os.Exit(1)
          }
        }

  - p: >
      When the platform is set to `browser` (the default value):

  - ul:
    - >
      <p>
      When [bundling](#bundle) is enabled the default output [format](#format)
      is set to `iife`, which wraps the generated JavaScript code in an
      immediately-invoked function expression to prevent variables from leaking
      into the global scope.
      </p>
    - >
      <p>
      If a package specifies a map for the
      [`browser`](https://gist.github.com/defunctzombie/4339901/49493836fb873ddaa4b8a7aa0ef2352119f69211)
      field in its `package.json` file, esbuild will use that map to replace
      specific files or modules with their browser-friendly versions. For
      example, a package might contain a substitution of [`path`](https://nodejs.org/api/path.html)
      with [`path-browserify`](https://www.npmjs.com/package/path-browserify).
      </p>
    - >
      <p>
      The [main fields](#main-fields) setting is set to <code>browser,<wbr>module,<wbr>main</code>
      but with some additional special behavior: if a package provides `module`
      and `main` entry points but not a `browser` entry point then `main` is
      used instead of `module` if that package is ever imported using `require()`.
      This behavior improves compatibility with CommonJS modules that export a
      function by assigning it to `module.exports`. If you want to disable this
      additional special behavior, you can explicitly set the [main fields](#main-fields)
      setting to <code>browser,<wbr>module,<wbr>main</code>.
      </p>
    - >
      <p>
      The [conditions](#conditions) setting automatically includes the `browser`
      condition. This changes how the `exports` field in `package.json` files
      is interpreted to prefer browser-specific code.
      </p>
    - >
      <p>
      If no custom [conditions](#conditions) are configured, the Webpack-specific
      `module` condition is also included. The `module` condition is used by
      package authors to provide a tree-shakable ESM alternative to a CommonJS
      file without creating a [dual package hazard](https://nodejs.org/api/packages.html#dual-package-hazard).
      You can prevent the `module` condition from being included by explicitly
      configuring some custom conditions (even an empty list).
      </p>
    - >
      <p>
      When using the [build](#build) API, all <code>process.<wbr>env.<wbr>NODE_ENV</code>
      expressions are automatically [defined](#define) to `"production"` if all
      [minification](#minify) options are enabled and `"development"` otherwise.
      This only happens if `process`, `process.env`, and `process.env.NODE_ENV`
      are not already defined. This substitution is necessary to avoid React-based
      code crashing instantly (since `process` is a node API, not a web API).
      </p>
    - >
      <p>
      The character sequence `</script>` will be escaped in JavaScript code and
      the character sequence `</style>` will be escaped in CSS code. This is
      done in case you inline esbuild's output directly into an HTML file. This
      can be disabled with esbuild's [supported](#supported) feature by setting
      `inline-script` (for JavaScript) and/or `inline-style` (for CSS) to `false`.
      </p>

  - p: >
      When the platform is set to `node`:

  - ul:
    - >
      <p>
      When [bundling](#bundle) is enabled the default output [format](#format)
      is set to `cjs`, which stands for  CommonJS (the module format used by node).
      ES6-style exports using `export` statements will be converted into getters
      on the CommonJS `exports` object.
      </p>
    - >
      <p>
      All [built-in node modules](https://nodejs.org/docs/latest/api/) such
      as `fs` are automatically marked as [external](#external) so they don't
      cause errors when the bundler tries to bundle them.
      </p>
    - >
      <p>
      The [main fields](#main-fields) setting is set to <code>main,<wbr>module</code>. This
      means tree shaking will likely not happen for packages that provide both
      `module` and `main` since tree shaking works with ECMAScript modules but
      not with CommonJS modules.
      </p>
      <p>
      Unfortunately some packages incorrectly treat `module` as meaning "browser
      code" instead of "ECMAScript module code" so this default behavior is
      required for compatibility. You can manually configure the [main fields](#main-fields)
      setting to <code>module,<wbr>main</code> if you want to enable tree shaking and know it
      is safe to do so.
      </p>
    - >
      <p>
      The [conditions](#conditions) setting automatically includes the `node`
      condition. This changes how the `exports` field in `package.json` files
      is interpreted to prefer node-specific code.
      </p>
    - >
      <p>
      If no custom [conditions](#conditions) are configured, the Webpack-specific
      `module` condition is also included. The `module` condition is used by
      package authors to provide a tree-shakable ESM alternative to a CommonJS
      file without creating a [dual package hazard](https://nodejs.org/api/packages.html#dual-package-hazard).
      You can prevent the `module` condition from being included by explicitly
      configuring some custom conditions (even an empty list).
      </p>
    - >
      <p>
      When the [format](#format) is set to `cjs` but the entry point is ESM,
      esbuild will add special annotations for any named exports to enable
      importing those named exports using ESM syntax from the resulting
      CommonJS file. Node's documentation has more information about
      [node's detection of CommonJS named exports](https://nodejs.org/api/esm.html#commonjs-namespaces).
      </p>
    - >
      <p>
      The [`binary`](/content-types/#binary) loader will make use of node's
      built-in [`Buffer.from`](https://nodejs.org/api/buffer.html#static-method-bufferfromstring-encoding)
      API to decode the base64 data embedded in the bundle into a `Uint8Array`.
      This is faster than what esbuild can do otherwise since it's implemented
      by node in native code.
      </p>

  - p: >
      When the platform is set to `neutral`:

  - ul:
    - >
      <p>
      When [bundling](#bundle) is enabled the default output [format](#format)
      is set to `esm`, which uses the `export` syntax introduced with ECMAScript
      2015 (i.e. ES6). You can change the output format if this default is not
      appropriate.
      </p>
    - >
      <p>
      The [main fields](#main-fields) setting is empty by default. If you want
      to use npm-style packages, you will likely have to configure this to be
      something else such as `main` for the standard main field used by node.
      </p>
    - >
      <p>
      The [conditions](#conditions) setting does not automatically include any
      platform-specific values.
      </p>

  - p: >
      See also [bundling for the browser](/getting-started/#bundling-for-the-browser)
      and [bundling for node](/getting-started/#bundling-for-node).

  - h3: Rebuild

  - p: >
      You may want to use this API if your use case involves calling esbuild's
      [build](#build) API repeatedly with the same options. For example,
      this is useful if you are implementing your own file watcher service.
      Rebuilding is more efficient than building again because some of the data
      from the previous build is cached and can be reused if the original files
      haven't changed since the previous build. There are currently two forms
      of caching used by the rebuild API:

  - ul:
    - >
      <p>
      Files are stored in memory and are not re-read from the file system if
      the file metadata hasn't changed since the last build. This optimization
      only applies to file system paths. It does not apply to virtual modules
      created by [plugins](/plugins/).
      </p>

    - >
      <p>
      Parsed [ASTs](https://en.wikipedia.org/wiki/Abstract_syntax_tree) are
      stored in memory and re-parsing the AST is avoided if the file contents
      haven't changed since the last build. This optimization applies to
      virtual modules created by plugins in addition to file system modules,
      as long as the virtual module path remains the same.
      </p>

  - p: >
      Here's how to do a rebuild:

  - example:
      in:
        app.js: '1 + 2'

      cli: |
        # The CLI does not have an API for "rebuild"

      mjs: |
        import * as esbuild from 'esbuild'

        let ctx = await esbuild.context({
          entryPoints: ['app.js'],
          bundle: true,
          outfile: 'out.js',
        })

        // Call "rebuild" as many times as you want
        for (let i = 0; i < 5; i++) {
          let result = await ctx.rebuild()
        }

        // Call "dispose" when you're done to free up resources
        ctx.dispose()

      go: |
        package main

        import "github.com/evanw/esbuild/pkg/api"
        import "os"

        func main() {
          ctx, err := api.Context(api.BuildOptions{
            EntryPoints: []string{"app.js"},
            Bundle:      true,
            Outfile:     "out.js",
          })
          if err != nil {
            os.Exit(1)
          }

          // Call "Rebuild" as many times as you want
          for i := 0; i < 5; i++ {
            result := ctx.Rebuild()
            if len(result.Errors) > 0 {
              os.Exit(1)
            }
          }

          // Call "Dispose" when you're done to free up resources
          ctx.Dispose()
        }

  - h3: Serve

  - info: >
      If you want your app to automatically reload as you edit, you should
      read about [live reloading](#live-reload). It combines serve mode with
      [watch mode](#watch) to listen for changes to the file system.

  - p: >
      Serve mode starts a web server that serves your code to your browser on
      your device. Here's an example that bundles `src/app.ts` into `www/js/app.js`
      and then also serves the `www` directory over `http://localhost:8000/`:

  - example:
      noCheck: true

      cli: |
        esbuild src/app.ts --outdir=www/js --bundle --servedir=www

      mjs: |
        import * as esbuild from 'esbuild'

        let ctx = await esbuild.context({
          entryPoints: ['src/app.ts'],
          outdir: 'www/js',
          bundle: true,
        })

        let { host, port } = await ctx.serve({
          servedir: 'www',
        })

      go: |
        package main

        import "github.com/evanw/esbuild/pkg/api"
        import "os"

        func main() {
          ctx, err := api.Context(api.BuildOptions{
            EntryPoints: []string{"src/app.ts"},
            Outdir:     "www/js",
            Bundle:      true,
          })
          if err != nil {
            os.Exit(1)
          }

          server, err2 := ctx.Serve(api.ServeOptions{
            Servedir: "www",
          })
          if err2 != nil {
            os.Exit(1)
          }

          // Returning from main() exits immediately in Go.
          // Block forever so we keep serving and don't exit.
          <-make(chan struct{})
        }

  - p: >
      If you create the file `www/index.html` with the following contents, the
      code contained in `src/app.ts` will load when you navigate to `http://localhost:8000/`:

  - pre.html: |
      <script src="js/app.js"></script>

  - p: >
      One benefit of using esbuild's built-in web server instead of another web
      server is that whenever you reload, the files that esbuild serves are
      always up to date. That's not necessarily the case with other development
      setups. One common setup is to run a local file watcher that rebuilds
      output files whenever their input files change, and then separately to run
      a local file server to serve those output files. But that means reloading
      after an edit may reload the old output files if the rebuild hasn't finished
      yet. With esbuild's web server, each incoming request starts a rebuild if
      one is not already in progress, and then waits for the current rebuild to
      complete before serving the file. This means esbuild never serves stale
      build results.

  - p: >
      Note that this web server is intended to only be used in development. _Do
      not use this in production._

  - h4#serve-arguments: Arguments

  - p: >
      The arguments to the serve API are as follows:

  - example:
      noCheck: true

      cli: |
        # Enable serve mode
        --serve

        # Set the port
        --serve=9000

        # Set the host and port (IPv4)
        --serve=127.0.0.1:9000

        # Set the host and port (IPv6)
        --serve=[::1]:9000

        # Set the directory to serve
        --servedir=www

        # Enable HTTPS
        --keyfile=your.key --certfile=your.cert

      js: |
        interface ServeOptions {
          port?: number
          host?: string
          servedir?: string
          keyfile?: string
          certfile?: string
          onRequest?: (args: ServeOnRequestArgs) => void
        }

        interface ServeOnRequestArgs {
          remoteAddress: string
          method: string
          path: string
          status: number
          timeInMS: number
        }

      go: |
        type ServeOptions struct {
          Port      uint16
          Host      string
          Servedir  string
          Keyfile   string
          Certfile  string
          OnRequest func(ServeOnRequestArgs)
        }

        type ServeOnRequestArgs struct {
          RemoteAddress string
          Method        string
          Path          string
          Status        int
          TimeInMS      int
        }

  - ul:
    - >
      `host`
      <p>
      By default, esbuild makes the web server available on all IPv4 network
      interfaces. This corresponds to a host address of `0.0.0.0`. If you would
      like to configure a different host (for example, to only serve on the
      `127.0.0.1` loopback interface without exposing anything to the network),
      you can specify the host using this argument.
      </p>
      <p>
      If you need to use IPv6 instead of IPv4, you just need to specify an IPv6
      host address. The equivalent to the `127.0.0.1` loopback interface in IPv6
      is `::1` and the equivalent to the `0.0.0.0` universal interface in IPv6 is
      `::`.
      </p>

    - >
      `port`
      <p>
      The HTTP port can optionally be configured here. If omitted, it will
      default to an open port with a preference for ports in the range 8000 to
      8009.
      </p>

    - >
      `servedir`
      <p>
      This is a directory of extra content for esbuild's HTTP server to serve
      instead of a 404 when incoming requests don't match any of the generated
      output file paths. This lets you use esbuild as a general-purpose local
      web server.
      </p>
      <p>
      For example, you might want to create an `index.html` file and then set
      `servedir` to `"."` to serve the current directory (which includes the
      `index.html` file). If you don't set `servedir` then esbuild will only
      serve the build results, but not any other files.
      </p>

    - >
      `keyfile` and `certfile`
      <p>
      If you pass a private key and certificate to esbuild using `keyfile` and
      `certfile`, then esbuild's web server will use the `https://` protocol
      instead of the `http://` protocol. See [enabling HTTPS](#https) for more
      information.
      </p>

    - >
      `onRequest`
      <p>
      This is called once for each incoming request with some information about
      the request. This callback is used by the CLI to print out a log message
      for each request. The time field is the time to generate the data for the
      request, but it does not include the time to stream the request to the
      client.
      </p>
      <p>
      Note that this is called after the request has completed. It's not possible
      to use this callback to modify the request in any way. If you want to do
      this, you should [put a proxy in front of esbuild](#serve-proxy) instead.
      </p>

  - h4#serve-return-values: Return values

  - example:
      noCheck: true

      cli: |
        # The CLI will print the host and port like this:

         > Local: http://127.0.0.1:8000/

      js: |
        interface ServeResult {
          host: string
          port: number
        }

      go: |
        type ServeResult struct {
          Host string
          Port uint16
        }

  - ul:
    - >
      `host`
      <p>
      This is the host that ended up being used by the web server. It will be
      `0.0.0.0` (i.e. serving on all available network interfaces) unless a
      custom host was configured. If you are using the CLI and the host is
      `0.0.0.0`, all available network interfaces will be printed as hosts
      instead.
      </p>

    - >
      `port`
      <p>
      This is the port that ended up being used by the web server. You'll want to
      use this if you don't specify a port since esbuild will end up picking
      an arbitrary open port, and you need to know which port it picked to be
      able to connect to it.
      </p>

  - h4#https: Enabling HTTPS

  - p: >
      By default, esbuild's web server uses the `http://` protocol. However,
      certain modern web features are unavailable to HTTP websites. If you want
      to use these features, then you'll need to tell esbuild to use the
      `https://` protocol instead.

  - p: >
      To enable HTTPS with esbuild:

  - ol:
    - >
      <p>
      Generate a self-signed certificate. There are many ways to do this. Here's
      one way, assuming you have the `openssl` command installed:
      </p>
      <pre>
      openssl req -x509 -newkey rsa:4096 -keyout your.key -out your.cert -days 9999 -nodes -subj /CN=127.0.0.1
      </pre>

    - >
      <p>
      Pass `your.key` and `your.cert` to esbuild using the `keyfile` and `certfile`
      [serve arguments](#serve-arguments).
      </p>

    - >
      <p>
      Click past the scary warning in your browser when you load your page
      (self-signed certificates aren't secure, but that doesn't matter since
      we're just doing local development).
      </p>

  - p: >
      If you have more complex needs than this, you can still [put a proxy in front of esbuild](#serve-proxy)
      and use that for HTTPS instead. Note that if you see the message
      <code>Client <wbr>sent <wbr>an <wbr>HTTP <wbr>request <wbr>to <wbr>an <wbr>HTTPS <wbr>server</code>
      when you load your page, then you are using the incorrect protocol.
      Replace `http://` with `https://` in your browser's URL bar.

  - p: >
      Keep in mind that esbuild's HTTPS support has nothing to do with security.
      The only reason to enable HTTPS in esbuild is because browsers have made
      it impossible to do local development with certain modern web features
      without jumping through these extra hoops. *Please do not use esbuild's
      development server for anything that needs to be secure.* It's only
      intended for local development and no considerations have been made for
      production environments whatsoever.

  - h4#serve-proxy: Customizing server behavior

  - p: >
      It's not possible to hook into esbuild's local server to customize the
      behavior of the server itself. Instead, behavior should be customized
      by putting a proxy in front of esbuild.

  - p: >
      Here's a simple example of a proxy server to get you started, using node's
      built-in [`http`](https://nodejs.org/api/http.html) module. It adds a
      custom 404 page instead of esbuild's default 404 page:

  - pre.js: |
      import * as esbuild from 'esbuild'
      import http from 'node:http'

      // Start esbuild's server on a random local port
      let ctx = await esbuild.context({
        // ... your build options go here ...
      })

      // The return value tells us where esbuild's local server is
      let { host, port } = await ctx.serve({ servedir: '.' })

      // Then start a proxy server on port 3000
      http.createServer((req, res) => {
        const options = {
          hostname: host,
          port: port,
          path: req.url,
          method: req.method,
          headers: req.headers,
        }

        // Forward each incoming request to esbuild
        const proxyReq = http.request(options, proxyRes => {
          // If esbuild returns "not found", send a custom 404 page
          if (proxyRes.statusCode === 404) {
            res.writeHead(404, { 'Content-Type': 'text/html' })
            res.end('<h1>A custom 404 page</h1>')
            return
          }

          // Otherwise, forward the response from esbuild to the client
          res.writeHead(proxyRes.statusCode, proxyRes.headers)
          proxyRes.pipe(res, { end: true })
        })

        // Forward the body of the request to esbuild
        req.pipe(proxyReq, { end: true })
      }).listen(3000)

  - p: >
      This code starts esbuild's server on random local port and then starts a
      proxy server on port 3000. During development you would load [http://localhost:3000](http://localhost:3000)
      in your browser, which talks to the proxy. This example demonstrates
      modifying a response after esbuild has handled the request, but you can
      also modify or replace the request before esbuild has handled it.

  - p: >
      You can do many things with a proxy like this including:

  - ul:
    - Injecting your own 404 page (the example above)
    - Customizing the mapping of routes to files on the file system
    - Redirecting some routes to an API server instead of to esbuild

  - p: >
      You can also use a real proxy such as [nginx](https://nginx.org/en/docs/beginners_guide.html#proxy)
      if you have more advanced needs.

  - h3: Tsconfig

  - p: >
      Normally the [build](#build) API automatically discovers `tsconfig.json`
      files and reads their contents during a build. However, you can also
      configure a custom `tsconfig.json` file to use instead. This can be
      useful if you need to do multiple builds of the same code with different
      settings:

  - example:
      in:
        app.ts: '1 + 2'
        custom-tsconfig.json: '{}'

      cli: |
          esbuild app.ts --bundle --tsconfig=custom-tsconfig.json

      mjs: |
        import * as esbuild from 'esbuild'

        await esbuild.build({
          entryPoints: ['app.ts'],
          bundle: true,
          tsconfig: 'custom-tsconfig.json',
          outfile: 'out.js',
        })

      go: |
        package main

        import "github.com/evanw/esbuild/pkg/api"
        import "os"

        func main() {
          result := api.Build(api.BuildOptions{
            EntryPoints: []string{"app.ts"},
            Bundle:      true,
            Tsconfig:    "custom-tsconfig.json",
            Write:       true,
          })

          if len(result.Errors) > 0 {
            os.Exit(1)
          }
        }

  - h3: Tsconfig raw

  - p: >
      This option can be used to pass your `tsconfig.json` file to the
      [transform](#transform) API, which doesn't access the file system.
      Using it looks like this:

  - example:
      cli: |
          echo 'class Foo { foo }' | esbuild --loader=ts --tsconfig-raw='{"compilerOptions":{"useDefineForClassFields":true}}'

      mjs: |
        import * as esbuild from 'esbuild'

        let ts = 'class Foo { foo }'
        let result = await esbuild.transform(ts, {
          loader: 'ts',
          tsconfigRaw: `{
            "compilerOptions": {
              "useDefineForClassFields": true,
            },
          }`,
        })
        console.log(result.code)

      go: |
        package main

        import "fmt"
        import "github.com/evanw/esbuild/pkg/api"

        func main() {
          ts := "class Foo { foo }"

          result := api.Transform(ts, api.TransformOptions{
            Loader: api.LoaderTS,
            TsconfigRaw: `{
              "compilerOptions": {
                "useDefineForClassFields": true,
              },
            }`,
          })

          if len(result.Errors) == 0 {
            fmt.Printf("%s", result.Code)
          }
        }

<<<<<<< HEAD
  - p: >
      如果你在使用 CLI 工具，请记住，不同的 shell 对于如何转义双引号字符有不同的规则
      （当替换的值为一个字符串时会非常必要）。使用 `\"` 反斜杠转义，因为它可以在 bash
      以及 Windows 命令提示符中生效。其他在 bash 中有效的转义双引号的方法，比如用单引号括起来，
      在Windows上不起作用，因为 Windows 命令提示符不会删除单引号。这和你在 `package.json` 的
      npm script 中使用 CLI 工具是相关的，人们期望在所有平台上工作：
=======
  - h3: Watch
>>>>>>> 64a7cbf09ed21d61e6fe85529b31e5676fa14bfe

  - p: >
      Enabling watch mode tells esbuild to listen for changes on the file system
      and to automatically rebuild whenever a file changes that could invalidate
      the build. Using it looks like this:

  - example:
      noCheck: true

      cli:
        - $: |
            esbuild app.js --outfile=out.js --bundle --watch
        - expect: |
            [watch] build finished, watching for changes...

      mjs: |
        import * as esbuild from 'esbuild'

        let ctx = await esbuild.context({
          entryPoints: ['app.js'],
          outfile: 'out.js',
          bundle: true,
        })

        await ctx.watch()
        console.log('watching...')

      go: |
        package main

        import "fmt"
        import "github.com/evanw/esbuild/pkg/api"
        import "os"

        func main() {
          ctx, err := api.Context(api.BuildOptions{
            EntryPoints: []string{"app.js"},
            Outfile:     "out.js",
            Bundle:      true,
            Write:       true,
          })
          if err != nil {
            os.Exit(1)
          }

          err2 := ctx.Watch(api.WatchOptions{})
          if err2 != nil {
            os.Exit(1)
          }
          fmt.Printf("watching...\n")

          // Returning from main() exits immediately in Go.
          // Block forever so we keep watching and don't exit.
          <-make(chan struct{})
        }

  - p: >
<<<<<<< HEAD
      如果你仍然在不同的 shell 中遇到跨平台引号转义问题，你讲可能会选择使用 [JavaScript API](/api/)。
      There you can use regular JavaScript syntax to eliminate
      你可以使用常规的 JavaScript 语法来消除跨平台差异。
=======
      If you want to stop watch mode at some point in the future, you can call
      `dispose` on the context object to terminate the file watcher:

  - example:
      noCheck: true

      cli: |
        # Use Ctrl+C to stop the CLI in watch mode

      mjs: |
        import * as esbuild from 'esbuild'

        let ctx = await esbuild.context({
          entryPoints: ['app.js'],
          outfile: 'out.js',
          bundle: true,
        })

        await ctx.watch()
        console.log('watching...')

        await new Promise(r => setTimeout(r, 10 * 1000))
        await ctx.dispose()
        console.log('stopped watching')

      go: |
        package main

        import "fmt"
        import "github.com/evanw/esbuild/pkg/api"
        import "os"
        import "time"

        func main() {
          ctx, err := api.Context(api.BuildOptions{
            EntryPoints: []string{"app.js"},
            Outfile:     "out.js",
            Bundle:      true,
            Write:       true,
          })
          if err != nil {
            os.Exit(1)
          }

          err2 := ctx.Watch(api.WatchOptions{})
          if err2 != nil {
            os.Exit(1)
          }
          fmt.Printf("watching...\n")

          time.Sleep(10 * time.Second)
          ctx.Dispose()
          fmt.Printf("stopped watching\n")
        }

  - p: >
      Watch mode in esbuild is implemented using polling instead of OS-specific
      file system APIs for portability. The polling system is designed to use
      relatively little CPU vs. a more traditional polling system that scans
      the whole directory tree at once. The file system is still scanned
      regularly but each scan only checks a random subset of your files, which
      means a change to a file will be picked up soon after the change is made
      but not necessarily instantly.

  - p: >
      With the current heuristics, large projects should be completely scanned
      around every 2 seconds so in the worst case it could take up to 2 seconds
      for a change to be noticed. However, after a change has been noticed the
      change's path goes on a short list of recently changed paths which are
      checked on every scan, so further changes to recently changed files
      should be noticed almost instantly.

  - p: >
      Note that it is still possible to implement watch mode yourself using
      esbuild's [rebuild](#rebuild) API and a file watcher library of your
      choice if you don't want to use a polling-based approach.

  - p: >
      If you are using the CLI, keep in mind that watch mode will be terminated
      when esbuild's stdin is closed. This prevents esbuild from accidentally
      outliving the parent process and unexpectedly continuing to consume
      resources on the system. If you have a use case that requires esbuild to
      continue to watch forever even when the parent process has finished, you
      may use <code>--watch=<wbr>forever</code> instead of `--watch`.

  - h2: Input
>>>>>>> 64a7cbf09ed21d61e6fe85529b31e5676fa14bfe

  - h3: Entry points

  - p: >
      This is an array of files that each serve as an input to the bundling
      algorithm. They are called "entry points" because each one is meant to
      be the initial script that is evaluated which then loads all other aspects
      of the code that it represents. Instead of loading many libraries in your
      page with `<script>` tags, you would instead use `import` statements to
      import them into your entry point (or into another file that is then
      imported into your entry point).

  - p: >
      Simple apps only need one entry point but additional entry points can be
      useful if there are multiple logically-independent groups of code such as
      a main thread and a worker thread, or an app with separate relatively
      unrelated areas such as a landing page, an editor page, and a settings page.
      Separate entry points helps introduce separation of concerns and helps
      reduce the amount of unnecessary code that the browser needs to download.
      If applicable, enabling [code splitting](#splitting) can further reduce
      download sizes when browsing to a second page whose entry point shares
      some already-downloaded code with a first page that has already been
      visited.

  - p: >
      The simple way to specify entry points is to just pass an array of file
      paths:

  - example:
      in:
        home.ts: "1 + 2"
        settings.ts: "1 + 2"

      cli: |
        esbuild home.ts settings.ts --bundle --outdir=out

      mjs: |
        import * as esbuild from 'esbuild'

        await esbuild.build({
          entryPoints: ['home.ts', 'settings.ts'],
          bundle: true,
          write: true,
          outdir: 'out',
        })

      go: |
        package main

        import "github.com/evanw/esbuild/pkg/api"
        import "os"

        func main() {
          result := api.Build(api.BuildOptions{
            EntryPoints: []string{"home.ts", "settings.ts"},
            Bundle:      true,
            Write:       true,
            Outdir:      "out",
          })

          if len(result.Errors) > 0 {
            os.Exit(1)
          }
        }

  - p: >
      This will generate two output files, `out/home.js` and `out/settings.js`
      corresponding to the two entry points `home.ts` and `settings.ts`.

  - p: >
      For further control over how the paths of the output files are derived
      from the corresponding input entry points, you should look into these
      options:

  - ul:
      - "[Entry names](#entry-names)"
      - "[Out extension](#out-extension)"
      - "[Outbase](#outbase)"
      - "[Outdir](#outdir)"
      - "[Outfile](#outfile)"

  - p: >
      In addition, you can also specify a fully custom output path for each
      individual entry point using an alternative entry point syntax:

  - example:
      in:
<<<<<<< HEAD
        home.js: "1 + 2"
        settings.js: "1 + 2"
=======
        home.ts: '1 + 2'
        settings.ts: '1 + 2'
>>>>>>> 64a7cbf09ed21d61e6fe85529b31e5676fa14bfe

      cli: |
        esbuild out1=home.ts out2=settings.ts --bundle --outdir=out

      mjs: |
        import * as esbuild from 'esbuild'

        await esbuild.build({
          entryPoints: {
            out1: 'home.ts',
            out2: 'settings.ts',
          },
          bundle: true,
          write: true,
          outdir: 'out',
        })

      go: |
        package main

        import "github.com/evanw/esbuild/pkg/api"
        import "os"

        func main() {
          result := api.Build(api.BuildOptions{
            EntryPointsAdvanced: []api.EntryPoint{{
              OutputPath: "out1",
              InputPath:  "home.ts",
            }, {
              OutputPath: "out2",
              InputPath:  "settings.ts",
            }},
            Bundle: true,
            Write:  true,
            Outdir: "out",
          })

          if len(result.Errors) > 0 {
            os.Exit(1)
          }
        }

  - p: >
      This will generate two output files, `out/out1.js` and `out/out2.js`
      corresponding to the two entry points `home.ts` and `settings.ts`.

  - h3: Loader

  - p: >
<<<<<<< HEAD
      你可以标记一个文件或者包为外部（external），从而将其从你的打包结果中移除。
      导入将被保留（对于 `iife` 以及 `cjs` 格式使用 `require`，对于 `esm` 格式使用 `import`），而不是被打包，
      并将在运行时进行计算。

  - p: >
      这里有几个用法。首先，它可以用于去除你的 bundle 中你知道将永远不会被执行的代码路径中的无用代码。
      例如，一个 package 可以会包含值运行在 node 端的代码，但是你只会将其用在浏览器中。
      它还可以用于在运行时从不能打包的包导入 node 中的代码。例如，`fsevents` 包含 esbuild 不支持的本地拓展，
      像这样将某些内容标记为外部（external）：
=======
      This option changes how a given input file is interpreted. For example,
      the [`js`](/content-types/#javascript) loader interprets the file as
      JavaScript and the [`css`](/content-types/#css) loader interprets the
      file as CSS. See the [content types](/content-types/) page for a
      complete list of all built-in loaders.

  - p: >
      Configuring a loader for a given file type lets you load that file type
      with an `import` statement or a `require` call. For example, configuring
      the `.png` file extension to use the [data URL](/content-types/#data-url)
      loader means importing a `.png` file gives you a data URL containing the
      contents of that image:

  - pre.js: |
      import url from './example.png'
      let image = new Image
      image.src = url
      document.body.appendChild(image)

      import svg from './example.svg'
      let doc = new DOMParser().parseFromString(svg, 'application/xml')
      let node = document.importNode(doc.documentElement, true)
      document.body.appendChild(node)

  - p: >
      The above code can be bundled using the [build](#build) API call like
      this:
>>>>>>> 64a7cbf09ed21d61e6fe85529b31e5676fa14bfe

  - example:
      in:
        app.js: |
          import url from './example.png'
          let image = new Image
          image.src = url
          document.body.appendChild(image)

          import svg from './example.svg'
          let doc = new DOMParser().parseFromString(svg, 'application/xml')
          let node = document.importNode(doc.documentElement, true)
          document.body.appendChild(node)

        example.png: |
          this is some data

        example.svg: |
          this is some data

      cli: |
        esbuild app.js --bundle --loader:.png=dataurl --loader:.svg=text

      mjs: |
        import * as esbuild from 'esbuild'

        await esbuild.build({
          entryPoints: ['app.js'],
          bundle: true,
          loader: {
            '.png': 'dataurl',
            '.svg': 'text',
          },
          outfile: 'out.js',
        })

      go: |
        package main

        import "github.com/evanw/esbuild/pkg/api"
        import "os"

        func main() {
          result := api.Build(api.BuildOptions{
            EntryPoints: []string{"app.js"},
            Bundle:      true,
            Loader: map[string]api.Loader{
              ".png": api.LoaderDataURL,
              ".svg": api.LoaderText,
            },
            Write: true,
          })

          if len(result.Errors) > 0 {
            os.Exit(1)
          }
        }

  - p: >
<<<<<<< HEAD
<<<<<<< HEAD
      你也可以在外部（external）路径中使用 `*` 通配符标记所有符合该模式的为外部（external）。
      例如，你可以使用 `*.png` 移除所有的 `.png` 文件或者使用 `/images/*` 移除所有路径以
      `/images/` 开头的路径。当在 外部（external）路径中使用 `*` 通配符时，
      该模式将应用于源代码中的原始路径，而不是解析为实际文件系统路径后的路径。
      这允许你匹配不是真实文件系统路径的路径。
=======
      You can also use the `*` wildcard character in an external path to mark
      all files matching that pattern as external. For example, you can use
      `*.png` to remove all `.png` files or `/images/*` to remove all paths
      starting with `/images/`.

  - p: >
      External paths are applied both before and after path resolution, which
      lets you match against both the import path in the source code and the
      absolute file system path. The path is considered to be external if the
      external path matches in either case. The specific behavior is as follows:
=======
      This option is specified differently if you are using the build API with
      input from [stdin](#stdin), since stdin does not have a file extension.
      Configuring a loader for stdin with the build API looks like this:

  - example:
      in:
        pkg.js: |
          module.exports = 123

      cli: |
        echo 'import pkg = require("./pkg")' | esbuild --loader=ts --bundle

      mjs: |
        import * as esbuild from 'esbuild'

        await esbuild.build({
          stdin: {
            contents: 'import pkg = require("./pkg")',
            loader: 'ts',
            resolveDir: '.',
          },
          bundle: true,
          outfile: 'out.js',
        })

      go: |
        package main

        import "github.com/evanw/esbuild/pkg/api"
        import "os"

        func main() {
          result := api.Build(api.BuildOptions{
            Stdin: &api.StdinOptions{
              Contents:   "import pkg = require('./pkg')",
              Loader:     api.LoaderTS,
              ResolveDir: ".",
            },
            Bundle: true,
          })
          if len(result.Errors) > 0 {
            os.Exit(1)
          }
        }

  - p: >
      The [transform](#transform) API call just takes a single loader since
      it doesn't involve interacting with the file system, and therefore doesn't
      deal with file extensions. Configuring a loader (in this case the
      [`ts`](/content-types/#typescript) loader) for the transform API looks
      like this:

  - example:
      cli:
        - $: |
            echo 'let x: number = 1' | esbuild --loader=ts
        - expect: |
            let x = 1;

      mjs: |
        import * as esbuild from 'esbuild'

        let ts = 'let x: number = 1'
        let result = await esbuild.transform(ts, {
          loader: 'ts',
        })
        console.log(result.code)

      go: |
        package main

        import "fmt"
        import "github.com/evanw/esbuild/pkg/api"

        func main() {
          ts := "let x: number = 1"
          result := api.Transform(ts, api.TransformOptions{
            Loader: api.LoaderTS,
          })
          if len(result.Errors) == 0 {
            fmt.Printf("%s", result.Code)
          }
        }

  - h3: Stdin

  - p: >
      Normally the build API call takes one or more file names as input.
      However, this option can be used to run a build without a module existing
      on the file system at all. It's called "stdin" because it corresponds to
      piping a file to stdin on the command line.

  - p: >
      In addition to specifying the contents of the stdin file, you can
      optionally also specify the resolve directory (used to determine where
      relative imports are located), the [sourcefile](#sourcefile) (the file
      name to use in error messages and source maps), and the [loader](#loader)
      (which determines how the file contents are interpreted). The CLI doesn't
      have a way to specify the resolve directory. Instead, it's automatically
      set to the current working directory.

  - p: >
      Here's how to use this feature:

  - example:
      in:
        another-file.js: 'export let foo = 123'

      cli: |
        echo 'export * from "./another-file"' | esbuild --bundle --sourcefile=imaginary-file.js --loader=ts --format=cjs

      mjs: |
        import * as esbuild from 'esbuild'

        let result = await esbuild.build({
          stdin: {
            contents: `export * from "./another-file"`,

            // These are all optional:
            resolveDir: './src',
            sourcefile: 'imaginary-file.js',
            loader: 'ts',
          },
          format: 'cjs',
          write: false,
        })

      go: |
        package main

        import "github.com/evanw/esbuild/pkg/api"
        import "os"

        func main() {
          result := api.Build(api.BuildOptions{
            Stdin: &api.StdinOptions{
              Contents: "export * from './another-file'",

              // These are all optional:
              ResolveDir: "./src",
              Sourcefile: "imaginary-file.js",
              Loader:     api.LoaderTS,
            },
            Format: api.FormatCommonJS,
          })

          if len(result.Errors) > 0 {
            os.Exit(1)
          }
        }

  - h2: Output contents

  - h3: Banner

  - p: >
      Use this to insert an arbitrary string at the beginning of generated
      JavaScript and CSS files. This is commonly used to insert comments:

  - example:
      in:
        app.js: '1 + 2'

      cli: |
        esbuild app.js --banner:js=//comment --banner:css=/*comment*/

      mjs: |
        import * as esbuild from 'esbuild'

        await esbuild.build({
          entryPoints: ['app.js'],
          banner: {
            js: '//comment',
            css: '/*comment*/',
          },
          outfile: 'out.js',
        })

      go: |
        package main

        import "github.com/evanw/esbuild/pkg/api"
        import "os"

        func main() {
          result := api.Build(api.BuildOptions{
            EntryPoints: []string{"app.js"},
            Banner: map[string]string{
              "js":  "//comment",
              "css": "/*comment*/",
            },
          })

          if len(result.Errors) > 0 {
            os.Exit(1)
          }
        }

  - p: >
      This is similar to [footer](#footer) which inserts at the end instead
      of the beginning.

  - p: >
      Note that if you are inserting non-comment code into a CSS file, be aware
      that CSS ignores all `@import` rules that come after a non-`@import` rule
      (other than a `@charset` rule), so using a banner to inject CSS rules may
      accidentally disable imports of external stylesheets.

  - h3: Charset

  - p: >
      By default esbuild's output is ASCII-only. Any non-ASCII characters are
      escaped using backslash escape sequences. One reason is because non-ASCII
      characters are misinterpreted by the browser by default, which causes
      confusion. You have to explicitly add <code>&lt;meta <wbr>charset=<wbr>"utf-8"&gt;</code> to your
      HTML or serve it with the correct <code>Content-<wbr>Type</code> header for the browser
      to not mangle your code. Another reason is that non-ASCII characters can
      significantly [slow down the browser's parser](https://v8.dev/blog/scanner).
      However, using escape sequences makes the generated output slightly bigger,
      and also makes it harder to read.

  - p: >
      If you would like for esbuild to print the original characters without
      using escape sequences and you have ensured that the browser will
      interpret your code as UTF-8, you can disable character escaping by
      setting the charset:

  - example:
      cli:
        - $: |
            echo 'let π = Math.PI' | esbuild
        - expect: |
            let \u03C0 = Math.PI;
        - $: |
            echo 'let π = Math.PI' | esbuild --charset=utf8
        - expect: |
            let π = Math.PI;

      mjs:
        - $: |
            import * as esbuild from 'esbuild'
        - $: |
            let js = 'let π = Math.PI'
        - $: |
            (await esbuild.transform(js)).code
        - expect: |
            'let \\u03C0 = Math.PI;\n'
        - $: |
            (await esbuild.transform(js, {
              charset: 'utf8',
            })).code
        - expect: |
            'let π = Math.PI;\n'

      go: |
        package main

        import "fmt"
        import "github.com/evanw/esbuild/pkg/api"

        func main() {
          js := "let π = Math.PI"

          result1 := api.Transform(js, api.TransformOptions{})

          if len(result1.Errors) == 0 {
            fmt.Printf("%s", result1.Code)
          }

          result2 := api.Transform(js, api.TransformOptions{
            Charset: api.CharsetUTF8,
          })

          if len(result2.Errors) == 0 {
            fmt.Printf("%s", result2.Code)
          }
        }

  - p: >
      Some caveats:
>>>>>>> 64a7cbf09ed21d61e6fe85529b31e5676fa14bfe

  - ul:
    - >
      <p>
<<<<<<< HEAD
      Before path resolution begins, import paths are checked against all
      external paths. In addition, if the external path looks like a package
      path (i.e. doesn't start with `/` or `./` or `../`), import paths are
      checked to see if they have that package path as a path prefix.
      </p>
      <p>
      This means that <code>--external:<wbr>@foo/<wbr>bar</code> implicitly
      also means <code>--external:<wbr>@foo/<wbr>bar/\*</code> which matches
      the import path <code>@foo/<wbr>bar/<wbr>baz</code>. So it marks all
      paths inside the `@foo/bar` package as external too.
      </p>

    - >
      <p>
      After path resolution ends, the resolved absolute paths are checked
      against all external paths that don't look like a package path (i.e.
      those that start with `/` or `./` or `../`). But before checking, the
      external path is joined with the current working directory and then
      normalized, becoming an absolute path (even if it contains a `*`
      wildcard character).
      </p>
      <p>
      This means that you can mark everything in the directory `dir` as
      external using <code>--external:<wbr>./dir/\*</code>. Note that the
      leading `./` is important. Using <code>--external:<wbr>dir/\*</code>
      instead is treated as a package path and is not checked for after
      path resolution ends.
      </p>
>>>>>>> 2e131b091e6a1dd99b9a331f6f3c75534bf796be
=======
      This does not yet escape non-ASCII characters embedded in regular
      expressions. This is because esbuild does not currently parse the contents
      of regular expressions at all. The flag was added despite this limitation
      because it's still useful for code that doesn't contain cases like this.
      </p>
    - >
      <p>
      This flag does not apply to comments. I believe preserving non-ASCII data
      in comments should be fine because even if the encoding is wrong, the run
      time environment should completely ignore the contents of all comments.
      For example, the [V8 blog post](https://v8.dev/blog/scanner) mentions an
      optimization that avoids decoding comment contents completely. And all
      comments other than license-related comments are stripped out by esbuild
      anyway.
      </p>
    - >
      <p>
      This option simultaneously applies to all output file types (JavaScript,
      CSS, and JSON). So if you configure your web server to send the correct
      <code>Content-<wbr>Type</code> header and want to use the UTF-8 charset,
      make sure your web server is configured to treat both `.js` and `.css`
      files as UTF-8.
      </p>

  - h3: Footer

  - p: >
      Use this to insert an arbitrary string at the end of generated JavaScript
      and CSS files. This is commonly used to insert comments:

  - example:
      in:
        app.js: '1 + 2'

      cli: |
        esbuild app.js --footer:js=//comment --footer:css=/*comment*/

      mjs: |
        import * as esbuild from 'esbuild'

        await esbuild.build({
          entryPoints: ['app.js'],
          footer: {
            js: '//comment',
            css: '/*comment*/',
          },
          outfile: 'out.js',
        })

      go: |
        package main

        import "github.com/evanw/esbuild/pkg/api"
        import "os"

        func main() {
          result := api.Build(api.BuildOptions{
            EntryPoints: []string{"app.js"},
            Footer: map[string]string{
              "js":  "//comment",
              "css": "/*comment*/",
            },
          })

          if len(result.Errors) > 0 {
            os.Exit(1)
          }
        }

  - p: >
      This is similar to [banner](#banner) which inserts at the beginning
      instead of the end.
>>>>>>> 64a7cbf09ed21d61e6fe85529b31e5676fa14bfe

  - h3: Format

  - p: >
      为生成的 JavaScript 文件设置输出格式。有三个可能的值：`iife`、`cjs` 与 `esm`。

  - h4#format-iife: IIFE

  - p: >
      `iife` 格式代表“立即调用函数表达式（immediately-invoked function expression）”并且在浏览器中运行。
      将你的代码包裹在一个函数表达式中，以确保代码中的所有变量不会与全局作用域中的变量冲突。
      如果你的入口起点有你想要暴露在浏览器全局环境中的导出，你可以使用 [global name](#global-name)
      设置 global `iife` 为默认格式，除非你设置 [platform](#platform) 为 `node`。
      像这样使用它：

  - example:
      cli:
        - $: |
            echo 'alert("test")' | esbuild --format=iife
        - expect: |
            (() => {
              alert("test");
            })();

      mjs: |
        import * as esbuild from 'esbuild'

        let js = 'alert("test")'
        let result = await esbuild.transform(js, {
          format: 'iife',
        })
        console.log(result.code)

      go: |
        package main

        import "fmt"
        import "github.com/evanw/esbuild/pkg/api"

        func main() {
          js := "alert(\"test\")"

          result := api.Transform(js, api.TransformOptions{
            Format: api.FormatIIFE,
          })

          if len(result.Errors) == 0 {
            fmt.Printf("%s", result.Code)
          }
        }

  - h4#format-commonjs: CommonJS

  - p: >
      `cjs` 格式打包代表"CommonJS" 并且在 node 环境中运行。它假设环境包括 `exports`、
      `require` 与 `module`。在 ECMAScript 模块语法中带有导出的入口点将被转换为一个模块，
      每个导出名称的 “exports” 上都有一个 getter。当你设置 [platform](#platform) 为 `node` 时，
      `cjs` 为默认格式。像这样使用它：

  - example:
      cli:
        - $: |
            echo 'export default "test"' | esbuild --format=cjs
        - expect: |
            ...
            var stdin_exports = {};
            __export(stdin_exports, {
              default: () => stdin_default
            });
            module.exports = __toCommonJS(stdin_exports);
            var stdin_default = "test";

      mjs: |
        import * as esbuild from 'esbuild'

        let js = 'export default "test"'
        let result = await esbuild.transform(js, {
          format: 'cjs',
        })
        console.log(result.code)

      go: |
        package main

        import "fmt"
        import "github.com/evanw/esbuild/pkg/api"

        func main() {
          js := "export default 'test'"

          result := api.Transform(js, api.TransformOptions{
            Format: api.FormatCommonJS,
          })

          if len(result.Errors) == 0 {
            fmt.Printf("%s", result.Code)
          }
        }

  - h4#format-esm: ESM

  - p: >
      `esm` 格式代表 "ECMAScript module"。它假设环境支持 `import` 与 `export` 语法。
      在 CommonJS 模块语法中带有导出的入口点将被转换为 `module.exports` 值的单个 `default` 导出。
      像这样使用它：

  - example:
      cli:
        - $: |
            echo 'module.exports = "test"' | esbuild --format=esm
        - expect: |
            ...
            var require_stdin = __commonJS({
              "<stdin>"(exports, module) {
                module.exports = "test";
              }
            });
            export default require_stdin();

      mjs: |
        import * as esbuild from 'esbuild'

        let js = 'module.exports = "test"'
        let result = await esbuild.transform(js, {
          format: 'esm',
        })
        console.log(result.code)

      go: |
        package main

        import "fmt"
        import "github.com/evanw/esbuild/pkg/api"

        func main() {
          js := "module.exports = 'test'"

          result := api.Transform(js, api.TransformOptions{
            Format: api.FormatESModule,
          })

          if len(result.Errors) == 0 {
            fmt.Printf("%s", result.Code)
          }
        }

  - p: >
      `esm` 格式可以在浏览器或者 node 中使用。但是你必须显式地以模块加载它。
      如果你从其他模块 `import`，那么这是自动进行的。否则：

  - ul:
      - >
        在浏览器中，你可以使用 <code>&lt;script <wbr>src="<wbr>file.js" <wbr>type="<wbr>module"&gt;<wbr>&lt;/script&gt;</code> 加载模块。
        <br>&nbsp;

      - >
        在 node 环境中，你可以使用 <code>node <wbr>--experimental-<wbr>modules <wbr>file.mjs</code> 加载模块。
        请注意 node 需要 `.mjs` 拓展名，除非你在 `package.json` 文件中配置了 <code>"type": <wbr>"module"</code> 。
        你可以使用 esbuild 中的 [out extension](#out-extension) 设置来自定义生成文件的拓展名。
        你可以点击 [这里](https://nodejs.org/api/esm.html) 获取更多关于使用 ECMAScript modules 的内容。

  - h3: Global name

  - p: >
      This option only matters when the [format](#format) setting is `iife`
      (which stands for immediately-invoked function expression). It sets the
      name of the global variable which is used to store the exports from the
      entry point:

  - example:
      cli: |
        echo 'module.exports = "test"' | esbuild --format=iife --global-name=xyz

      mjs: |
        import * as esbuild from 'esbuild'

        let js = 'module.exports = "test"'
        let result = await esbuild.transform(js, {
          format: 'iife',
          globalName: 'xyz',
        })
        console.log(result.code)

      go: |
        package main

        import "fmt"
        import "github.com/evanw/esbuild/pkg/api"

        func main() {
          js := "module.exports = 'test'"

          result := api.Transform(js, api.TransformOptions{
            Format:     api.FormatIIFE,
            GlobalName: "xyz",
          })

          if len(result.Errors) == 0 {
            fmt.Printf("%s", result.Code)
          }
        }

  - p: >
      Specifying the global name with the `iife` format will generate code that
      looks something like this:

  - pre.js: |
      var xyz = (() => {
        ...
        var require_stdin = __commonJS((exports, module) => {
          module.exports = "test";
        });
        return require_stdin();
      })();

  - p: >
      The global name can also be a compound property expression, in which case
      esbuild will generate a global variable with that property. Existing
      global variables that conflict will not be overwritten. This can be used
      to implement "namespacing" where multiple independent scripts add their
      exports onto the same global object. For example:

  - example:
      cli: |
        echo 'module.exports = "test"' | esbuild --format=iife --global-name='example.versions["1.0"]'

      mjs: |
        import * as esbuild from 'esbuild'

        let js = 'module.exports = "test"'
        let result = await esbuild.transform(js, {
          format: 'iife',
          globalName: 'example.versions["1.0"]',
        })
        console.log(result.code)

      go: |
        package main

        import "fmt"
        import "github.com/evanw/esbuild/pkg/api"

        func main() {
          js := "module.exports = 'test'"

          result := api.Transform(js, api.TransformOptions{
            Format:     api.FormatIIFE,
            GlobalName: `example.versions["1.0"]`,
          })

          if len(result.Errors) == 0 {
            fmt.Printf("%s", result.Code)
          }
        }

  - p: >
      The compound global name used above generates code that looks like this:

  - pre.js: |
      var example = example || {};
      example.versions = example.versions || {};
      example.versions["1.0"] = (() => {
        ...
        var require_stdin = __commonJS((exports, module) => {
          module.exports = "test";
        });
        return require_stdin();
      })();

  - h3: Legal comments

  - p: >
      A "legal comment" is considered to be any statement-level comment in JS
      or rule-level  comment in CSS that contains `@license` or `@preserve` or
      that starts with `//!` or `/*!`. These comments are preserved in output
      files by default since that follows the intent of the original authors
      of the code. However, this behavior can be configured by using one of
      the following options:

  - ul:
    - >
      <p>`none`<br>Do not preserve any legal comments.</p>

    - >
      <p>`inline`<br>Preserve all legal comments.</p>

    - >
      <p>`eof`<br>Move all legal comments to the end of the file.</p>

    - >
      <p>`linked`<br>Move all legal comments to a `.LEGAL.txt` file and link to them with a comment.</p>

    - >
      <p>`external`<br>Move all legal comments to a `.LEGAL.txt` file but to not link to them.</p>

  - p: >
      The default behavior is `none`. Setting the legal comment mode looks like this:

  - example:
      in:
        app.js: '1 + 2'

      cli: |
        esbuild app.js --legal-comments=eof

      mjs: |
        import * as esbuild from 'esbuild'

        await esbuild.build({
          entryPoints: ['app.js'],
          legalComments: 'eof',
        })

      go: |
        package main

        import "github.com/evanw/esbuild/pkg/api"
        import "os"

        func main() {
          result := api.Build(api.BuildOptions{
            EntryPoints:   []string{"app.js"},
            LegalComments: api.LegalCommentsEndOfFile,
          })

          if len(result.Errors) > 0 {
            os.Exit(1)
          }
        }

  - p: >
      Note that "statement-level" for JS and "rule-level" for CSS means the
      comment must appear in a context where multiple statements or rules
      are allowed such as in the top-level scope or in a statement or rule
      block. So comments inside expressions or at the declaration level are
      not considered legal comments.

  - h3: Splitting

  - warning: >
      Code splitting is still a work in progress. It currently only works with
      the `esm` output [format](#format). There is also a known
      [ordering issue](https://github.com/evanw/esbuild/issues/399) with
      `import` statements across code splitting chunks. You can follow
      [the tracking issue](https://github.com/evanw/esbuild/issues/16) for
      updates about this feature.

  - p: >
      This enables "code splitting" which serves two purposes:

  - ul:
      - >
        <p>
        Code shared between multiple entry points is split off into a separate
        shared file that both entry points import. That way if the user first
        browses to one page and then to another page, they don't have to
        download all of the JavaScript for the second page from scratch if the
        shared part has already been downloaded and cached by their browser.
        </p>

      - >
        <p>
        Code referenced through an asynchronous `import()` expression will be
        split off into a separate file and only loaded when that expression is
        evaluated. This allows you to improve the initial download time of your
        app by only downloading the code you need at startup, and then lazily
        downloading additional code if needed later.
        </p>
        <p>
        Without code splitting enabled, an `import()` expression becomes
        <code>Promise<wbr>.resolve()<wbr>.then(() =&gt; <wbr>require())</code>
        instead. This still preserves the asynchronous semantics of the
        expression but it means the imported code is included in the same
        bundle instead of being split off into a separate file.
        </p>

  - p: >
      When you enable code splitting you must also configure the output
      directory using the [outdir](#outdir) setting:

  - example:
      in:
        home.ts: '1 + 2'
        about.ts: '1 + 2'

      cli: |
        esbuild home.ts about.ts --bundle --splitting --outdir=out --format=esm

      mjs: |
        import * as esbuild from 'esbuild'

        await esbuild.build({
          entryPoints: ['home.ts', 'about.ts'],
          bundle: true,
          splitting: true,
          outdir: 'out',
          format: 'esm',
        })

      go: |
        package main

        import "github.com/evanw/esbuild/pkg/api"
        import "os"

        func main() {
          result := api.Build(api.BuildOptions{
            EntryPoints: []string{"home.ts", "about.ts"},
            Bundle:      true,
            Splitting:   true,
            Outdir:      "out",
            Format:      api.FormatESModule,
            Write:       true,
          })

          if len(result.Errors) > 0 {
            os.Exit(1)
          }
        }

  - h2: Output location

  - h3: Allow overwrite

  - p: >
      Enabling this setting allows output files to overwrite input files. It's
      not  enabled by default because doing so means overwriting your source
      code, which can lead to data loss if your code is not checked in. But
      supporting this makes certain workflows easier by avoiding the need for
      a temporary directory. So you can enable this when you want to deliberately
      overwrite your source code:

  - example:
      in:
        app.js: '1 + 2'

      cli: |
        esbuild app.js --outdir=. --allow-overwrite

      mjs: |
        import * as esbuild from 'esbuild'

        await esbuild.build({
          entryPoints: ['app.js'],
          outdir: '.',
          allowOverwrite: true,
        })

      go: |
        package main

        import "github.com/evanw/esbuild/pkg/api"
        import "os"

        func main() {
          result := api.Build(api.BuildOptions{
            EntryPoints:    []string{"app.js"},
            Outdir:         ".",
            AllowOverwrite: true,
          })

          if len(result.Errors) > 0 {
            os.Exit(1)
          }
        }

  - h3: Asset names

  - p: >
      This option controls the file names of the additional output files generated
      when the [loader](#loader) is set to [`file`](/content-types/#external-file).
      It configures the output paths using a template with placeholders that will
      be substituted with values specific to the file when the output path is
      generated. For example, specifying an asset name template of
      <code>assets/<wbr>[name]-<wbr>[hash]</code> puts all assets into a
      subdirectory called `assets` inside of the output directory and includes
      the content hash of the asset in the file name. Doing that looks like this:

  - example:
      in:
        app.js: 'import "./file.png"'
        file.png: 'a png file'

      cli: |
        esbuild app.js --asset-names=assets/[name]-[hash] --loader:.png=file --bundle --outdir=out

      mjs: |
        import * as esbuild from 'esbuild'

        await esbuild.build({
          entryPoints: ['app.js'],
          assetNames: 'assets/[name]-[hash]',
          loader: { '.png': 'file' },
          bundle: true,
          outdir: 'out',
        })

      go: |
        package main

        import "github.com/evanw/esbuild/pkg/api"
        import "os"

        func main() {
          result := api.Build(api.BuildOptions{
            EntryPoints: []string{"app.js"},
            AssetNames:  "assets/[name]-[hash]",
            Loader: map[string]api.Loader{
              ".png": api.LoaderFile,
            },
            Bundle: true,
            Outdir: "out",
          })

          if len(result.Errors) > 0 {
            os.Exit(1)
          }
        }

  - p: >
      There are four placeholders that can be used in asset path templates:

  - ul:
    - >
      `[dir]`
      <p>
      This is the relative path from the directory containing the asset file to
      the [outbase](#outbase) directory. Its purpose is to help asset output
      paths look more aesthetically pleasing by mirroring the input directory
      structure inside of the output directory.
      </p>

    - >
      `[name]`
      <p>
      This is the original file name of the asset without the extension. For
      example, if the asset was originally named `image.png` then `[name]` will
      be substituted with `image` in the template. It is not necessary to use
      this placeholder; it only exists to provide human-friendly asset names to
      make debugging easier.
      </p>

    - >
      `[hash]`
      <p>
      This is the content hash of the asset, which is useful to avoid name
      collisions. For example, your code may import <code>components/<wbr>button/<wbr>icon.png</code>
      and <code>components/<wbr>select/<wbr>icon.png</code> in which case
      you'll need the hash to distinguish between the two assets that are both
      named `icon`.
      </p>

    - >
      `[ext]`
      <p>
      This is the file extension of the asset (i.e. everything after the end of
      the last `.` character). It can be used to put different types of assets
      into different directories. For example, <code>--asset-names=<wbr>assets/<wbr>[ext]/<wbr>[name]-[hash]</code>
      might write out an asset named `image.png` as <code>assets/<wbr>png/<wbr>image-CQFGD2NG.png</code>.
      </p>

  - p: >
      Asset path templates do not need to include a file extension. The original
      file extension of the asset will be automatically added to the end of the
      output path after template substitution.

  - p: >
      This option is similar to the [chunk names](#chunk-names) and
      [entry names](#entry-names) options.

  - h3: Chunk names

  - p: >
      This option controls the file names of the chunks of shared code that are
      automatically generated when [code splitting](#splitting) is enabled.
      It configures the output paths using a template with placeholders that will
      be substituted with values specific to the chunk when the output path is
      generated. For example, specifying a chunk name template of
      <code>chunks/<wbr>[name]-<wbr>[hash]</code> puts all generated chunks into
      a subdirectory called `chunks` inside of the output directory and includes
      the content hash of the chunk in the file name. Doing that looks like this:

  - example:
      in:
        app.js: '1 + 2'

      cli: |
        esbuild app.js --chunk-names=chunks/[name]-[hash] --bundle --outdir=out --splitting --format=esm

      mjs: |
        import * as esbuild from 'esbuild'

        await esbuild.build({
          entryPoints: ['app.js'],
          chunkNames: 'chunks/[name]-[hash]',
          bundle: true,
          outdir: 'out',
          splitting: true,
          format: 'esm',
        })

      go: |
        package main

        import "github.com/evanw/esbuild/pkg/api"
        import "os"

        func main() {
          result := api.Build(api.BuildOptions{
            EntryPoints: []string{"app.js"},
            ChunkNames:  "chunks/[name]-[hash]",
            Bundle:      true,
            Outdir:      "out",
            Splitting:   true,
            Format:      api.FormatESModule,
          })

          if len(result.Errors) > 0 {
            os.Exit(1)
          }
        }

  - p: >
      There are three placeholders that can be used in chunk path templates:

  - ul:
    - >
      `[name]`
      <p>
      This will currently always be the text `chunk`, although this placeholder
      may take on additional values in future releases.
      </p>

    - >
      `[hash]`
      <p>
      This is the content hash of the chunk. Including this is necessary to
      distinguish different chunks from each other in the case where multiple
      chunks of shared code are generated.
      </p>

    - >
      `[ext]`
      <p>
      This is the file extension of the chunk (i.e. everything after the end of
      the last `.` character). It can be used to put different types of chunks
      into different directories. For example, <code>--chunk-names=<wbr>chunks/<wbr>[ext]/<wbr>[name]-[hash]</code>
      might write out a chunk as <code>chunks/<wbr>css/<wbr>chunk-DEFJT7KY.css</code>.
      </p>

  - p: >
      Chunk path templates do not need to include a file extension. The
      configured [out extension](#out-extension) for the appropriate content
      type will be automatically added to the end of the output path after
      template substitution.

  - p: >
      Note that this option only controls the names for automatically-generated
      chunks of shared code. It does _not_ control the names for output files
      related to entry points. The names of these are currently determined from
      the path of the original entry point file relative to the [outbase](#outbase)
      directory, and this behavior cannot be changed. An additional API option
      will be added in the future to let you change the file names of entry
      point output files.

  - p: >
      This option is similar to the [asset names](#asset-names) and
      [entry names](#entry-names) options.

  - h3: Entry names

  - p: >
      This option controls the file names of the output files corresponding to each
      input entry point file. It configures the output paths using a template with
      placeholders that will be substituted with values specific to the file when
      the output path is generated. For example, specifying an entry name template
      of <code>[dir]/<wbr>[name]-<wbr>[hash]</code> includes a hash of the output
      file in the file name and puts the files into the output directory,
      potentially under a subdirectory (see the details about `[dir]` below).
      Doing that looks like this:

  - example:
      in:
        src/main-app/app.js: '1 + 2'

      cli: |
        esbuild src/main-app/app.js --entry-names=[dir]/[name]-[hash] --outbase=src --bundle --outdir=out

      mjs: |
        import * as esbuild from 'esbuild'

        await esbuild.build({
          entryPoints: ['src/main-app/app.js'],
          entryNames: '[dir]/[name]-[hash]',
          outbase: 'src',
          bundle: true,
          outdir: 'out',
        })

      go: |
        package main

        import "github.com/evanw/esbuild/pkg/api"
        import "os"

        func main() {
          result := api.Build(api.BuildOptions{
            EntryPoints: []string{"src/main-app/app.js"},
            EntryNames:  "[dir]/[name]-[hash]",
            Outbase:     "src",
            Bundle:      true,
            Outdir:      "out",
          })

          if len(result.Errors) > 0 {
            os.Exit(1)
          }
        }

  - p: >
      There are four placeholders that can be used in entry path templates:

  - ul:
    - >
      `[dir]`
      <p>
      This is the relative path from the directory containing the input entry
      point file to the [outbase](#outbase) directory. Its purpose is to help
      you avoid collisions between identically-named entry points in different
      subdirectories.
      </p>
      <p>
      For example, if there are two entry points
      <code>src/<wbr>pages/<wbr>home/<wbr>index.ts</code> and
      <code>src/<wbr>pages/<wbr>about/<wbr>index.ts</code>, the outbase
      directory is `src`, and the entry names template is `[dir]/[name]`,
      the output directory will contain <code>pages/<wbr>home/<wbr>index.js</code>
      and <code>pages/<wbr>about/<wbr>index.js</code>. If the entry names
      template had been just `[name]` instead, bundling would have failed
      because there would have been two output files with the same output path
      `index.js` inside the output directory.
      </p>

    - >
      `[name]`
      <p>
      This is the original file name of the entry point without the extension.
      For example, if the input entry point file is named `app.js` then `[name]`
      will be substituted with `app` in the template.
      </p>

    - >
      `[hash]`
      <p>
      This is the content hash of the output file, which can be used to take
      optimal advantage of browser caching. Adding `[hash]` to your entry
      point names means esbuild will calculate a hash that relates to all
      content in the corresponding output file (and any output file it imports
      if [code splitting](#splitting) is active). The hash is designed to change
      if and only if any of the input files relevant to that output file are
      changed.
      </p>
      <p>
      After that, you can have your web server tell browsers that to cache these
      files forever (in practice you can say they expire a very long time from
      now such as in a year). You can then use the information in the
      [metafile](#metafile) to determine which output file path corresponds to
      which input entry point so you know what path to include in your `<script>`
      tag.
      </p>

    - >
      `[ext]`
      <p>
      This is the file extension that the entry point file will be written out to
      (i.e. the [out extension](#out-extension) setting, not the original file
      extension). It can be used to put different types of entry points into different
      directories. For example, <code>--entry-names=<wbr>entries/<wbr>[ext]/<wbr>[name]</code>
      might write the output file for `app.ts` to <code>entries/<wbr>js/<wbr>app.js</code>.
      </p>

  - p: >
      Entry path templates do not need to include a file extension. The appropriate
      [out extension](#out-extension) based on the file type will be automatically
      added to the end of the output path after template substitution.

  - p: >
      This option is similar to the [asset names](#asset-names) and
      [chunk names](#chunk-names) options.

  - h3: Out extension

  - p: >
      This option lets you customize the file extension of the files that
      esbuild generates to something other than `.js` or `.css`. In particular,
      the `.mjs` and `.cjs` file extensions have special meaning in node (they
      indicate a file in ESM and CommonJS format, respectively). This option is
      useful if you are using esbuild to generate multiple files and you have
      to use the [outdir](#outdir) option instead of the [outfile](#outfile)
      option. You can use it like this:

  - example:
      in:
        app.js: '1 + 2'

      cli: |
        esbuild app.js --bundle --outdir=dist --out-extension:.js=.mjs

      mjs: |
        import * as esbuild from 'esbuild'

        await esbuild.build({
          entryPoints: ['app.js'],
          bundle: true,
          outdir: 'dist',
          outExtension: { '.js': '.mjs' },
        })

      go: |
        package main

        import "github.com/evanw/esbuild/pkg/api"
        import "os"

        func main() {
          result := api.Build(api.BuildOptions{
            EntryPoints: []string{"app.js"},
            Bundle:      true,
            Outdir:      "dist",
            OutExtension: map[string]string{
              ".js": ".mjs",
            },
            Write: true,
          })

          if len(result.Errors) > 0 {
            os.Exit(1)
          }
        }

  - h3: Outbase

  - p: >
      If your build contains multiple entry points in separate directories, the
      directory structure will be replicated into the [output directory](#outdir)
      relative to the outbase directory. For example, if there are two entry
      points <code>src/<wbr>pages/<wbr>home/<wbr>index.ts</code> and
      <code>src/<wbr>pages/<wbr>about/<wbr>index.ts</code> and the outbase directory is
      `src`, the output directory will contain <code>pages/<wbr>home/<wbr>index.js</code>
      and <code>pages/<wbr>about/<wbr>index.js</code>. Here's how to use it:

  - example:
      in:
        src/pages/home/index.ts: '1 + 2'
        src/pages/about/index.ts: '3 + 4'

      cli: |
        esbuild src/pages/home/index.ts src/pages/about/index.ts --bundle --outdir=out --outbase=src

      mjs: |
        import * as esbuild from 'esbuild'

        await esbuild.build({
          entryPoints: [
            'src/pages/home/index.ts',
            'src/pages/about/index.ts',
          ],
          bundle: true,
          outdir: 'out',
          outbase: 'src',
        })

      go: |
        package main

        import "github.com/evanw/esbuild/pkg/api"
        import "os"

        func main() {
          result := api.Build(api.BuildOptions{
            EntryPoints: []string{
              "src/pages/home/index.ts",
              "src/pages/about/index.ts",
            },
            Bundle:  true,
            Outdir:  "out",
            Outbase: "src",
          })

          if len(result.Errors) > 0 {
            os.Exit(1)
          }
        }

  - p: >
      If the outbase directory isn't specified, it defaults to the
      [lowest common ancestor](https://en.wikipedia.org/wiki/Lowest_common_ancestor)
      directory among all input entry point paths. This is <code>src/<wbr>pages</code>
      in the example above, which means by default the output directory will
      contain <code>home/<wbr>index.js</code> and <code>about/<wbr>index.js</code>
      instead.

  - h3: Outdir

  - p: >
      This option sets the output directory for the build operation. For
      example, this command will generate a directory called `out`:

  - example:
      in:
        app.js: '1 + 2'

      cli: |
        esbuild app.js --bundle --outdir=out

      mjs: |
        import * as esbuild from 'esbuild'

        await esbuild.build({
          entryPoints: ['app.js'],
          bundle: true,
          outdir: 'out',
        })

      go: |
        package main

        import "github.com/evanw/esbuild/pkg/api"
        import "os"

        func main() {
          result := api.Build(api.BuildOptions{
            EntryPoints: []string{"app.js"},
            Bundle:      true,
            Outdir:      "out",
          })

          if len(result.Errors) > 0 {
            os.Exit(1)
          }
        }

  - p: >
      The output directory will be generated if it does not already exist, but
      it will not be cleared if it already contains some files. Any generated
      files will silently overwrite existing files with the same name. You
      should clear the output directory yourself before running esbuild if you
      want the output directory to only contain files from the current run of
      esbuild.

  - p: >
      If your build contains multiple entry points in separate directories, the
      directory structure will be replicated into the output directory starting
      from the [lowest common ancestor](https://en.wikipedia.org/wiki/Lowest_common_ancestor)
      directory among all input entry point paths. For example, if there are
      two entry points <code>src/<wbr>home/<wbr>index.ts</code> and
      <code>src/<wbr>about/<wbr>index.ts</code>, the output directory will
      contain <code>home/<wbr>index.js</code> and <code>about/<wbr>index.js</code>.
      If you want to customize this behavior, you should change the
      [outbase directory](#outbase).

  - h3: Outfile

  - p: >
      This option sets the output file name for the build operation. This is
      only applicable if there is a single entry point. If there are multiple
      entry points, you must use the [outdir](#outdir) option instead to
      specify an output directory. Using outfile looks like this:

  - example:
      in:
        app.js: '1 + 2'

      cli: |
        esbuild app.js --bundle --outfile=out.js

      mjs: |
        import * as esbuild from 'esbuild'

        await esbuild.build({
          entryPoints: ['app.js'],
          bundle: true,
          outfile: 'out.js',
        })

      go: |
        package main

        import "github.com/evanw/esbuild/pkg/api"
        import "os"

        func main() {
          result := api.Build(api.BuildOptions{
            EntryPoints: []string{"app.js"},
            Bundle:      true,
            Outdir:      "out.js",
          })

          if len(result.Errors) > 0 {
            os.Exit(1)
          }
        }

  - h3: Public path

  - p: >
      This is useful in combination with the [external file](/content-types/#external-file)
      loader. By default that loader exports the name of the imported file as a
      string using the `default` export. The public path option lets you
      prepend a base path to the exported string of each file loaded by this
      loader:

  - example:
      in:
        app.js: |
          import url from './example.png'
          let image = new Image
          image.src = url
          document.body.appendChild(image)
        example.png: |
          this is some data

      cli: |
        esbuild app.js --bundle --loader:.png=file --public-path=https://www.example.com/v1 --outdir=out

      mjs: |
        import * as esbuild from 'esbuild'

        await esbuild.build({
          entryPoints: ['app.js'],
          bundle: true,
          loader: { '.png': 'file' },
          publicPath: 'https://www.example.com/v1',
          outdir: 'out',
        })

      go: |
        package main

        import "github.com/evanw/esbuild/pkg/api"
        import "os"

        func main() {
          result := api.Build(api.BuildOptions{
            EntryPoints: []string{"app.js"},
            Bundle:      true,
            Loader: map[string]api.Loader{
              ".png": api.LoaderFile,
            },
            Outdir:     "out",
            PublicPath: "https://www.example.com/v1",
            Write:      true,
          })

          if len(result.Errors) > 0 {
            os.Exit(1)
          }
        }

  - h3: Write

  - p: >
      The build API call can either write to the file system directly or return
      the files that would have been written as in-memory buffers. By default
      the CLI and JavaScript APIs write to the file system and the Go API
      doesn't. To use the in-memory buffers:

  - example:
      in:
        app.js: '1 + 2'

      mjs: |
        import * as esbuild from 'esbuild'

        let result = await esbuild.build({
          entryPoints: ['app.js'],
          sourcemap: 'external',
          write: false,
          outdir: 'out',
        })

        for (let out of result.outputFiles) {
          console.log(out.path, out.contents, out.text)
        }

      go: |
        package main

        import "fmt"
        import "github.com/evanw/esbuild/pkg/api"
        import "os"

        func main() {
          result := api.Build(api.BuildOptions{
            EntryPoints: []string{"app.js"},
            Sourcemap:   api.SourceMapExternal,
            Write:       false,
            Outdir:      "out",
          })

          if len(result.Errors) > 0 {
            os.Exit(1)
          }

          for _, out := range result.OutputFiles {
            fmt.Printf("%v %v\n", out.Path, out.Contents)
          }
        }

  - h2: Path resolution

  - h3: Alias

  - p: >
      This feature lets you substitute one package for another when bundling.
      The example below substitutes the package `oldpkg` with the package
      `newpkg`:

  - example:
      in:
        app.js: 'import "oldpkg/foo"'
        node_modules/newpkg/foo.js: 'works'

      cli: |
        esbuild app.js --bundle --alias:oldpkg=newpkg

      mjs: |
        import * as esbuild from 'esbuild'

        await esbuild.build({
          entryPoints: ['app.js'],
          bundle: true,
          write: true,
          alias: {
            'oldpkg': 'newpkg',
          },
        })

      go: |
        package main

        import "github.com/evanw/esbuild/pkg/api"
        import "os"

        func main() {
          result := api.Build(api.BuildOptions{
            EntryPoints: []string{"app.js"},
            Bundle:      true,
            Write:       true,
            Alias: map[string]string{
              "oldpkg": "newpkg",
            },
          })

          if len(result.Errors) > 0 {
            os.Exit(1)
          }
        }

  - p: >
      These new substitutions happen first before all of esbuild's other path
      resolution logic. One use case for this feature is replacing a node-only
      package with a browser-friendly package in third-party code that you
      don't control.

  - p: >
      Note that when an import path is substituted using an alias, the resulting
      import path is resolved in the working directory instead of in the directory
      containing the source file with the import path. If needed, the working
      directory that esbuild uses can be set with the [working directory](#working-directory)
      feature.

  - h3: Conditions

  - p: >
      This feature controls how the `exports` field in `package.json` is
      interpreted. Custom conditions can be added using the conditions setting.
      You can specify as many of these as you want and the meaning of these is
      entirely up to package authors. Node has currently only endorsed the
      `development` and `production` custom conditions for recommended use.
      Here is an example of adding the custom conditions `custom1` and `custom2`:

  - example:
      in:
        src/app.js: 'import "pkg"'
        src/node_modules/pkg/package.json: '{ "exports": { "custom1": "./foo.js" } }'
        src/node_modules/pkg/foo.js: 'console.log(123)'

      cli: |
        esbuild src/app.js --bundle --conditions=custom1,custom2

      mjs: |
        import * as esbuild from 'esbuild'

        await esbuild.build({
          entryPoints: ['src/app.js'],
          bundle: true,
          conditions: ['custom1', 'custom2'],
        })

      go: |
        package main

        import "github.com/evanw/esbuild/pkg/api"
        import "os"

        func main() {
          result := api.Build(api.BuildOptions{
            EntryPoints: []string{"src/app.js"},
            Bundle:      true,
            Conditions:  []string{"custom1", "custom2"},
          })

          if len(result.Errors) > 0 {
            os.Exit(1)
          }
        }

  - h4: How conditions work

  - p: >
      Conditions allow you to redirect the same import path to different file
      locations in different situations. The redirect map containing the
      conditions and paths is stored in the `exports` field in the package's
      `package.json` file. For example, this would remap `require('pkg/foo')`
      to `pkg/required.cjs` and `import 'pkg/foo'` to `pkg/imported.mjs`
      using the `import` and `require` conditions:

  - pre.json: |
      {
        "name": "pkg",
        "exports": {
          "./foo": {
            "import": "./imported.mjs",
            "require": "./required.cjs",
            "default": "./fallback.js"
          }
        }
      }

  - p: >
      Conditions are checked in the order that they appear within the JSON file.
      So the example above behaves sort of like this:

  - pre.js: |
      if (importPath === './foo') {
        if (conditions.has('import')) return './imported.mjs'
        if (conditions.has('require')) return './required.cjs'
        return './fallback.js'
      }

  - p: >
      By default there are five conditions with special behavior that are built
      in to esbuild, and cannot be disabled:

  - ul:
    - >
      `default`
      <p>
      This condition is always active. It is intended to come last and lets you
      provide a fallback for when no other condition applies. This condition is
      also active when you run your code natively in node.
      </p>
    - >
      `import`
      <p>
      This condition is only active when the import path is from an ESM `import`
      statement or `import()` expression. It can be used to provide ESM-specific
      code. This condition is also active when you run your code natively in node
      (but only in an ESM context).
      </p>
    - >
      `require`
      <p>
      This condition is only active when the import path is from a CommonJS
      `require()` call. It can be used to provide CommonJS-specific code. This
      condition is also active when you run your code natively in node (but only
      in a CommonJS context).
      </p>
    - >
      `browser`
      <p>
      This condition is only active when esbuild's [platform](#platform) setting
      is set to `browser`. It can be used to provide browser-specific code. This
      condition is not active when you run your code natively in node.
      </p>
    - >
      `node`
      <p>
      This condition is only active when esbuild's [platform](#platform) setting
      is set to `node`. It can be used to provide node-specific code. This
      condition is also active when you run your code natively in node.
      </p>

  - p: >
      The following condition is also automatically included when the [platform](#platform)
      is set to either `browser` or `node` and no custom conditions are
      configured. If there are any custom conditions configured (even an empty
      list) then this condition will no longer be automatically included:

  - ul:
    - >
      `module`
      <p>
      This condition can be used to tell esbuild to pick the ESM variant for a
      given import path to provide better tree-shaking when bundling. This
      condition is not active when you run your code natively in node. It is
      specific to bundlers, and originated from Webpack.
      </p>

  - p: >
      Note that when you use the `require` and `import` conditions, _your
      package may end up in the bundle multiple times!_ This is a subtle issue
      that can cause bugs due to duplicate copies of your code's state in
      addition to bloating the resulting bundle. This is commonly known as the
      [dual package hazard](https://nodejs.org/docs/latest/api/packages.html#packages_dual_package_hazard).

  - p: >
      One way of avoiding the dual package hazard that works both for bundlers
      and when running natively in node is to put all of your code in the
      `require` condition as CommonJS and have the `import` condition just be a
      light ESM wrapper that calls `require` on your package and re-exports the
      package using ESM syntax. This approach doesn't provide good tree-shaking,
      however, as esbuild doesn't tree-shake CommonJS modules.

  - p: >
      Another way of avoiding a dual package hazard is to use the bundler-specific
      `module` condition to direct bundlers to always load the ESM version of your
      package while letting node always fall back to the CommonJS version of
      your package. Both `import` and `module` are intended to be used with ESM
      but unlike `import`, the `module` condition is always active even if the
      import path was loaded using a `require` call. This works well with bundlers
      because bundlers support loading ESM using `require`, but it's not something
      that can work with node because node deliberately doesn't implement loading
      ESM using `require`.

  - h3: External

  - p: >
      You can mark a file or a package as external to exclude it from your
      build. Instead of being bundled, the import will be preserved (using
      `require` for the `iife` and `cjs` formats and using `import` for the
      `esm` format) and will be evaluated at run time instead.

  - p: >
      This has several uses. First of all, it can be used to trim unnecessary
      code from your bundle for a code path that you know will never be
      executed. For example, a package may contain code that only runs in node
      but you will only be using that package in the browser. It can also be
      used to import code in node at run time from a package that cannot be
      bundled. For example, the `fsevents` package contains a native extension,
      which esbuild doesn't support. Marking something as external looks like
      this:

  - example:
      cli:
        - $: |
            echo 'require("fsevents")' > app.js
        - $: |
            esbuild app.js --bundle --external:fsevents --platform=node
        - expect: |
            // app.js
            require("fsevents");

      mjs: |
        import * as esbuild from 'esbuild'
        import fs from 'node:fs'

        fs.writeFileSync('app.js', 'require("fsevents")')

        await esbuild.build({
          entryPoints: ['app.js'],
          outfile: 'out.js',
          bundle: true,
          platform: 'node',
          external: ['fsevents'],
        })

      go: |
        package main

        import "io/ioutil"
        import "github.com/evanw/esbuild/pkg/api"
        import "os"

        func main() {
          ioutil.WriteFile("app.js", []byte("require(\"fsevents\")"), 0644)

          result := api.Build(api.BuildOptions{
            EntryPoints: []string{"app.js"},
            Outfile:     "out.js",
            Bundle:      true,
            Write:       true,
            Platform:    api.PlatformNode,
            External:    []string{"fsevents"},
          })

          if len(result.Errors) > 0 {
            os.Exit(1)
          }
        }

  - p: >
      You can also use the `*` wildcard character in an external path to mark
      all files matching that pattern as external. For example, you can use
      `*.png` to remove all `.png` files or `/images/*` to remove all paths
      starting with `/images/`:

  - example:
      in:
        app.js: 'import "/images/*"; import "*.png"'

      cli: |
        esbuild app.js --bundle "--external:*.png" "--external:/images/*"

      mjs: |
        import * as esbuild from 'esbuild'

        await esbuild.build({
          entryPoints: ['app.js'],
          outfile: 'out.js',
          bundle: true,
          external: ['*.png', '/images/*'],
        })

      go: |
        package main

        import "github.com/evanw/esbuild/pkg/api"
        import "os"

        func main() {
          result := api.Build(api.BuildOptions{
            EntryPoints: []string{"app.js"},
            Outfile:     "out.js",
            Bundle:      true,
            Write:       true,
            External:    []string{"*.png", "/images/*"},
          })

          if len(result.Errors) > 0 {
            os.Exit(1)
          }
        }

  - p: >
      External paths are applied both before and after path resolution, which
      lets you match against both the import path in the source code and the
      absolute file system path. The path is considered to be external if the
      external path matches in either case. The specific behavior is as follows:

  - ul:
    - >
      <p>
      Before path resolution begins, import paths are checked against all
      external paths. In addition, if the external path looks like a package
      path (i.e. doesn't start with `/` or `./` or `../`), import paths are
      checked to see if they have that package path as a path prefix.
      </p>
      <p>
      This means that <code>--external:<wbr>@foo/<wbr>bar</code> implicitly
      also means <code>--external:<wbr>@foo/<wbr>bar/\*</code> which matches
      the import path <code>@foo/<wbr>bar/<wbr>baz</code>. So it marks all
      paths inside the `@foo/bar` package as external too.
      </p>

    - >
      <p>
      After path resolution ends, the resolved absolute paths are checked
      against all external paths that don't look like a package path (i.e.
      those that start with `/` or `./` or `../`). But before checking, the
      external path is joined with the current working directory and then
      normalized, becoming an absolute path (even if it contains a `*`
      wildcard character).
      </p>
      <p>
      This means that you can mark everything in the directory `dir` as
      external using <code>--external:<wbr>./dir/\*</code>. Note that the
      leading `./` is important. Using <code>--external:<wbr>dir/\*</code>
      instead is treated as a package path and is not checked for after
      path resolution ends.
      </p>

  - h3: Main fields

  - p: >
      When you import a package in node, the `main` field in that package's
      `package.json` file determines which file is imported (along with
      [a lot of other rules](https://nodejs.org/api/modules.html#all-together)).
      Major JavaScript bundlers including esbuild let you specify additional
      `package.json` fields to try when resolving a package. There are at least
      three such fields commonly in use:

  - ul:
    - >
      `main`
      <p>
      This is [the standard field](https://docs.npmjs.com/files/package.json#main)
      for all packages that are meant to be used with node. The name `main` is
      hard-coded in to node's module resolution logic itself. Because it's
      intended for use with node, it's reasonable to expect that the file path
      in this field is a CommonJS-style module.
      </p>

    - >
      `module`
      <p>
      This field came from [a proposal](https://github.com/dherman/defense-of-dot-js/blob/f31319be735b21739756b87d551f6711bd7aa283/proposal.md)
      for how to integrate ECMAScript modules into node. Because of this, it's
      reasonable to expect that the file path in this field is an
      ECMAScript-style module. This proposal wasn't adopted by node (node uses
      <code>"type": <wbr>"module"</code> instead) but it was adopted by major
      bundlers because ECMAScript-style modules lead to better [tree shaking](#tree-shaking),
      or dead code removal.
      </p>
      <p>
      For package authors: Some packages incorrectly use the `module` field for
      browser-specific code, leaving node-specific code for the `main` field.
      This is probably because node ignores the `module` field and people
      typically only use bundlers for browser-specific code. However, bundling
      node-specific code is valuable too (e.g. it decreases download and boot
      time) and packages that put browser-specific code in `module` prevent
      bundlers from being able to do tree shaking effectively. If you are
      trying to publish browser-specific code in a package, use the `browser`
      field instead.
      </p>

    - >
      `browser`
      <p>
      This field came from [a proposal](https://gist.github.com/defunctzombie/4339901/49493836fb873ddaa4b8a7aa0ef2352119f69211)
      that allows bundlers to replace node-specific files or modules with their
      browser-friendly versions. It lets you specify an alternate
      browser-specific entry point. Note that it is possible for a package to
      use both the `browser` and `module` field together (see the note below).
      </p>

  - p: >
      The default main fields depend on the current [platform](#platform)
      setting. These defaults should be the most widely compatible with the
      existing package ecosystem. But you can customize them like this if you
      want to:

  - example:
      in:
        app.js: '1 + 2'

      cli: |
        esbuild app.js --bundle --main-fields=module,main

      mjs: |
        import * as esbuild from 'esbuild'

        await esbuild.build({
          entryPoints: ['app.js'],
          bundle: true,
          mainFields: ['module', 'main'],
          outfile: 'out.js',
        })

      go: |
        package main

        import "github.com/evanw/esbuild/pkg/api"
        import "os"

        func main() {
          result := api.Build(api.BuildOptions{
            EntryPoints: []string{"app.js"},
            Bundle:      true,
            MainFields:  []string{"module", "main"},
            Write:       true,
          })

          if len(result.Errors) > 0 {
            os.Exit(1)
          }
        }

  - h4#main-fields-for-package-authors: For package authors

  - p: >
      If you want to author a package that uses the `browser` field in
      combination with the `module` field, then you'll probably want to fill
      out **_all four entries_** in the full CommonJS-vs-ESM and
      browser-vs-node compatibility matrix. For that you'll need to use the
      expanded form of the `browser` field that is a map instead of just a
      string:

  - pre.json: >
      {
        "main": "./node-cjs.js",
        "module": "./node-esm.js",
        "browser": {
          "./node-cjs.js": "./browser-cjs.js",
          "./node-esm.js": "./browser-esm.js"
        }
      }

  - p: >
      The `main` field is expected to be CommonJS while the `module` field is
      expected to be ESM. The decision about which module format to use is
      independent from the decision about whether to use a browser-specific
      or node-specific variant. If you omit one of these four entries, then you
      risk the wrong variant being chosen. For example, if you omit the entry
      for the CommonJS browser build, then the CommonJS node build could be
      chosen instead.

  - p: >
      Note that using `main`, `module`, and `browser` is the old way of doing
      this. There is also a newer way to do this that you may prefer to use
      instead: the [`exports` field](#how-conditions-work) in `package.json`.
      It provides a different set of trade-offs. For example, it gives you more
      precise control over imports for all sub-paths in your package (while
      `main` fields only give you control over the entry point), but it may
      cause your package to be imported multiple times depending on how you
      configure it.

  - h3: Node paths

  - p: >
      Node's module resolution algorithm supports an environment variable called
      [`NODE_PATH`](https://nodejs.org/api/modules.html#modules_loading_from_the_global_folders)
      that contains a list of global directories to use when resolving import
      paths. These paths are searched for packages in addition to the
      `node_modules` directories in all parent directories. You can pass this
      list of directories to esbuild using an environment variable with the CLI
      and using an array with the JS and Go APIs:

  - example:
      in:
        app.js: 'import {x} from "test"'
        someDir/test.js: 'export let x'

      cli: |
        NODE_PATH=someDir esbuild app.js --bundle --outfile=out.js

      mjs: |
        import * as esbuild from 'esbuild'

        await esbuild.build({
          nodePaths: ['someDir'],
          entryPoints: ['app.js'],
          bundle: true,
          outfile: 'out.js',
        })

      go: |
        package main

        import "github.com/evanw/esbuild/pkg/api"
        import "os"

        func main() {
          result := api.Build(api.BuildOptions{
            NodePaths:   []string{"someDir"},
            EntryPoints: []string{"app.js"},
            Bundle:      true,
            Outfile:     "out.js",
            Write:       true,
          })

          if len(result.Errors) > 0 {
            os.Exit(1)
          }
        }

  - p: >
      If you are using the CLI and want to pass multiple directories using
      `NODE_PATH`, you will have to separate them with `:` on Unix and `;` on
      Windows. This is the same format that Node itself uses.

  - h3: Packages

  - p: >
      Use this setting to exclude all of your package's dependencies from the bundle.
      This is useful when [bundling for node](/getting-started/#bundling-for-node)
      because many npm packages use node-specific features that esbuild doesn't
      support while bundling (such as `__dirname`, `import.meta.url`, `fs.readFileSync`,
      and `*.node` native binary modules). Using it looks like this:

  - example:
      in:
        app.js: 'import "pkg"'

      cli: |
        esbuild app.js --bundle --packages=external

      mjs: |
        import * as esbuild from 'esbuild'

        await esbuild.build({
          entryPoints: ['app.js'],
          bundle: true,
          packages: 'external',
        })

      go: |
        package main

        import "github.com/evanw/esbuild/pkg/api"
        import "os"

        func main() {
          result := api.Build(api.BuildOptions{
            EntryPoints: []string{"app.js"},
            Bundle:      true,
            Packages:    api.PackagesExternal,
          })

          if len(result.Errors) > 0 {
            os.Exit(1)
          }
        }

  - p: >
      Enabling this automatically marks all import paths that look like npm
      packages (i.e. that don't start with a `.` or `..` path component and
      that aren't absolute paths) as external. It has the same effect as
      manually passing each dependency to [external](#external) but is more
      concise. If you want to customize which of your dependencies are
      external and which ones aren't, then you should be using
      [external](#external) instead of this setting.

  - p: >
      Note that this setting only has an effect when [bundling](#bundle) is
      enabled. Also note that marking an import path as external happens after
      the import path is rewritten by any configured [aliases](#alias), so the
      alias feature still has an effect when this setting is used.

  - h3: Preserve symlinks

  - p: >
      This setting mirrors the [`--preserve-symlinks`](https://nodejs.org/api/cli.html#cli_preserve_symlinks)
      setting in node. If you use that setting (or the similar [`resolve.symlinks`](https://webpack.js.org/configuration/resolve/#resolvesymlinks)
      setting in Webpack), you will likely need to enable this setting in
      esbuild too. It can be enabled like this:

  - example:
      in:
        app.js: '1 + 2'

      cli: |
        esbuild app.js --bundle --preserve-symlinks --outfile=out.js

      mjs: |
        import * as esbuild from 'esbuild'

        await esbuild.build({
          entryPoints: ['app.js'],
          bundle: true,
          preserveSymlinks: true,
          outfile: 'out.js',
        })

      go: |
        package main

        import "github.com/evanw/esbuild/pkg/api"
        import "os"

        func main() {
          result := api.Build(api.BuildOptions{
            EntryPoints:      []string{"app.js"},
            Bundle:           true,
            PreserveSymlinks: true,
            Outfile:          "out.js",
          })

          if len(result.Errors) > 0 {
            os.Exit(1)
          }
        }

  - p: >
      Enabling this setting causes esbuild to determine file identity by the
      original file path (i.e. the path without following symlinks) instead of
      the real file path (i.e. the path after following symlinks). This can be
      beneficial with certain directory structures. Keep in mind that this means
      a file may be given multiple identities if there are multiple symlinks
      pointing to it, which can result in it appearing multiple times in
      generated output files.

  - p: >
      _Note: The term "symlink" means [symbolic link](https://en.wikipedia.org/wiki/Symbolic_link)
      and refers to a file system feature where a path can redirect to another
      path._

  - h3: Resolve extensions

  - p: >
      The [resolution algorithm used by node](https://nodejs.org/api/modules.html#modules_file_modules)
      supports implicit file extensions. You can <code>require(<wbr>'./file')</code> and it
      will check for `./file`, `./file.js`, `./file.json`, and `./file.node` in
      that order. Modern bundlers including esbuild extend this concept to other
      file types as well. The full order of implicit file extensions in esbuild
      can be customized using the resolve extensions setting, which defaults to
      <code>.tsx,<wbr>.ts,<wbr>.jsx,<wbr>.js,<wbr>.css,<wbr>.json</code>:

  - example:
      in:
        app.js: '1 + 2'

      cli: |
          esbuild app.js --bundle --resolve-extensions=.ts,.js

      mjs: |
        import * as esbuild from 'esbuild'

        await esbuild.build({
          entryPoints: ['app.js'],
          bundle: true,
          resolveExtensions: ['.ts', '.js'],
          outfile: 'out.js',
        })

      go: |
        package main

        import "github.com/evanw/esbuild/pkg/api"
        import "os"

        func main() {
          result := api.Build(api.BuildOptions{
            EntryPoints:       []string{"app.js"},
            Bundle:            true,
            ResolveExtensions: []string{".ts", ".js"},
            Write:             true,
          })

          if len(result.Errors) > 0 {
            os.Exit(1)
          }
        }

  - p: >
      Note that esbuild deliberately does not include the new `.mjs` and `.cjs`
      extensions in this list. Node's resolution algorithm doesn't treat these
      as implicit file extensions, so esbuild doesn't either. If you want to
      import files with these extensions you should either explicitly add the
      extensions in your import paths or change this setting to include the
      additional extensions that you want to be implicit.

  - h3: Working directory

  - p: >
      This API option lets you specify the working directory to use for the
      build. It normally defaults to the current [working directory](https://en.wikipedia.org/wiki/Working_directory)
      of the process you are using to call esbuild's API. The working directory
      is used by esbuild for a few different things including resolving relative
      paths given as API options to absolute paths and pretty-printing absolute
      paths as relative paths in log messages. Here is how to customize esbuild's
      working directory:

  - example:
      in:
        /var/tmp/custom/working/directory/file.js: 'export let foo = 123'

      cli: |
        cd "/var/tmp/custom/working/directory"

      mjs: |
        import * as esbuild from 'esbuild'

        await esbuild.build({
          entryPoints: ['file.js'],
          absWorkingDir: '/var/tmp/custom/working/directory',
          outfile: 'out.js',
        })

      go: |
        package main

        import "github.com/evanw/esbuild/pkg/api"
        import "os"

        func main() {
          result := api.Build(api.BuildOptions{
            EntryPoints:   []string{"file.js"},
            AbsWorkingDir: "/var/tmp/custom/working/directory",
            Outfile:       "out.js",
          })

          if len(result.Errors) > 0 {
            os.Exit(1)
          }
        }

  - p: >
      Note: If you are using [Yarn Plug'n'Play](https://yarnpkg.com/features/pnp/),
      keep in mind that this working directory is used to search for Yarn's
      manifest file. If you are running esbuild from an unrelated directory,
      you will have to set this working directory to the directory containing
      the manifest file (or one of its child directories) for the manifest
      file to be found by esbuild.

  - h2: Transformation

  - h3: JSX

  - p: >
      This option tells esbuild what to do about JSX syntax. Here are the available options:

  - ul:
    - >
      `transform`
      <p>
      This tells esbuild to transform JSX to JS using a general-purpose
      transform that's shared between many libraries that use JSX syntax.
      Each JSX element is turned into a call to the [JSX factory](#jsx-factory)
      function with the element's component (or with the [JSX fragment](#jsx-fragment)
      for fragments) as the first argument. The second argument is an array of
      props (or `null` if there are no props). Any child elements present
      become additional arguments after the second argument.
      </p>
      <p>
      If you want to configure this setting on a per-file basis, you can do
      that by using a <code>// @jsxRuntime <wbr>classic</code> comment. This is
      a convention from [Babel's JSX plugin](https://babeljs.io/docs/en/babel-preset-react/)
      that esbuild follows.
      </p>

    - >
      `preserve`
      <p>
      This preserves the JSX syntax in the output instead of transforming it
      into function calls. JSX elements are treated as first-class syntax and
      are still affected by other settings such as [minification](#minify) and
      [property mangling](#mangle-props).
      </p>
      <p>
      Note that this means the output files are no longer valid JavaScript code.
      This feature is intended to be used when you want to transform the JSX
      syntax in esbuild's output files by another tool after bundling.
      </p>

    - >
      `automatic`
      <p>
      This transform was [introduced in React 17+](https://reactjs.org/blog/2020/09/22/introducing-the-new-jsx-transform.html)
      and is very specific to React. It automatically generates `import`
      statements from the [JSX import source](#jsx-import-source) and introduces
      many special cases regarding how the syntax is handled. The details are too
      complicated to describe here. For more information, please read
      [React's documentation about their new JSX transform](https://github.com/reactjs/rfcs/blob/createlement-rfc/text/0000-create-element-changes.md).
      If you want to enable the development mode version of this transform, you
      need to additionally enable the [JSX dev](#jsx-dev) setting.
      </p>
      <p>
      If you want to configure this setting on a per-file basis, you can do
      that by using a <code>// @jsxRuntime <wbr>automatic</code> comment. This is
      a convention from [Babel's JSX plugin](https://babeljs.io/docs/en/babel-preset-react/)
      that esbuild follows.
      </p>

  - p: >
      Here's an example of setting the JSX transform to `preserve`:

  - example:
      cli:
        - $: |
            echo '<div/>' | esbuild --jsx=preserve --loader=jsx
        - expect: |
            <div />;

      mjs: |
        import * as esbuild from 'esbuild'

        let result = await esbuild.transform('<div/>', {
          jsx: 'preserve',
          loader: 'jsx',
        })

        console.log(result.code)

      go: |
        package main

        import "fmt"
        import "github.com/evanw/esbuild/pkg/api"

        func main() {
          result := api.Transform("<div/>", api.TransformOptions{
            JSX:    api.JSXPreserve,
            Loader: api.LoaderJSX,
          })

          if len(result.Errors) == 0 {
            fmt.Printf("%s", result.Code)
          }
        }

  - h3: JSX dev

  - p: >
      If the [JSX](#jsx) transform has been set to `automatic`, then enabling
      this setting causes esbuild to automatically inject the file name and
      source location into each JSX element. Your JSX library can then use
      this information to help with debugging. If the JSX transform has been
      set to something other than `automatic`, then this setting does nothing.
      Here's an example of enabling this setting:

  - example:
      in:
        app.jsx: '<a/>'

      cli:
        - $: |
            echo '<a/>' | esbuild --loader=jsx --jsx=automatic
        - expect: |
            import { jsx } from "react/jsx-runtime";
            /* @__PURE__ */ jsx("a", {});

        - $: |
            echo '<a/>' | esbuild --loader=jsx --jsx=automatic --jsx-dev
        - expect: |
            import { jsxDEV } from "react/jsx-dev-runtime";
            /* @__PURE__ */ jsxDEV("a", {}, void 0, false, {
              fileName: "<stdin>",
              lineNumber: 1,
              columnNumber: 1
            }, this);

      mjs: |
        import * as esbuild from 'esbuild'

        await esbuild.build({
          entryPoints: ['app.jsx'],
          jsxDev: true,
          jsx: 'automatic',
          outfile: 'out.js',
        })

      go: |
        package main

        import "github.com/evanw/esbuild/pkg/api"
        import "os"

        func main() {
          result := api.Build(api.BuildOptions{
            EntryPoints: []string{"app.jsx"},
            JSXDev:      true,
            JSX:         api.JSXAutomatic,
            Outfile:     "out.js",
          })

          if len(result.Errors) > 0 {
            os.Exit(1)
          }
        }

  - h3: JSX factory

  - p: >
      This sets the function that is called for each JSX element. Normally a
      JSX expression such as this:

  - pre.xml: |
      <div>Example text</div>

  - p: >
      is compiled into a function call to `React.createElement` like this:

  - pre.js: |
      React.createElement("div", null, "Example text");

  - p: >
      You can call something other than `React.createElement` by changing the
      JSX factory. For example, to call the function `h` instead (which is
      used by other libraries such as [Preact](https://preactjs.com/)):

  - example:
      cli:
        - $: |
            echo '<div/>' | esbuild --jsx-factory=h --loader=jsx
        - expect: |
            /* @__PURE__ */ h("div", null);

      mjs: |
        import * as esbuild from 'esbuild'

        let result = await esbuild.transform('<div/>', {
          jsxFactory: 'h',
          loader: 'jsx',
        })

        console.log(result.code)

      go: |
        package main

        import "fmt"
        import "github.com/evanw/esbuild/pkg/api"

        func main() {
          result := api.Transform("<div/>", api.TransformOptions{
            JSXFactory: "h",
            Loader:     api.LoaderJSX,
          })

          if len(result.Errors) == 0 {
            fmt.Printf("%s", result.Code)
          }
        }

  - p: >
      Alternatively, if you are using TypeScript, you can just configure JSX
      for TypeScript by adding this to your `tsconfig.json` file and esbuild
      should pick it up automatically without needing to be configured:

  - pre.json: |
      {
        "compilerOptions": {
          "jsxFactory": "h"
        }
      }

  - p: >
      If you want to configure this on a per-file basis, you can do that by
      using a <code>// @jsx <wbr>h</code> comment. Note that this setting
      does not apply when the [JSX](#jsx) transform has been set to `automatic`.

  - h3: JSX fragment

  - p: >
      This sets the function that is called for each JSX fragment. Normally a
      JSX fragment expression such as this:

  - pre.xml: |
      <>Stuff</>

  - p: >
      is compiled into a use of the `React.Fragment` component like this:

  - pre.js: |
      React.createElement(React.Fragment, null, "Stuff");

  - p: >
      You can use a component other than `React.Fragment` by changing the
      JSX fragment. For example, to use the component `Fragment` instead
      (which is used by other libraries such as [Preact](https://preactjs.com/)):

  - example:
      cli:
        - $: |
            echo '<>x</>' | esbuild --jsx-fragment=Fragment --loader=jsx
        - expect: |
            /* @__PURE__ */ React.createElement(Fragment, null, "x");

      mjs: |
        import * as esbuild from 'esbuild'

        let result = await esbuild.transform('<>x</>', {
          jsxFragment: 'Fragment',
          loader: 'jsx',
        })

        console.log(result.code)

      go: |
        package main

        import "fmt"
        import "github.com/evanw/esbuild/pkg/api"

        func main() {
          result := api.Transform("<>x</>", api.TransformOptions{
            JSXFragment: "Fragment",
            Loader:      api.LoaderJSX,
          })

          if len(result.Errors) == 0 {
            fmt.Printf("%s", result.Code)
          }
        }

  - p: >
      Alternatively, if you are using TypeScript, you can just configure JSX
      for TypeScript by adding this to your `tsconfig.json` file and esbuild
      should pick it up automatically without needing to be configured:

  - pre.json: |
      {
        "compilerOptions": {
          "jsxFragmentFactory": "Fragment"
        }
      }

  - p: >
      If you want to configure this on a per-file basis, you can do that by
      using a <code>// @jsxFrag <wbr>Fragment</code> comment. Note that this
      setting does not apply when the [JSX](#jsx) transform has been set to
      `automatic`.

  - h3: JSX import source

  - p: >
      If the [JSX](#jsx) transform has been set to `automatic`, then setting
      this lets you change which library esbuild uses to automatically import
      its JSX helper functions from. Note that this only works with the JSX
      transform that's [specific to React 17+](https://reactjs.org/blog/2020/09/22/introducing-the-new-jsx-transform.html).
      If you set the JSX import source to `your-pkg`, then that package must
      expose at least the following exports:

  - pre.js: |
      import { createElement } from "your-pkg"
      import { Fragment, jsx, jsxs } from "your-pkg/jsx-runtime"
      import { Fragment, jsxDEV } from "your-pkg/jsx-dev-runtime"

  - p: >
      The `/jsx-runtime` and `/jsx-dev-runtime` subpaths are hard-coded by
      design and cannot be changed. The `jsx` and `jsxs` imports are used when
      [JSX dev mode](#jsx-dev) is off and the `jsxDEV` import is used when
      JSX dev mode is on. The meaning of these is described in
      [React's documentation about their new JSX transform](https://github.com/reactjs/rfcs/blob/createlement-rfc/text/0000-create-element-changes.md).
      The `createElement` import is used regardless of the JSX dev mode when an
      element has a prop spread followed by a `key` prop, which looks like this:

  - pre.jsx: |
      return <div {...props} key={key} />

  - p: >
      Here's an example of setting the JSX import source to [`preact`](https://preactjs.com/):

  - example:
      in:
        app.jsx: '<a/>'

      cli: |
        esbuild app.jsx --jsx-import-source=preact --jsx=automatic

      mjs: |
        import * as esbuild from 'esbuild'

        await esbuild.build({
          entryPoints: ['app.jsx'],
          jsxImportSource: 'preact',
          jsx: 'automatic',
          outfile: 'out.js',
        })

      go: |
        package main

        import "github.com/evanw/esbuild/pkg/api"
        import "os"

        func main() {
          result := api.Build(api.BuildOptions{
            EntryPoints:     []string{"app.jsx"},
            JSXImportSource: "preact",
            JSX:             api.JSXAutomatic,
            Outfile:         "out.js",
          })

          if len(result.Errors) > 0 {
            os.Exit(1)
          }
        }

  - p: >
      Alternatively, if you are using TypeScript, you can just configure the
      JSX import source for TypeScript by adding this to your `tsconfig.json`
      file and esbuild should pick it up automatically without needing to be
      configured:

  - pre.json: |
      {
        "compilerOptions": {
          "jsx": "react-jsx",
          "jsxImportSource": "preact"
        }
      }

  - p: >
      And if you want to control this setting on the per-file basis, you can do
      that with a <code>// @jsxImportSource <wbr>your-pkg</code> comment in each
      file. You may also need to add a <code>// @jsxRuntime <wbr>automatic</code>
      comment as well if the [JSX](#jsx) transform has not already been set by
      other means, or if you want that to be set on a per-file basis as well.

  - h3: JSX side effects

  - p: >
      By default esbuild assumes that JSX expressions are side-effect free,
      which means they are annoated with [`/* @__PURE__ */` comments](#pure) and
      are removed during bundling when they are unused. This follows the common
      use of JSX for virtual DOM and applies to the vast majority of JSX libraries.
      However, some people have written JSX libraries that don't have this property
      (specifically JSX expressions can have arbitrary side effects and can't be
      removed when unused). If you are using such a library, you can use this
      setting to tell esbuild that JSX expressions have side effects:

  - example:
      in:
        app.jsx: '<a/>'

      cli: |
        esbuild app.jsx --jsx-side-effects

      mjs: |
        import * as esbuild from 'esbuild'

        await esbuild.build({
          entryPoints: ['app.jsx'],
          outfile: 'out.js',
          jsxSideEffects: true,
        })

      go: |
        package main

        import "github.com/evanw/esbuild/pkg/api"
        import "os"

        func main() {
          result := api.Build(api.BuildOptions{
            EntryPoints:    []string{"app.jsx"},
            Outfile:        "out.js",
            JSXSideEffects: true,
          })

          if len(result.Errors) > 0 {
            os.Exit(1)
          }
        }

  - h3: Supported

  - p: >
      This setting lets you customize esbuild's set of unsupported syntax
      features at the individual syntax feature level. For example, you can use
      this to tell esbuild that [BigInts](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/BigInt)
      are not supported so that esbuild generates an error when you try to use
      one. Usually this is configured for you when you use the [`target`](#target)
      setting, which you should typically be using instead of this setting.
      If the target is specified in addition to this setting, this setting will
      override whatever is specified by the target.

  - p: >
      Here are some examples of why you might want to use this setting instead
      of or in addition to setting the target:

  - ul:
    - >
      <p>
      JavaScript runtimes often do a quick implementation of newer syntax
      features that is slower than the equivalent older JavaScript, and you
      can get a speedup by telling esbuild to pretend this syntax feature isn't
      supported. For example, [V8](https://v8.dev/) has a [long-standing performance bug regarding object spread](https://bugs.chromium.org/p/v8/issues/detail?id=11536)
      that can be avoided by manually copying properties instead of using
      object spread syntax.
      </p>

    - >
      <p>
      There are many other JavaScript implementations in addition to the ones
      that esbuild's `target` setting recognizes, and they may not support certain
      features. If you are targeting such an implementation, you can use this setting
      to configure esbuild with a custom syntax feature compatibility set without
      needing to change esbuild itself. For example, [TypeScript's](https://www.typescriptlang.org/) JavaScript
      parser may not support [arbitrary module namespace identifier names](https://github.com/microsoft/TypeScript/issues/40594)
      so you may want to turn those off when targeting TypeScript's JavaScript
      parser.
      </p>

    - >
      <p>
      You may be processing esbuild's output with another tool, and you may want
      esbuild to transform certain features and the other tool to transform
      certain other features. For example, if you are using esbuild to transform
      files individually to ES5 but you are then feeding the output into [Webpack](https://webpack.js.org/)
      for bundling, you may want to preserve `import()` expressions even though
      they are a syntax error in ES5.
      </p>

  - p: >
      If you want esbuild to consider a certain syntax feature to be unsupported,
      you can specify that like this:

  - example:
      in:
        app.js: ''

      cli: |
        esbuild app.js --supported:bigint=false

      mjs: |
        import * as esbuild from 'esbuild'

        await esbuild.build({
          entryPoints: ['app.js'],
          supported: {
            'bigint': false,
          },
        })

      go: |
        package main

        import "github.com/evanw/esbuild/pkg/api"
        import "os"

        func main() {
          result := api.Build(api.BuildOptions{
            EntryPoints: []string{"app.js"},
            Supported: map[string]bool{
              "bigint": false,
            },
          })

          if len(result.Errors) > 0 {
            os.Exit(1)
          }
        }

  - p: >
      Syntax features are specified using esbuild-specific feature names. The
      full set of feature names is as follows:

      <p>**JavaScript:**</p>
      <ul>
      <li>`arbitrary-module-namespace-names`</li>
      <li>`array-spread`</li>
      <li>`arrow`</li>
      <li>`async-await`</li>
      <li>`async-generator`</li>
      <li>`bigint`</li>
      <li>`class-field`</li>
      <li>`class-private-accessor`</li>
      <li>`class-private-brand-check`</li>
      <li>`class-private-field`</li>
      <li>`class-private-method`</li>
      <li>`class-private-static-accessor`</li>
      <li>`class-private-static-field`</li>
      <li>`class-private-static-method`</li>
      <li>`class-static-blocks`</li>
      <li>`class-static-field`</li>
      <li>`class`</li>
      <li>`const-and-let`</li>
      <li>`default-argument`</li>
      <li>`destructuring`</li>
      <li>`dynamic-import`</li>
      <li>`exponent-operator`</li>
      <li>`export-star-as`</li>
      <li>`for-await`</li>
      <li>`for-of`</li>
      <li>`generator`</li>
      <li>`hashbang`</li>
      <li>`import-assertions`</li>
      <li>`import-meta`</li>
      <li>`inline-script`</li>
      <li>`logical-assignment`</li>
      <li>`nested-rest-binding`</li>
      <li>`new-target`</li>
      <li>`node-colon-prefix-import`</li>
      <li>`node-colon-prefix-require`</li>
      <li>`nullish-coalescing`</li>
      <li>`object-accessors`</li>
      <li>`object-extensions`</li>
      <li>`object-rest-spread`</li>
      <li>`optional-catch-binding`</li>
      <li>`optional-chain`</li>
      <li>`regexp-dot-all-flag`</li>
      <li>`regexp-lookbehind-assertions`</li>
      <li>`regexp-match-indices`</li>
      <li>`regexp-named-capture-groups`</li>
      <li>`regexp-sticky-and-unicode-flags`</li>
      <li>`regexp-unicode-property-escapes`</li>
      <li>`rest-argument`</li>
      <li>`template-literal`</li>
      <li>`top-level-await`</li>
      <li>`typeof-exotic-object-is-object`</li>
      <li>`unicode-escapes`</li>
      </ul>

      <p>**CSS:**</p>
      <ul>
      <li>`hex-rgba`</li>
      <li>`inline-style`</li>
      <li>`inset-property`</li>
      <li>`modern-rgb-hsl`</li>
      <li>`nesting`</li>
      <li>`rebecca-purple`</li>
      </ul>

  - h3: Target

  - p: >
      This sets the target environment for the generated JavaScript and/or CSS
      code. It tells esbuild to transform JavaScript syntax that is too new for
      these environments into older JavaScript syntax that will work in these
      environments. For example, the `??` operator was introduced in Chrome 80
      so esbuild will convert it into an equivalent (but more verbose)
      conditional expression when targeting Chrome 79 or earlier.

  - p: >
      Note that this is only concerned with syntax features, not APIs. It does
      *not* automatically add [polyfills](https://developer.mozilla.org/en-US/docs/Glossary/Polyfill)
      for new APIs that are not used by these environments. You will have to
      explicitly import polyfills for the APIs you need (e.g. by importing
      [`core-js`](https://www.npmjs.com/package/core-js)). Automatic polyfill
      injection is outside of esbuild's scope.

  - p: >
      Each target environment is an environment name followed by a version
      number. The following environment names are currently supported:

  - ul:
    - '`chrome`'
    - '`deno`'
    - '`edge`'
    - '`firefox`'
    - '`hermes`'
    - '`ie`'
    - '`ios`'
    - '`node`'
    - '`opera`'
    - '`rhino`'
    - '`safari`'

  - p: >
      In addition, you can also specify JavaScript language versions such as
      `es2020`. The default target is `esnext` which means that by default,
      esbuild will assume all of the latest JavaScript and CSS features are
      supported. Here is an example that configures multiple target environments.
      You don't need to specify all of them; you can just specify the subset
      of target environments that your project cares about. You can also be more
      precise about version numbers if you'd like (e.g. `node12.19.0` instead of
      just `node12`):

  - example:
      in:
        app.js: '1 + 2'

      cli: |
        esbuild app.js --target=es2020,chrome58,edge16,firefox57,node12,safari11

      mjs: |
        import * as esbuild from 'esbuild'

        await esbuild.build({
          entryPoints: ['app.js'],
          target: [
            'es2020',
            'chrome58',
            'edge16',
            'firefox57',
            'node12',
            'safari11',
          ],
          outfile: 'out.js',
        })

      go: |
        package main

        import "github.com/evanw/esbuild/pkg/api"
        import "os"

        func main() {
          result := api.Build(api.BuildOptions{
            EntryPoints: []string{"app.js"},
            Target:      api.ES2020,
            Engines: []api.Engine{
              {Name: api.EngineChrome, Version: "58"},
              {Name: api.EngineEdge, Version: "16"},
              {Name: api.EngineFirefox, Version: "57"},
              {Name: api.EngineNode, Version: "12"},
              {Name: api.EngineSafari, Version: "11"},
            },
            Write: true,
          })

          if len(result.Errors) > 0 {
            os.Exit(1)
          }
        }

  - p: >
      You can refer to the [JavaScript loader](/content-types/#javascript) for
      the details about which syntax features were introduced with which language
      versions. Keep in mind that while JavaScript language versions such as
      `es2020` are identified by year, that is the year the specification is
      approved. It has nothing to do with the year all major browsers implement
      that specification which often happens earlier or later than that year.

  - p: >
      If you use a syntax feature that esbuild doesn't yet have support for
      transforming to your current language target, esbuild will generate an
      error where the unsupported syntax is used. This is often the case when
      targeting the `es5` language version, for example, since esbuild only
      supports transforming most newer JavaScript syntax features to `es6`.

  - p: >
      If you need to customize the set of supported syntax features at the
      individual feature level in addition to or instead of what `target`
      provides, you can do that with the [`supported`](#supported) setting.

  - h2: Optimization

  - h3: Define

  - p: >
      This feature provides a way to replace global identifiers with
      constant expressions. It can be a way to change the behavior some code
      between builds without changing the code itself:

  - example:
      cli:
        - $: |
            echo 'hooks = DEBUG && require("hooks")' | esbuild --define:DEBUG=true
        - expect: |
            hooks = require("hooks");

        - $: |
            echo 'hooks = DEBUG && require("hooks")' | esbuild --define:DEBUG=false
        - expect: |
            hooks = false;

      mjs:
        - $: import * as esbuild from 'esbuild'
        - $: let js = 'hooks = DEBUG && require("hooks")'

        - $: |
            (await esbuild.transform(js, {
              define: { DEBUG: 'true' },
            })).code
        - expect: |
            'hooks = require("hooks");\n'

        - $: |
            (await esbuild.transform(js, {
              define: { DEBUG: 'false' },
            })).code
        - expect: |
            'hooks = false;\n'

      go: |
        package main

        import "fmt"
        import "github.com/evanw/esbuild/pkg/api"

        func main() {
          js := "hooks = DEBUG && require('hooks')"

          result1 := api.Transform(js, api.TransformOptions{
            Define: map[string]string{"DEBUG": "true"},
          })

          if len(result1.Errors) == 0 {
            fmt.Printf("%s", result1.Code)
          }

          result2 := api.Transform(js, api.TransformOptions{
            Define: map[string]string{"DEBUG": "false"},
          })

          if len(result2.Errors) == 0 {
            fmt.Printf("%s", result2.Code)
          }
        }

  - p: >
      Replacement expressions must either be a JSON object (null, boolean,
      number, string, array, or object) or a single identifier. Replacement
      expressions other than arrays and objects are substituted inline, which
      means that they can participate in constant folding. Array and object
      replacement expressions are stored in a variable and then referenced
      using an identifier instead of being substituted inline, which avoids
      substituting repeated copies of the value but means that the values don't
      participate in constant folding.

  - p: >
      If you want to replace something with a string literal, keep in mind that
      the replacement value passed to esbuild must itself contain quotes.
      Omitting the quotes means the replacement value is an identifier instead:

  - example:
      cli:
        - $: |
            echo 'id, str' | esbuild --define:id=text --define:str=\"text\"
        - expect: |
            text, "text";

      mjs:
        - $: import * as esbuild from 'esbuild'
        - $: |
            (await esbuild.transform('id, str', {
              define: { id: 'text', str: '"text"' },
            })).code
        - expect: |
            'text, "text";\n'

      go: |
        package main

        import "fmt"
        import "github.com/evanw/esbuild/pkg/api"

        func main() {
          result := api.Transform("id, text", api.TransformOptions{
            Define: map[string]string{
              "id":  "text",
              "str": "\"text\"",
            },
          })

          if len(result.Errors) == 0 {
            fmt.Printf("%s", result.Code)
          }
        }

  - p: >
      If you're using the CLI, keep in mind that different shells have different
      rules for how to escape double-quote characters (which are necessary when
      the replacement value is a string). Use a `\"` backslash escape because it
      works in both bash and Windows command prompt. Other methods of escaping
      double quotes that work in bash such as surrounding them with single
      quotes will not work on Windows, since Windows command prompt does not
      remove the single quotes. This is relevant when using the CLI from a npm
      script in your `package.json` file, which people will expect to work on
      all platforms:

  - pre.json: |
      {
        "scripts": {
          "build": "esbuild --define:process.env.NODE_ENV=\\\"production\\\" app.js"
        }
      }

  - p: >
      If you still run into cross-platform quote escaping issues with different
      shells, you will probably want to switch to using the [JavaScript API](/api/)
      instead. There you can use regular JavaScript syntax to eliminate
      cross-platform differences.

  - h3: Drop

  - p: >
      This tells esbuild to edit your source code before building to drop
      certain constructs. There are currently two possible things that can be
      dropped:

  - ul:
    - >
      `debugger`
      <p>
      Passing this flag causes all [`debugger` statements](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/debugger)
      to be removed from the output. This is similar to the `drop_debugger: true`
      flag available in the popular [UglifyJS](https://github.com/mishoo/UglifyJS)
      and [Terser](https://github.com/terser/terser) JavaScript minifiers.
      </p>
      <p>
      JavaScript's `debugger` statements cause the active debugger to treat the
      statement as an automatically-configured breakpoint. Code containing this
      statement will automatically be paused when the debugger is open. If no
      debugger is open, the statement does nothing. Dropping these statements
      from your code just prevents the debugger from automatically stopping
      when your code runs.
      </p>
      <p>
      You can drop `debugger` statements like this:
      </p>

  - example:
      in:
        app.js: 'debugger'

      cli: |
        esbuild app.js --drop:debugger

      mjs: |
        import * as esbuild from 'esbuild'

        await esbuild.build({
          entryPoints: ['app.js'],
          drop: ['debugger'],
        })

      go: |
        package main

        import "github.com/evanw/esbuild/pkg/api"
        import "os"

        func main() {
          result := api.Build(api.BuildOptions{
            EntryPoints: []string{"app.js"},
            Drop:        api.DropDebugger,
          })

          if len(result.Errors) > 0 {
            os.Exit(1)
          }
        }

  - ul:
    - >
      `console`
      <p>
      Passing this flag causes all [`console` API calls](https://developer.mozilla.org/en-US/docs/Web/API/console#methods)
      to be removed from the output. This is similar to the `drop_console: true`
      flag available in the popular [UglifyJS](https://github.com/mishoo/UglifyJS)
      and [Terser](https://github.com/terser/terser) JavaScript minifiers.
      </p>
      <p>
      WARNING: Using this flag can introduce bugs into your code! This flag
      removes the entire call expression including all call arguments. If any
      of those arguments had important side effects, using this flag will
      change the behavior of your code. Be very careful when using this flag.
      </p>
      <p>
      If you want to remove console API calls without removing the arguments
      with side effects (so you do not introduce bugs), you should mark the
      relevant API calls as [pure](#pure) instead. For example, you can mark
      `console.log` as pure using <code>--pure:<wbr>console.log</code>. This
      will cause these API calls to be removed safely when minification is
      enabled.
      </p>
      <p>
      You can drop `console` API calls like this:
      </p>

  - example:
      in:
        app.js: 'console.log()'

      cli: |
        esbuild app.js --drop:console

      mjs: |
        import * as esbuild from 'esbuild'

        await esbuild.build({
          entryPoints: ['app.js'],
          drop: ['console'],
        })

      go: |
        package main

        import "github.com/evanw/esbuild/pkg/api"
        import "os"

        func main() {
          result := api.Build(api.BuildOptions{
            EntryPoints: []string{"app.js"},
            Drop:        api.DropConsole,
          })

          if len(result.Errors) > 0 {
            os.Exit(1)
          }
        }

  - h3: Ignore annotations

  - p: >
      Since JavaScript is a dynamic language, identifying unused code is
      sometimes very difficult for a compiler, so the community has developed
      certain annotations to help tell compilers what code should be considered
      side-effect free and available for removal. Currently there are two forms
      of side-effect annotations that esbuild supports:

  - ul:
    - >
      <p>
      Inline `/* @__PURE__ */` comments before function calls tell esbuild that
      the function call can be removed if the resulting value isn't used. See
      the [pure](#pure) API option for more information.
      </p>

    - >
      <p>
      The `sideEffects` field in `package.json` can be used to tell esbuild
      which files in your package can be removed if all imports from that
      file end up being unused. This is a convention from Webpack and many
      libraries published to npm already have this field in their package
      definition. You can learn more about this field in
      [Webpack's documentation](https://webpack.js.org/guides/tree-shaking/)
      for this field.
      </p>

  - p: >
      These annotations can be problematic because the compiler depends
      completely on developers for accuracy, and developers occasionally
      publish packages with incorrect annotations. The `sideEffects` field is
      particularly error-prone for developers because by default it causes all
      files in your package to be considered dead code if no imports are used.
      If you add a new file containing side effects and forget to update that
      field, your package will likely break when people try to bundle it.

  - p: >
      This is why esbuild includes a way to ignore side-effect annotations.
      You should only enable this if you encounter a problem where the bundle
      is broken because necessary code was unexpectedly removed from the bundle:

  - example:
      in:
        app.js: '1 + 2'

      cli: |
          esbuild app.js --bundle --ignore-annotations

      mjs: |
        import * as esbuild from 'esbuild'

        await esbuild.build({
          entryPoints: ['app.js'],
          bundle: true,
          ignoreAnnotations: true,
          outfile: 'out.js',
        })

      go: |
        package main

        import "github.com/evanw/esbuild/pkg/api"
        import "os"

        func main() {
          result := api.Build(api.BuildOptions{
            EntryPoints:       []string{"app.js"},
            Bundle:            true,
            IgnoreAnnotations: true,
          })

          if len(result.Errors) > 0 {
            os.Exit(1)
          }
        }

  - p: >
      Enabling this means esbuild will no longer respect `/* @__PURE__ */`
      comments or the `sideEffects` field. It will still do automatic
      [tree shaking](#tree-shaking) of unused imports, however, since that doesn't rely on
      annotations from developers. Ideally this flag is only a temporary
      workaround. You should report these issues to the maintainer of the
      package to get them fixed since they indicate a problem with the package
      and they will likely trip up other people too.

  - h3: Inject

  - p: >
      这个配置项可以自动替换从另一个文件引入的全局变量。
      当你为无法控制的代码适配新环境时是非常有用的。
      例如，假定你有一个叫做 `process-shim.js` 的文件，该文件导出了 `process` 变量：

  - pre.js: |
      // process-shim.js
      export let process = {
        cwd: () => ''
      }

  - pre.js: |
      // entry.js
      console.log(process.cwd())

  - p: >
      这尝试替换 node 的 `process.cwd()` 函数的使用，以阻止包在浏览器中运行它而导致崩溃。
      你可以使用 inject 特性将一个 import 置于文件中以替换所有的全局标识符 `process`。

  - example:
      in:
        process-shim.js: 'export let process = { cwd: () => "" }'
        entry.js: "console.log(process.cwd())"

      cli: |
        esbuild entry.js --bundle --inject:./process-shim.js --outfile=out.js

      mjs: |
        import * as esbuild from 'esbuild'

        await esbuild.build({
          entryPoints: ['entry.js'],
          bundle: true,
          inject: ['./process-shim.js'],
          outfile: 'out.js',
        })

      go: |
        package main

        import "github.com/evanw/esbuild/pkg/api"
        import "os"

        func main() {
          result := api.Build(api.BuildOptions{
            EntryPoints: []string{"entry.js"},
            Bundle:      true,
            Inject:      []string{"./process-shim.js"},
            Outfile:     "out.js",
            Write:       true,
          })

          if len(result.Errors) > 0 {
            os.Exit(1)
          }
        }

  - p: >
      结果是这样的：

  - pre.js: |
      // out.js
      let process = {cwd: () => ""};
      console.log(process.cwd());

  - h4: inject 与 [define](#define) 一起使用

  - p: >
      你可以与 [define](#define) 特性结合使用，这样你的导入会更具可选择性。例如：

  - pre.js: |
      // process-shim.js
      export function dummy_process_cwd() {
        return ''
      }

  - pre.js: |
      // entry.js
      console.log(process.cwd())

  - p: >
      You can map `process.cwd` to `dummy_process_cwd` with the [define](#define)
      feature, then inject `dummy_process_cwd` from `process-shim.js` with the
      inject feature:

  - example:
      in:
        process-shim.js: 'export function dummy_process_cwd() { return "" }'
        entry.js: "console.log(process.cwd())"

      cli: |
        esbuild entry.js --bundle --define:process.cwd=dummy_process_cwd --inject:./process-shim.js --outfile=out.js

      mjs: |
        import * as esbuild from 'esbuild'

        await esbuild.build({
          entryPoints: ['entry.js'],
          bundle: true,
          define: { 'process.cwd': 'dummy_process_cwd' },
          inject: ['./process-shim.js'],
          outfile: 'out.js',
        })

      go: |
        package main

        import "github.com/evanw/esbuild/pkg/api"
        import "os"

        func main() {
          result := api.Build(api.BuildOptions{
            EntryPoints: []string{"entry.js"},
            Bundle:      true,
            Define: map[string]string{
              "process.cwd": "dummy_process_cwd",
            },
            Inject:  []string{"./process-shim.js"},
            Outfile: "out.js",
            Write:   true,
          })

          if len(result.Errors) > 0 {
            os.Exit(1)
          }
        }

  - p: >
      结果如下：

  - pre.js: |
      // out.js
      function dummy_process_cwd() {
        return "";
      }
      console.log(dummy_process_cwd());

  - h4: 自动导入 [JSX](/content-types/#jsx)

  - p: >
      你可以使用 inject 特性以自动提供 JSX 表达式的执行环境。例如，你可以自动导入 `react`
      包以执行诸如 `React.createElement` 的函数。查看
      [JSX 文档](/content-types/#auto-import-for-jsx) 获取更多。

  - h4: 不使用 import 注入文件

  - p: >
      你可以对不包含 exports 的文件使用该特性。在这种情况下，注入的文件就像每个输入文件都包含
      <code>import <wbr>"./file.js"</code> 一样出现在输出的前面。
      由于 ECMAScript 模块的工作方式，这个注入仍然是 “卫生的”，因为在不同文件中具有相同名称的符号会被重命名，
      这样它们就不会相互冲突。

  - h4: 选择性注入文件

  - p: >
      如果你仅想当导出被实际使用的情况下 _有条件_ 的引入一个文件，你应该通过将其置于 package 中并且
      在 `package.json` 中添加 <code>"sideEffects": <wbr>false</code> 以标记被注入的文件没有副作用。
      该设置为
      [Webpack 公约](https://webpack.js.org/guides/tree-shaking/#mark-the-file-as-side-effect-free)，
      esbuild 中该公约对所有的导入文件生效，而不仅仅是注入文件。

  - h3: Keep names

  - p: >
<<<<<<< HEAD
      该配置项改变了输入文件解析的方式。例如， [`js`](/content-types/#javascript) loader 将文件解析为 JavaScript，
      [`css`](/content-types/#css) loader 将文件解析为 CSS。查看 [content types](/content-types/) 获取内置
      loader 的完整列表。

  - p: >
      配置一个给定文件类型的 loader 可以让你使用 `import` 声明或者 `require` 调用来加载该文件类型。
      例如，使用 [data URL](/content-types/#data-url) loader 配置 `.png` 文件拓展名，
      这意味着导入 `.png` 文件会给你一个包含该图像内容的数据 URL：
=======
      In JavaScript the `name` property on functions and classes defaults to a
      nearby identifier in the source code. These syntax forms all set the `name`
      property of the function to `"fn"`:
>>>>>>> 64a7cbf09ed21d61e6fe85529b31e5676fa14bfe

  - pre.js: |
      function fn() {}
      let fn = function() {};
      fn = function() {};
      let [fn = function() {}] = [];
      let {fn = function() {}} = {};
      [fn = function() {}] = [];
      ({fn = function() {}} = {});

  - p: >
<<<<<<< HEAD
      以上代码可以使用 [build API](#build-api) 调用进行打包，就像这样：
=======
      However, [minification](#minify) renames symbols to reduce code size and
      [bundling](#bundle) sometimes need to rename symbols to avoid collisions.
      That changes value of the `name` property for many of these cases. This
      is usually fine because the `name` property is normally only used for
      debugging. However, some frameworks rely on the `name` property for
      registration and binding purposes. If this is the case, you can enable
      this option to preserve the original `name` values even in minified code:
>>>>>>> 64a7cbf09ed21d61e6fe85529b31e5676fa14bfe

  - example:
      in:
        app.js: '1 + 2'

      cli: |
        esbuild app.js --minify --keep-names

      mjs: |
        import * as esbuild from 'esbuild'

        await esbuild.build({
          entryPoints: ['app.js'],
          minify: true,
          keepNames: true,
          outfile: 'out.js',
        })

      go: |
        package main

        import "github.com/evanw/esbuild/pkg/api"
        import "os"

        func main() {
          result := api.Build(api.BuildOptions{
            EntryPoints:       []string{"app.js"},
            MinifyWhitespace:  true,
            MinifyIdentifiers: true,
            MinifySyntax:      true,
            KeepNames:         true,
          })

          if len(result.Errors) > 0 {
            os.Exit(1)
          }
        }

  - h3: Mangle props

  - warning: >
      **Using this feature can break your code in subtle ways.** Do not use this
      feature unless you know what you are doing, and you know exactly how it
      will affect both your code and all of your dependencies.

  - p: >
      This setting lets you pass a regular expression to esbuild to tell
      esbuild to automatically rename all properties that match this regular
      expression. It's useful when you want to minify certain property names
      in your code either to make the generated code smaller or to somewhat
      obfuscate your code's intent.

  - p: >
      Here's an example that uses the regular expression `_$` to mangle all
      properties ending in an underscore, such as `foo_`. This mangles
      <code>print({ <wbr>foo_: 0 <wbr>}.foo_)</code>
      into <code>print({ <wbr>a: 0 <wbr>}.a)</code>:

  - example:
      in:
        app.js: '1 + 2'

      cli: |
        esbuild app.js --mangle-props=_$

      mjs: |
        import * as esbuild from 'esbuild'

        await esbuild.build({
          entryPoints: ['app.js'],
          mangleProps: /_$/,
        })

      go: |
        package main

        import "github.com/evanw/esbuild/pkg/api"
        import "os"

        func main() {
          result := api.Build(api.BuildOptions{
            EntryPoints: []string{"app.js"},
            MangleProps: "_$",
          })

          if len(result.Errors) > 0 {
            os.Exit(1)
          }
        }

  - p: >
<<<<<<< HEAD
      如果你在 [标准化输入（stdin）](#stdin) 中使用 build API，该配置项就会变的不同，
      因为标准化输入（stdin）没有文件拓展名。使用 build API 为标准化输入（stdin）配置一个 loader，
      就像这样：
=======
      Only mangling properties that end in an underscore is a reasonable
      heuristic because normal JS code doesn't typically contain identifiers
      like that. Browser APIs also don't use this naming convention so this
      also avoids conflicts with browser APIs. If you want to avoid mangling
      names such as [`__defineGetter__`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/__defineGetter__)
      you could consider using a more complex regular expression such as
      `[^_]_$` (i.e. must end in a non-underscore followed by an underscore).

  - p: >
      This is a separate setting instead of being part of the [minify](#minify)
      setting because it's an unsafe transformation that does not work on
      arbitrary JavaScript code. It only works if the provided regular
      expression matches all of the properties that you want mangled and does
      not match any of the properties that you don't want mangled. It also only
      works if you do not under any circumstances reference a mangled property
      indirectly. For example, it means you can't use `obj[prop]` to reference a
      property where `prop` is a string containing the property name. Specifically
      the following syntax constructs are the only ones eligible for property mangling:

  - table: |
      | Syntax                           | Example                                   |
      |----------------------------------|-------------------------------------------|
      | Dot property accesses            | `x.foo_`                                  |
      | Dot optional chains              | `x?.foo_`                                 |
      | Object properties                | `x = { foo_: y }`                         |
      | Object methods                   | `x = { foo_() {} }`                       |
      | Class fields                     | `class x { foo_ = y }`                    |
      | Class methods                    | `class x { foo_() {} }`                   |
      | Object destructuring bindings    | `let { foo_: x } = y`                     |
      | Object destructuring assignments | `({ foo_: x } = y)`                       |
      | JSX element member expression    | `<X.foo_></X.foo_>`                       |
      | JSX attribute names              | `<X foo_={y} />`                          |
      | TypeScript namespace exports     | `namespace x { export let foo_ = y }`     |
      | TypeScript parameter properties  | `class x { constructor(public foo_) {} }` |

  - p: >
      When using this feature, keep in mind that property names are only
      consistently mangled within a single esbuild API call but not across
      esbuild API calls. Each esbuild API call does an independent property
      mangling operation so output files generated by two different API calls
      may mangle the same property to two different names, which could cause
      the resulting code to behave incorrectly.

  - h4#mangle-quoted: >
      Quoted properties

  - p: >
      By default, esbuild doesn't modify the contents of string literals. This means
      you can avoid property mangling for an individual property by quoting it
      as a string. However, you must consistently use quotes or no quotes for
      a given property everywhere for this to work. For example,
      <code>print({ <wbr>foo_: 0 <wbr>}.foo_)</code> will be mangled into
      <code>print({ <wbr>a: 0 <wbr>}.a)</code> while
      <code>print({ <wbr>'foo_': 0 <wbr>}['foo_'])</code> will not be mangled.

  - p: >
      If you would like for esbuild to also mangle the contents of string literals,
      you can explicitly enable that behavior like this:
>>>>>>> 64a7cbf09ed21d61e6fe85529b31e5676fa14bfe

  - example:
      in:
        app.js: '1 + 2'

      cli: |
        esbuild app.js --mangle-props=_$ --mangle-quoted

      mjs: |
        import * as esbuild from 'esbuild'

        await esbuild.build({
          entryPoints: ['app.js'],
          mangleProps: /_$/,
          mangleQuoted: true,
        })

      go: |
        package main

        import "github.com/evanw/esbuild/pkg/api"
        import "os"

        func main() {
          result := api.Build(api.BuildOptions{
            EntryPoints:  []string{"app.js"},
            MangleProps:  "_$",
            MangleQuoted: api.MangleQuotedTrue,
          })

          if len(result.Errors) > 0 {
            os.Exit(1)
          }
        }

  - p: >
<<<<<<< HEAD
      [transform API](#transform-api) 调用仅使用一个 loader，因为它不涉及与文件系统的交互，
      因此不需要处理文件拓展名。为 transform API 配置一个 loader（在这里是
      [`ts`](/content-types/#typescript) loader），就像这样：
=======
      Enabling this makes the following syntax constructs also eligible for property
      mangling:

  - table: |
      | Syntax                                  | Example                   |
      |-----------------------------------------|---------------------------|
      | Quoted property accesses                | `x['foo_']`               |
      | Quoted optional chains                  | `x?.['foo_']`             |
      | Quoted object properties                | `x = { 'foo_': y }`       |
      | Quoted object methods                   | `x = { 'foo_'() {} }`     |
      | Quoted class fields                     | `class x { 'foo_' = y }`  |
      | Quoted class methods                    | `class x { 'foo_'() {} }` |
      | Quoted object destructuring bindings    | `let { 'foo_': x } = y`   |
      | Quoted object destructuring assignments | `({ 'foo_': x } = y)`     |
      | String literals to the left of `in`     | `'foo_' in x`             |

  - h4#reserve-props: >
      Preventing renaming

  - p: >
      If you would like to exclude certain properties from mangling, you can
      reserve them with an additional setting. For example, this uses the
      regular expression `^__.*__$` to reserve all properties that start and
      end with two underscores, such as `__foo__`:
>>>>>>> 64a7cbf09ed21d61e6fe85529b31e5676fa14bfe

  - example:
      in:
        app.js: '1 + 2'

      cli: |
        esbuild app.js --mangle-props=_$ "--reserve-props=^__.*__$"

      mjs: |
        import * as esbuild from 'esbuild'

        await esbuild.build({
          entryPoints: ['app.js'],
          mangleProps: /_$/,
          reserveProps: /^__.*__$/,
        })

      go: |
        package main

        import "github.com/evanw/esbuild/pkg/api"
        import "os"

        func main() {
          result := api.Build(api.BuildOptions{
            EntryPoints:  []string{"app.js"},
            MangleProps:  "_$",
            ReserveProps: "^__.*__$",
          })

          if len(result.Errors) > 0 {
            os.Exit(1)
          }
        }

  - h4#mangle-cache: >
      Persisting renaming decisions

  - p: >
      Advanced usage of the property mangling feature involves storing the
      mapping from original name to mangled name in a persistent cache. When
      enabled, all mangled property renamings are recorded in the cache during
      the initial build. Subsequent builds reuse the renamings stored in the
      cache and add additional renamings for any newly-added properties. This
      has a few consequences:

  - ul:
    - >
      <p>
      You can customize what mangled properties are renamed to by editing the
      cache before passing it to esbuild.
      </p>

    - >
      <p>
      The cache serves as a list of all properties that were mangled. You can
      easily scan it to see if there are any unexpected property renamings.
      </p>

    - >
      <p>
      You can disable mangling for individual properties by setting the renamed
      value to `false` instead of to a string. This is similar to the [reserve props](#reserve-props)
      setting but on a per-property basis.
      </p>

    - >
      <p>
      You can ensure consistent renaming between builds (e.g. a main-thread
      file and a web worker, or a library and a plugin). Without this feature,
      each build would do an independent renaming operation and the mangled
      property names likely wouldn't be consistent.
      </p>

  - p: >
      For example, consider the following input file:

  - pre.js: |
      console.log({
        someProp_: 1,
        customRenaming_: 2,
        disabledRenaming_: 3
      });

  - p: >
      If we want `customRenaming_` to be renamed to `cR_` and we don't want
      `disabledRenaming_` to be renamed at all, we can pass the following
      mangle cache JSON to esbuild:

  - pre.json: |
      {
        "customRenaming_": "cR_",
        "disabledRenaming_": false
      }

  - p: >
      The mangle cache JSON can be passed to esbuild like this:

  - example:
      in:
        app.js: '1 + 2'

      cli: |
        esbuild app.js --mangle-props=_$ --mangle-cache=cache.json

      mjs: |
        import * as esbuild from 'esbuild'

        let result = await esbuild.build({
          entryPoints: ['app.js'],
          mangleProps: /_$/,
          mangleCache: {
            customRenaming_: "cR_",
            disabledRenaming_: false
          },
        })

        console.log('updated mangle cache:', result.mangleCache)

      go: |
        package main

        import "fmt"
        import "github.com/evanw/esbuild/pkg/api"
        import "os"

        func main() {
          result := api.Build(api.BuildOptions{
            EntryPoints: []string{"app.js"},
            MangleProps: "_$",
            MangleCache: map[string]interface{}{
              "customRenaming_":   "cR_",
              "disabledRenaming_": false,
            },
          })

          if len(result.Errors) > 0 {
            os.Exit(1)
          }

          fmt.Println("updated mangle cache:", result.MangleCache)
        }

  - p: >
      When property naming is enabled, that will result in the following
      output file:

  - pre.js: |
      console.log({
        a: 1,
        cR_: 2,
        disabledRenaming_: 3
      });

  - p: >
      And the following updated mangle cache:

  - pre.json: |
      {
        "customRenaming_": "cR_",
        "disabledRenaming_": false,
        "someProp_": "a"
      }

  - h3: Minify

  - p: >
      启用该配置时，生成的代码会被压缩而不是格式化输出。
      压缩后的代码与未压缩代码是相等的，但是会更小。这意味着下载更快但是更难调试。
      一般情况下在生产环境而不是开发环境压缩代码。

  - p: >
      在 esbuild 中这样启用压缩：

  - example:
      cli:
        - $: |
            echo 'fn = obj => { return obj.x }' | esbuild --minify
        - expect: |
            fn=n=>n.x;

      mjs:
        - $: import * as esbuild from 'esbuild'
        - $: |
            var js = 'fn = obj => { return obj.x }'
        - $: |
            (await esbuild.transform(js, {
              minify: true,
            })).code
        - expect: |
            'fn=n=>n.x;\n'

      go: |
        package main

        import "fmt"
        import "github.com/evanw/esbuild/pkg/api"

        func main() {
          js := "fn = obj => { return obj.x }"

          result := api.Transform(js, api.TransformOptions{
            MinifyWhitespace:  true,
            MinifyIdentifiers: true,
            MinifySyntax:      true,
          })

          if len(result.Errors) == 0 {
            fmt.Printf("%s", result.Code)
          }
        }

  - p: >
      该配置项结合起来做三件独立的事情：移除空格、重写语法使其更体积更小、重命名变量为更短的名称。
      一般情况下这三件事情你都想做，但是如果有必要的话，这些配置项可以单独启用：

  - example:
      cli:
        - $: |
            echo 'fn = obj => { return obj.x }' | esbuild --minify-whitespace
        - expect: |
            fn=obj=>{return obj.x};

        - $: |
            echo 'fn = obj => { return obj.x }' | esbuild --minify-identifiers
        - expect: |
            fn = (n) => {
              return n.x;
            };

        - $: |
            echo 'fn = obj => { return obj.x }' | esbuild --minify-syntax
        - expect: |
            fn = (obj) => obj.x;

      mjs:
        - $: import * as esbuild from 'esbuild'

        - $: |
            var js = 'fn = obj => { return obj.x }'

        - $: |
            (await esbuild.transform(js, {
              minifyWhitespace: true,
            })).code
        - expect: |
            'fn=obj=>{return obj.x};\n'

        - $: |
            (await esbuild.transform(js, {
              minifyIdentifiers: true,
            })).code
        - expect: |
            'fn = (n) => {\n  return n.x;\n};\n'

        - $: |
            (await esbuild.transform(js, {
              minifySyntax: true,
            })).code
        - expect: |
            'fn = (obj) => obj.x;\n'

      go: |
        package main

        import "fmt"
        import "github.com/evanw/esbuild/pkg/api"

        func main() {
          css := "div { color: yellow }"

          result1 := api.Transform(css, api.TransformOptions{
            Loader:           api.LoaderCSS,
            MinifyWhitespace: true,
          })

          if len(result1.Errors) == 0 {
            fmt.Printf("%s", result1.Code)
          }

          result2 := api.Transform(css, api.TransformOptions{
            Loader:            api.LoaderCSS,
            MinifyIdentifiers: true,
          })

          if len(result2.Errors) == 0 {
            fmt.Printf("%s", result2.Code)
          }

          result3 := api.Transform(css, api.TransformOptions{
            Loader:       api.LoaderCSS,
            MinifySyntax: true,
          })

          if len(result3.Errors) == 0 {
            fmt.Printf("%s", result3.Code)
          }
        }

  - p: >
      这些概念同样适用于 CSS，而不仅仅是 JavaScript：

  - example:
      cli:
        - $: |
            echo 'div { color: yellow }' | esbuild --loader=css --minify
        - expect: |
            div{color:#ff0}

      mjs:
        - $: import * as esbuild from 'esbuild'
        - $: |
            var css = 'div { color: yellow }'
        - $: |
            (await esbuild.transform(css, {
              loader: 'css',
              minify: true,
            })).code
        - expect: |
            'div{color:#ff0}\n'

      go: |
        package main

        import "fmt"
        import "github.com/evanw/esbuild/pkg/api"

        func main() {
          css := "div { color: yellow }"

          result := api.Transform(css, api.TransformOptions{
            Loader:            api.LoaderCSS,
            MinifyWhitespace:  true,
            MinifyIdentifiers: true,
            MinifySyntax:      true,
          })

          if len(result.Errors) == 0 {
            fmt.Printf("%s", result.Code)
          }
        }

  - p: >
      esbuild 中的 JavaScript 压缩算法生成的输出通常与行业标准 JavaScript 压缩工具生成的输出大小相近。
      [benchmark](https://github.com/privatenumber/minification-benchmarks/tree/cd3e5acb8d38da5f86426d44ac95974812559683#readme)
      有一个不同压缩工具之间的样例对比。尽管 esbuild 不是所有场景下的最优 JavaScript 压缩工具，
      它努力在专用缩小工具的几个百分点内为大多数代码生成缩小的输出，当然也比其他工具快得多。

  - h4#minify-considerations: 思考

  - p: >
      当时用 esbuild 作为压缩器时需要记住以下几点：

  - ul:
      - >
        <p>
        当启用压缩时也可能也需要设置 [target](#target) 配置项 。默认情况下，
        esbuild 利用现代 JavaScript 特性使你的代码变得更小。例如，
        <code>a ===<wbr> undefined<wbr> || a ===<wbr> null<wbr> ? 1 : a</code>
        可以被压缩为 <code>a ?? 1</code>。如果你不想让 esbuild 在压缩是利用现代 JavaScript 特性，
        你应该使用一个更老的语言目标，例如 <code>--target=es6</code>。
        </p>

<<<<<<< HEAD
      - >
        <p>
        对于所有的 JavaScript 代码，
        压缩不是 100% 安全的。
        这对 esbuild 和其他流行的 JavaScript 压缩器，
        例如 [terser](https://github.com/terser/terser) 是真实存在的。
        特别地，esbuild 并不是为了保存函数上调用 `.toString()` 的值而设计的。
        原因是如果所有函数中的所有代码都要逐字保存的话，
        压缩会变得非常困难并且实际上是没有用的。
        然而，这意味着依赖于 `.toString()` 返回值的 JavaScript 代码
        在压缩过程中可能会中断。
        例如，在 [Angular](https://angular.io/) 框架中一些模式在代码压缩时会中断，
        因为 Angular 使用 `.toString()` 来读取函数的参数名称。
        一个解决方案是使用 [明确的注释替代](https://docs.angularjs.org/api/auto/service/$injector#injection-function-annotation)。
        </p>
=======
    - >
      <p>
      The character escape sequence `\n` will be replaced with a newline
      character in JavaScript template literals. String literals will also be
      converted into template literals if the [target](#target) supports them
      and if doing so would result in smaller output. **This is not a bug.**
      Minification means you are asking for smaller output, and the escape
      sequence `\n` takes two bytes while the newline character takes one byte.
      </p>

    - >
      <p>
      By default esbuild won't minify the names of top-level declarations. This
      is because esbuild doesn't know what you will be doing with the output.
      You might be injecting the minified code into the middle of some other
      code, in which case minifying top-level declaration names would be unsafe.
      Setting an output [format](#format) (or enabling [bundling](#bundle),
      which picks an output format for you if you haven't set one) tells
      esbuild that the output will be run within its own scope, which means
      it's then safe to minify top-level declaration names.
      </p>

    - >
      <p>
      The character escape sequence `\n` will be replaced with a newline
      character in JavaScript template literals. String literals will also be
      converted into template literals if the [target](#target) supports them
      and if doing so would result in smaller output. **This is not a bug.**
      Minification means you are asking for smaller output, and the escape
      sequence `\n` takes two bytes while the newline character takes one byte.
      </p>

    - >
      <p>
      By default esbuild won't minify the names of top-level declarations. This
      is because esbuild doesn't know what you will be doing with the output.
      You might be injecting the minified code into the middle of some other
      code, in which case minifying top-level declaration names would be unsafe.
      Setting an output [format](#format) (or enabling [bundling](#bundle),
      which picks an output format for you if you haven't set one) tells
      esbuild that the output will be run within its own scope, which means
      it's then safe to minify top-level declaration names.
      </p>

    - >
      <p>
      Minification is not safe for 100% of all JavaScript code. This is true
      for esbuild as well as for other popular JavaScript minifiers such as
      [terser](https://github.com/terser/terser). In particular, esbuild is
      not designed to preserve the value of calling `.toString()` on a
      function. The reason for this is because if all code inside all
      functions had to be preserved verbatim, minification would hardly do
      anything at all and would be virtually useless. However, this means that
      JavaScript code relying on the return value of `.toString()` will likely
      break when minified. For example, some patterns in the [AngularJS](https://angularjs.org/)
      framework break when code is minified because AngularJS uses `.toString()`
      to read the argument names of functions. A workaround is to use [explicit
      annotations instead](https://docs.angularjs.org/api/auto/service/$injector#injection-function-annotation).
      </p>
>>>>>>> 2e131b091e6a1dd99b9a331f6f3c75534bf796be

      - >
        <p>
        默认情况下，esbuild 不会在函数和类对象上保留 `.name` 的值。这是因为大多数代码不会依赖该属性，
        并且使用更短的名称是一个重要的大小优化。然而，一些代码确实依赖 `.name` 属性来注册和绑定。
        如果你需要依赖该属性，你应该启用 [keep names](#keep-names) 配置项。
        </p>

      - |
        <p>
        使用某些 JavaScript 特性可以禁用 esbuild 的许多优化，包括压缩。
        具体来说，直接使用 `eval` 和/或 `with` 语句可以阻止 esbuild 将标识符重命名为更小的名称，
        因为这些特性会导致标识符绑定在运行时而不是编译时发生。
        这几乎总是无意的，而且只发生在人们不知道什么是直接 eval 以及它为什么不好的情况下。
        </p>
        <p>
        如果你正在考虑像这样写一段代码：
        </p>
        <pre>
        // 直接使用 eval （将会禁用整个文件的压缩）
        let result = eval(something)
        </pre>
        <p>
        你应该这样写，你的代码才能被压缩：
        </p>
        <pre>
        // 间接使用 eval （对周围的代码没有副作用）
        let result = (0, eval)(something)
        </pre>
        <p>
        [这里](/content-types/#direct-eval) 可以获取关于直接使用 `eval` 以及可用选择的更多信息。
        </p>

      - >
        <p>
        esbuild 中的压缩算法还没有进行高级代码优化。特别是，下面的代码优化对 JavaScript 是
        有可能的，但不是由 esbuild 完成的（不是一个详尽的列表）：
        </p>
        <ul>
          <li>消除函数体中的 dead-code</li>
          <li>函数内联</li>
          <li>Cross-statement 常数传播</li>
          <li>对象形状建模</li>
          <li>Allocation sinking</li>
          <li>Method devirtualization</li>
          <li>Symbolic execution</li>
          <li>JSX 表达式提升</li>
          <li>TypeScript 枚举检测和内联</li>
        </ul>
        <p>
        如果你的代码使用的模式要求某些形式的代码优化是紧凑的，或者如果你正在为你的用例搜索最佳的
        JavaScript 压缩算法，你应该考虑使用其他工具。实现这些高级代码优化的一些工具示例包括
        [Terser](https://github.com/terser/terser#readme) 和
        [Google Closure Compiler](https://github.com/google/closure-compiler#readme)。
        </p>

<<<<<<< HEAD
  - h3: Outdir

  - p: >
      该配置项为 build 操作设置输出文件夹。例如，该命令会生成一个名为 `out` 的目录：

  - example:
      in:
        app.js: "1 + 2"

      cli: |
        esbuild app.js --bundle --outdir=out

      js: |
        require('esbuild').buildSync({
          entryPoints: ['app.js'],
          bundle: true,
          outdir: 'out',
        })

      go: |
        package main

        import "github.com/evanw/esbuild/pkg/api"
        import "os"

        func main() {
          result := api.Build(api.BuildOptions{
            EntryPoints: []string{"app.js"},
            Bundle:      true,
            Outdir:      "out",
          })

          if len(result.Errors) > 0 {
            os.Exit(1)
          }
        }

  - p: >
      输出文件夹如果不存在的话将会创建该文件夹，但是当其包含一些文件时不会被清除。
      生成的文件遇到同名文件会进行静默覆盖。如果你想要输出文件夹只包含当前 esbuild 运行生成的文件，
      你应该在运行 esbuild 之前清除输出文件夹。

  - p: >
      如果你的构建有多个入口，且多个入口在单独的文件夹内，目录结构将从所有输入入口点路径中
      [最低的公共祖先](https://en.wikipedia.org/wiki/Lowest_common_ancestor) 目录开始复制到输出目录中。If your build contains multiple entry points in separate directories, the
      例如，这里有两个入口起点 <code>src/<wbr>home/<wbr>index.ts</code> 与
      <code>src/<wbr>about/<wbr>index.ts</code>，输出文件夹将会包含
      <code>home/<wbr>index.js</code> 与 <code>about/<wbr>index.js</code>。
      如果你想要自定义该行为，你应该改变 [outbase directory](#outbase)。

  - h3: Outfile

  - p: >
      该配置项为 build 操作设置输出文件名。这仅在单个入口点时适用。
      如果有多个入口点，你必须适用 [outdir](#outdir) 配置项来制定输出文件夹。
      像这样使用outfile：

  - example:
      in:
        app.js: "1 + 2"

      cli: |
        esbuild app.js --bundle --outfile=out.js

      js: |
        require('esbuild').buildSync({
          entryPoints: ['app.js'],
          bundle: true,
          outfile: 'out.js',
        })

      go: |
        package main

        import "github.com/evanw/esbuild/pkg/api"
        import "os"

        func main() {
          result := api.Build(api.BuildOptions{
            EntryPoints: []string{"app.js"},
            Bundle:      true,
            Outdir:      "out.js",
          })

          if len(result.Errors) > 0 {
            os.Exit(1)
          }
        }

  - h3: Platform

  - p: >
      默认情况下，esbuild 的打包器为浏览器生成代码。
      如果你打包好的代码想要在 node 环境中运行，你应该设置 platform 为 `node`：

  - example:
      in:
        app.js: "1 + 2"

      cli: |
        esbuild app.js --bundle --platform=node

      js: |
        require('esbuild').buildSync({
          entryPoints: ['app.js'],
          bundle: true,
          platform: 'node',
          outfile: 'out.js',
        })

      go: |
        package main

        import "github.com/evanw/esbuild/pkg/api"
        import "os"

        func main() {
          result := api.Build(api.BuildOptions{
            EntryPoints: []string{"app.js"},
            Bundle:      true,
            Platform:    api.PlatformNode,
            Write:       true,
          })

          if len(result.Errors) > 0 {
            os.Exit(1)
          }
        }

  - p: >
      当 platform 设置为 `browser`（默认值）时：

  - ul:
      - >
        <p>
        默认的输出 [格式](#format) 为 `iife`，将生成的 JavaScript 代码包裹在立即执行函数表达式中，
        以阻止变量泄露到全局作用域中。 
        </p>
      - >
        <p>
        如果一个包在 `package.json` 文件中
        的[`browser`](https://gist.github.com/defunctzombie/4339901/49493836fb873ddaa4b8a7aa0ef2352119f69211)
        配置配置了一个 map，esbuild 将会使用该 map 替换指定的文件或模块为对浏览器友好的版本。
        例如，例如，一个包可能会用 [`path-browserify`](https://www.npmjs.com/package/path-browserify) 替换
        [`path`](https://nodejs.org/api/path.html)。
        </p>
      - >
        <p>
        [main fields](#main-fields) 设置为 <code>browser,<wbr>module,<wbr>main</code>，
        但是会有一些额外的特殊行为。如果你个包支持 `module` 与 `main`，但是不支持 `browser`，
        那么当使用 `require()` 导入时，将使用 `main` 而不是 `module`。
        此行为通过将函数赋值给 `module.exports` 来改善与导出函数的 CommonJS 模块的兼容性。
        </p>
      - >
        <p>
        [conditions](#conditions) 设置自动包含了 `browser` 情况。
        这将改变 `package.json` 文件中 `exports` 字段如何被解释为偏好特定于浏览器代码的方式。
        </p>
      - >
        <p>
        All <code>process.<wbr>env.<wbr>NODE_ENV</code> expressions are automatically
        [defined](#define) to `"production"` if all [minification](#minify)
        options are enabled and `"development"` otherwise. This only happens if
        `process`, `process.env`, and `process.env.NODE_ENV` are not already
        defined. This substitution is necessary to avoid React-based code crashing
        instantly (since `process` is a node API, not a web API).
        </p>

  - p: >
      当 platform 设置为 `node` 时：

  - ul:
      - >
        <p>
        默认输出 [格式](#format) 为 `cjs`，代表 CommonJS（node 使用的模块格式）。
        ES6-风格的导出使用的 `export` 语句将会被转换为 CommonJS `exports` 对象中的 getters。
        </p>
      - >
        <p>
        所有诸如 `fs` 的 [内置 node 模块](https://nodejs.org/docs/latest/api/) 会被自动标记为
        [external](#external)，因此在打包器尝试打包他们时不会导致错误。
        </p>
      - >
        <p>
        [main 字段](#main-fields) 设置为 <code>main,<wbr>module</code>。
        这意味着 tree shaking 操作可能不会发生在同时提供 `module` 和 `main` 的包中，
        因为 tree shaking 操作只适用于 ECMAScript 模块，而不适用于 CommonJS 模块。
        </p>
        <p>
        不幸的是，一些包将 `module` 视为 "browser code" 而不是 "ECMAScript module code"，
        因此，这种默认行为是兼容性所必需的。如果你想要启用 tree shaking 并且知道这样做是安全的，
        那么你可以手动将 [main 字段](#main-fields) 设置为 <code>module,<wbr>main</code>。
        </p>
      - >
        <p>
        [conditions](#conditions) 设置自动包含 `node` 情况。
        这将改变 `package.json` 文件中 `exports` 字段如何被解释为偏好特定于 node 端代码的方式。
        </p>

  - p: >
      当 platform 设置为 `neutral` 时：

  - ul:
      - >
        <p>
        默认输出 [格式](#format) 为 `esm`，使用 ECMAScript 2015 (即 ES6) 中引入的 `export` 语法。
        如果默认值不合适的话你可以改变输出格式。
        </p>
      - >
        <p>
        [main 字段](#main-fields) 默认设置为空。如果你想使用 npm 风格的包，
        你可能需要将其配置为其他内容，比如将 node 使用的 main 字段配置为 `main`。
        </p>
      - >
        <p>
        [conditions](#conditions) 设置不会自动包含任何平台特定值。
        </p>

  - p: >
      可以查看 [为浏览器打包](/getting-started/#bundling-for-the-browser)
      与 [为 node 打包](/getting-started/#bundling-for-node)。

  - h3: Serve

  - p: >
      在开发过程中，当发生更改时在文本编辑器与浏览器之间来回切换是很正常的事。
      在浏览器中重新加载代码之前手动重新运行 esbuild 是很不方便的。有几种方法可以自动完成：

  - ul:
      - 当一个文件发生更改时使用 [监听模式](#watch) 重新运行 esbuild
      - 将你的文本编辑器配置为每次保存代码重新运行 esbuild
      - 使用一个对于每次请求都会重新构建的 web 服务器来为你的代码提供服务

  - p: >
      此 API 调用使用的是最后一种方法。serve API 与 [build API](#build-api) 调用很相似，
      但是它不会将生成的代码写入到文件系统中，它启动一个 long-lived 本地 web 服务器来为最新构建生成的代码提供服务。
      每批新的请求都会导致 esbuild 在响应请求之前重新运行构建命令，这样你的文件就总是最新的。

  - p: >
      此方法对于其他方法的优势在于 web 服务器可以延迟浏览器请求，知道构建完成。
      在最新构建完成之前重新加载你的代码，将永远不会运行上一次构建生成的代码。
      这些文件在内存中提供服务，并且没有写入到文件系统中，以确保过时的文件不会被监听。

  - p: >
      请注意，这仅会在开发环境中使用。_不要将其用在生产环境中。_
      在生产环境中你不应该使用 esbuild 作为一个 web 服务器来服务静态资源。、

  - p: >
      有两个不同的方法来使用 serve API：

  - h4#serve-everything: "方法 1：为 esbuild 构建出的所有内容提供服务"

  - p: >
      通过这种方法，你为 esbuild 提供一个名为 servedir 的目录，除了 esbuild 生成的文件之外，还提供了额外的内容。
      这对于创建一些静态 HTML 页面并希望使用 esbuild 打包 JavaScript 和/或 CSS 的简单情况非常有用。
      你可以把你的 HTML 文件置于 servedir 中，你的其他源代码置于 servedir 之外，
      然后将 [`outdir`](#outdir) 设置为在某处的 servedir：

  - example:
      noCheck: true

      cli: |
        esbuild src/app.js --servedir=www --outdir=www/js --bundle

      js: |
        require('esbuild').serve({
          servedir: 'www',
        }, {
          entryPoints: ['src/app.js'],
          outdir: 'www/js',
          bundle: true,
        }).then(server => {
          // Call "stop" on the web server to stop serving
          server.stop()
        })

      go: |
        server, err := api.Serve(api.ServeOptions{
          Servedir: "www",
        }, api.BuildOptions{
          EntryPoints: []string{"src/app.js"},
          Outdir:      "www/js",
          Bundle:      true,
        })

        // Call "stop" on the web server to stop serving
        server.Stop()

  - p: >
      在上面的例子中，你的 `www/index.html` 页面可以像这样引用打包好的 `src/app.js` 文件：

  - pre.html: |
      <script src="js/app.js"></script>

  - p: >
      当你这样做时，每一个 HTTP 请求都会导致 esbuild 重新构建你的代码，并且为你提供最新版本的代码。
      因此每次刷新页面，`js/app.js` 文件总是最新的。请注意尽管生成的出现在了 `outdir` 目录中，
      但是它从来没有使用 serve API 真正写入过文件系统。相反，生成的代码映射的路径（即优先于其他路径）
      在 `servedir` 和生成的文件直接从内存提供服务。

  - p: >
      这样做的好处是，你可以使用在开发环境与生产环境使用完全相同的 HTML 页面。
      在开发环境中你可以使用 `--servedir=` 运行 esbuild，esbuild 将会直接为生成的输出文件提供服务。
      在生产环境中，你可以设置该标志，esbuild 将会把生成的文件写入到文件系统中。
      这两种情况下你应该能够在浏览器中得到完全一样的结果，其在开发环境与生产环境中拥有完全相同的代码。

  - p: >
      端口号默认自动设置为大于等于 8000 的一个开放端口。端口号会在 API 调用时返回（或者使用 CLI 时会打印在终端中），
      这样你就可以知道应该访问哪一个 URL。如果有必要的话，端口号可以被指定（下面会详细描述）。

  - h4#serve-generated: "方法 2: 仅为 esbuild 生成的文件提供服务"

  - p: >
      使用该方法，你只需要告诉 esbuild 为 [`outdir`](#outdir) 中的内容提供服务，而不会让其为额外的内容提供服务。
      对比更复杂的开发环境配置是比较有用的。例如，你可能想要在开发环境中使用 NGINX 作为反向代理来路由不同的路径到不同的后端服务
      （例如 `/static/` 转向 NGINX、`/api/` 转向 node、`/js/` 转向 esbuild 等）。
      可以向这样使用 esbuild 的该方法：

  - example:
      noCheck: true

      cli: |
        esbuild src/app.js --outfile=out.js --bundle --serve=8000

      js: |
        require('esbuild').serve({
          port: 8000,
        }, {
          entryPoints: ['src/app.js'],
          bundle: true,
          outfile: 'out.js',
        }).then(server => {
          // Call "stop" on the web server to stop serving
          server.stop()
        })

      go: |
        server, err := api.Serve(api.ServeOptions{
          Port: 8000,
        }, api.BuildOptions{
          EntryPoints: []string{"src/app.js"},
          Bundle:      true,
          Outfile:     "out.js",
        })

        // Call "stop" on the web server to stop serving
        server.Stop()

  - p: >
      上面示例中的 API 调用会在 [http://localhost:8000/out.js](http://localhost:8000/out.js) 为
      编译好的 `src/app.js` 提供服务。就像是第一个方法，每个 HTTP 请求都会导致 esbuild 重新构建你的代码，
      并且为你提供最新版本的代码。因此 `out.js` 将一直是最新的。你的 HTML 文件（被其他 web 服务器在其他端口上提供服务）
      可以在你的 HTML 文件中像这样关联编译好的文件：

  - pre.html: |
      <script src="http://localhost:8000/out.js"></script>

  - p: >
      在没有启用 web 服务器的情况下，使用正常的构建命令时，web 服务器的 URL 结构与 [输出目录](#outdir) 的URL结构完全相同。
      例如，如果输出输出文件夹包含一个叫做 <code>./pages/<wbr>about.js</code> 的文件，web 服务器将会有一个相应的
      <code>/pages/<wbr>about.js</code> 路径。

  - p: >
      如果你想要浏览 web 服务器以查看哪些 URL 是有效的，你可以通过访问文件夹名称而不是文件名称来使用内置文件夹列表。
      例如，如果你正在 8000 端口运行 esbuild 的 web 服务器，你可以在浏览器中访问
      [http://<wbr>localhost:<wbr>8000/](http://localhost:8000/) 来查看 web 服务器的根目录。
      在这里你可以点击链接在 web 服务器中打开不同的文件或链接。

  - h4#serve-arguments: 参数

  - p: >
      请注意 serve API 是与 [build API](#build-api) 不同的 API 调用。
      这是因为启动一个长时间运行的 web 服务器是完全不同的，因此需要不同的参数和返回值。
      serve API 调用的第一个参数是一个带有特定于 serve 的配置项的配置项对象：

  - example:
      noCheck: true

      js: |
        interface ServeOptions {
          port?: number;
          host?: string;
          servedir?: string;
          onRequest?: (args: ServeOnRequestArgs) => void;
        }

        interface ServeOnRequestArgs {
          remoteAddress: string;
          method: string;
          path: string;
          status: number;
          timeInMS: number;
        }

      go: |
        type ServeOptions struct {
          Port      uint16
          Host      string
          Servedir  string
          OnRequest func(ServeOnRequestArgs)
        }

        type ServeOnRequestArgs struct {
          RemoteAddress string
          Method        string
          Path          string
          Status        int
          TimeInMS      int
        }

  - ul:
      - >
        `port`
        <p>
        可以选择在这里配置 HTTP 端口。如果省略，它将默认使用一个开放端口，优先级为 8000 端口。
        你可以在命令行中通过使用 `--serve=8000` 而不仅仅是 `--serve` 来设置端口。
        </p>

      - >
        `host`
        <p>
        默认情况下，esbuild 在所有的 IPv4 网络接口中有效。
        这对应着 `0.0.0.0` 的 host。如果你想要配置一个不同的 host（例如，仅在 `127.0.0.1` 回路中提供服务而不向网络公开任何信息），
        你可以使用该参数指定 host。你可以在命令行中通过使用 <code>--serve=<wbr>127.0.0.1:<wbr>8000</code>
        而不仅仅是 `--serve` 来设置 host。
        </p>
        <p>
        如果你需要使用 IPv6 而不是 IPv4，你仅需要指定一个 IPv6 host 地址。
        在 IPv6 中与 `127.0.0.1` 回路接口等效的是 `::1`，并且与 `0.0.0.0` 通用接口等效的是 `::`。
        如果你正在使用命令行将 host 设置为 IPv6 地址，你需要用方括号将 IPv6 地址括起来，以区别地址中
        的冒号和分隔主机和端口的冒号，就像这样： <code>--serve=<wbr>[::]:<wbr>8000</code>。
        </p>

      - >
        `servedir`
        <p>
        这是 esbuild 的 HTTP 服务器提供的额外内容目录，当传入的请求与生成的任何输出文件路径不匹配时，它将代替 404。
        这使你可以将 esbuild 用作通用的本地 web 服务器。例如，使用 <code>esbuild <wbr>--servedir=.</code>
        在 `localhost` 为当前文件夹提供服务。在前面关于不同方法的部分中，对使用 `servedir` 进行了更详细的描述。
        </p>

      - >
        `onRequest`
        <p>
        对每个传入的请求调用一次，并提供有关请求的一些信息。
        CLI 使用该回调为每一个请求打印日志信息。time 字段是为该请求生成数据的时间，
        但是它不包括向客户端发送请求流的时间。
        </p>
        <p>
        请注意这会在请求完成后调用。使用该回调以任何形式修改请求是不可能的。
        如果你想要这样做，你应该 [在 esbuild 之前设置一个代理](#customizing-server-behavior)。
        </p>

  - p: >
      serve API 调用的第二个参数是每个请求都会调用的底层构建 API 的常规配置项集合。
      查看 [build API](#build-api) 文档获取更多关于这些配置项的信息。

  - h4#serve-return-values: 返回值

  - example:
      noCheck: true

      js: |
        interface ServeResult {
          port: number;
          host: string;
          wait: Promise<void>;
          stop: () => void;
        }

      go: |
        type ServeResult struct {
          Port uint16
          Host string
          Wait func() error
          Stop func()
        }

  - ul:
      - >
        `port`
        <p>
        这个是最终被 web 服务器使用的端口。如果你没有指定一个端口的话你将想要使用它，因为 esbuild
        将最终挑选一个随机开放端口，并且你需要知道它选择了那个段扩才能连接到它。
        如果你正在使用 CLI，这个端口号将会被打印在终端的 stderr 中。
        </p>

      - >
        `host`
        <p>
        这个是最终被 web 服务器使用的 host。它将是
        `0.0.0.0`（即 服务所有可用的网络接口），除非配置了一个自定义 host。
        </p>

      - >
        `wait`
        <p>
        只要 socket 打开，serve API 调用会立即返回。这个 `wait` 返回值提供了一种方法，可以在 web 服务器
        由于网络错误或者由于将来某个时间点停止调用而终止是通知它。
        </p>

      - >
        `stop`
        <p>
        当你不需要它清理资源时，你可以调用该回调以停止 web 服务器。
        这将会立即终止所有打开的链接，并且唤醒所有等待 `wait` 返回值的代码。
        </p>

  - h4: 自定义服务器行为

  - p: >
      不可能 hook 到 esbuild 的本地服务器来定制服务器本身的行为。
      相反，应该通过在 esbuild 前设置代理来定制行为。

  - p: >
      下面是一个代理服务器的简单示例。
      他添加了自定义 404 页面而不使用 esbuild 的默认 404 页面：

  - pre.js: |
      const esbuild = require('esbuild');
      const http = require('http');

      // Start esbuild's server on a random local port
      esbuild.serve({
        servedir: __dirname,
      }, {
        // ... your build options go here ...
      }).then(result => {
        // The result tells us where esbuild's local server is
        const {host, port} = result

        // Then start a proxy server on port 3000
        http.createServer((req, res) => {
          const options = {
            hostname: host,
            port: port,
            path: req.url,
            method: req.method,
            headers: req.headers,
          }

          // Forward each incoming request to esbuild
          const proxyReq = http.request(options, proxyRes => {
            // If esbuild returns "not found", send a custom 404 page
            if (proxyRes.statusCode === 404) {
              res.writeHead(404, { 'Content-Type': 'text/html' });
              res.end('<h1>A custom 404 page</h1>');
              return;
            }

            // Otherwise, forward the response from esbuild to the client
            res.writeHead(proxyRes.statusCode, proxyRes.headers);
            proxyRes.pipe(res, { end: true });
          });

          // Forward the body of the request to esbuild
          req.pipe(proxyReq, { end: true });
        }).listen(3000);
      });

  - p: >
      该代码在一个随机本地端口启动了 esbuild 服务器，然后在 3000 端口启动了一个代理服务器。
      在开发环境中你可以在浏览器中加载 [http://localhost:3000](http://localhost:3000)，
      这将会走向代理。该示例示范了在 esbuild 已经处理请求之后修改相应信息，但你也可以在 esbuild 处理它之前
      修改或替换请求信息。

  - p: >
      你可以使用代理做很多事情，就像下面的举例：

  - ul:
      - 插入你自己的 404 页面（上面的示例）
      - 自定义路由与文件系统中文件之间的映射关系
      - 重定向一些路由到 API 服务器而不是到 esbuild
      - 使用自签名证书添加 HTTPS 支持

  - p: >
      如果你有更高级的需求的话，你也可以使用诸如 [NGINX](https://nginx.org/en/docs/beginners_guide.html#proxy) 一样真正的代理。

  - h3: Sourcemap

  - p: >
      Source map 可以使调试代码更容易。
      它们编码从生成的输出文件中的行/列偏移量转换回
      对应的原始输入文件中的行/列偏移量所需的信息。
      如果生成的代码与原始代码有很大的不同，
      这是很有用的（例如 你的源代码为 Typescript 或者你启用了 [压缩](#minify)）。
      如果你更希望在你的浏览器开发者工具中寻找单独的文件，
      而不是一个大的打包好的文件，
      这也很有帮助。

  - p: >
      注意 source map 的输出支持 JavaScript 和 CSS，
      而且二者的配置一致。下文中提及的 `.js` 文件
      和 `.css` 文件的配置是类似的。

  - p: >
      启用 source map 将会伴随着任何一个生成的 `.js` 文件生成一个 `.js.map` 文件，并且在
      `.js` 文件底部添加特殊的 `//# sourceMappingURL=` 注释以指向 `.js.map` 文件。
      There are four different modes for source map generation:

  - div: >
      <ol start="1"><li>
      <code>linked</code>
      <p>
      This mode means the source map is generated into a separate `.js.map`
      output file alongside the `.js` output file, and the `.js` output file contains
      a special `//# sourceMappingURL=` comment that points to the `.js.map` output file.
      That way the browser knows where to find the source map for a given file
      when you open the debugger. Use `linked` source map mode like this:
      </p>
      </li></ol>

      There are four different modes for source map generation:

  - div: >
      <ol start="1"><li>
      <code>linked</code>
      <p>
      This mode means the source map is generated into a separate `.js.map`
      output file alongside the `.js` output file, and the `.js` output file contains
      a special `//# sourceMappingURL=` comment that points to the `.js.map` output file.
      That way the browser knows where to find the source map for a given file
      when you open the debugger. Use `linked` source map mode like this:
      </p>
      </li></ol>

  - example:
      in:
        app.ts: "let x: number = 1"

      cli: |
        esbuild app.ts --sourcemap --outfile=out.js

      js: |
        require('esbuild').buildSync({
          entryPoints: ['app.ts'],
          sourcemap: true,
          outfile: 'out.js',
        })

      go: |
        package main

        import "github.com/evanw/esbuild/pkg/api"
        import "os"

        func main() {
          result := api.Build(api.BuildOptions{
            EntryPoints: []string{"app.ts"},
            Sourcemap:   api.SourceMapLinked,
            Outfile:     "out.js",
            Write:       true,
          })

          if len(result.Errors) > 0 {
            os.Exit(1)
          }
        }

  - p: >
      如果输入的文件本身包含特殊 `//# sourceMappingURL=` 注释，esbuild 将会自动尝试解析
      链接的 source map。如果成功的话，生成的源映射中的映射将一路映射回输入源映射中引用的原始源代码。

  - div: >
      <ol start="2"><li>
      <code>external</code>
      <p>
      This mode means the source map is generated into a separate `.js.map`
      output file alongside the `.js` output file, but unlike `linked` mode the `.js`
      output file does not contain a `//# sourceMappingURL=` comment. Use `external`
      source map mode like this:
      </p>
      </li></ol>

  - div: >
      <ol start="2"><li>
      <code>external</code>
      <p>
      This mode means the source map is generated into a separate `.js.map`
      output file alongside the `.js` output file, but unlike `linked` mode the `.js`
      output file does not contain a `//# sourceMappingURL=` comment. Use `external`
      source map mode like this:
      </p>
      </li></ol>

  - example:
      in:
        app.ts: "let x: number = 1"

      cli: |
        esbuild app.ts --sourcemap=external --outfile=out.js

      js: |
        require('esbuild').buildSync({
          entryPoints: ['app.ts'],
          sourcemap: 'external',
          outfile: 'out.js',
        })

      go: |
        package main

        import "github.com/evanw/esbuild/pkg/api"
        import "os"

        func main() {
          result := api.Build(api.BuildOptions{
            EntryPoints: []string{"app.ts"},
            Sourcemap:   api.SourceMapExternal,
            Outfile:     "out.js",
            Write:       true,
          })

          if len(result.Errors) > 0 {
            os.Exit(1)
          }
        }

  - p: >
      如果你想插入整个 source map 到 `.js` 文件中而不是单独生成一个 `.js.map` 文件，你应该设置
      source map 模式为 `inline`：

  - div: >
      <ol start="3"><li>
      <code>inline</code>
      <p>
      This mode means the source map is appended to the end of the `.js` output
      file as a base64 payload inside a `//# sourceMappingURL=` comment. No
      additional `.js.map` output file is generated. Keep in mind that source
      maps are usually very big because they contain all of your original source
      code, so you usually do not want to ship code containing `inline` source
      maps. To remove the source code from the source map (keeping only the file
      names and the line/column mappings), use the [sources content](#sources-content) option.
      Use `inline` source map mode like this:
      </p>
      </li></ol>

  - example:
      in:
        app.ts: "let x: number = 1"

      cli: |
        esbuild app.ts --sourcemap=inline --outfile=out.js

      js: |
        require('esbuild').buildSync({
          entryPoints: ['app.ts'],
          sourcemap: 'inline',
          outfile: 'out.js',
        })

      go: |
        package main

        import "github.com/evanw/esbuild/pkg/api"
        import "os"

        func main() {
          result := api.Build(api.BuildOptions{
            EntryPoints: []string{"app.ts"},
            Sourcemap:   api.SourceMapInline,
            Outfile:     "out.js",
            Write:       true,
          })

          if len(result.Errors) > 0 {
            os.Exit(1)
          }
        }


  - p: >
      请记住 source map 通常是比较大的，因为他们包含所有的源代码，因此你通常不会想让代码中包含
      `inline` source maps。为了移除 source map 中的源代码（只保存文件名以及行/列映射关系），
      请使用 [sources content](#sources-content) 配置项。

  - p: >
      如果你想同时设置 `inline` 与 `external` 的话，你应该设置 source map 模式为 `both`：

  - div: >
      <ol start="4"><li>
      <code>both</code>
      <p>
      This mode is a combination of `inline` and `external`. The source map is
      appended inline to the end of the `.js` output file, and another copy of
      the same source map is written to a separate `.js.map` output file
      alongside the `.js` output file. Use `both` source map mode like this:
      </p>
      </li></ol>

  - example:
      in:
        app.ts: "let x: number = 1"

      cli: |
        esbuild app.ts --sourcemap=both --outfile=out.js

      js: |
        require('esbuild').buildSync({
          entryPoints: ['app.ts'],
          sourcemap: 'both',
          outfile: 'out.js',
        })

      go: |
        package main

        import "github.com/evanw/esbuild/pkg/api"
        import "os"

        func main() {
          result := api.Build(api.BuildOptions{
            EntryPoints: []string{"app.ts"},
            Sourcemap:   api.SourceMapInlineAndExternal,
            Outfile:     "out.js",
            Write:       true,
          })

          if len(result.Errors) > 0 {
            os.Exit(1)
          }
        }

  - h4: 使用 source maps

  - p: >
      The [build API](#build-api) supports all four source map modes listed above,
      but the [transform API](#transform-api) does not support the `linked` mode.
      This is because the output returned from the transform API does not have an
      associated filename. If you want the output of the transform API to have a
      source map comment, you can append one yourself. In addition, the CLI form
      of the transform API only supports the `inline` mode because the output is
      written to stdout so generating multiple output files is not possible.

  - p: >
      在浏览器中，source maps 应该会自动被浏览器开发者工具选中，只要其启用了 source map 设置。
      请注意浏览器仅在堆栈跟踪打印在控制台后才会使用 source maps。堆栈跟踪本身没有修改，所以检查 <code>error.<wbr>stack</code>。
      你代码中的堆栈仍然会给出包含已编译代码的未映射堆栈跟踪。
      这里是如何启用浏览器开发者工具中 source map 设置的方式：

  - ul:
      - "Chrome: ⚙ → Enable JavaScript source maps"
      - "Safari: ⚙ → Sources → Enable source maps"
      - "Firefox: ··· → Enable Source Maps"

  - p: >
      在 node 环境中，source map 在 [version v12.12.0](https://nodejs.org/en/blog/release/v12.12.0/) 版本之后原生支持。
      此特性是默认关闭的，但是可以通过一个标志启用。不向在浏览器中，实际的堆栈跟踪也被修改了，所以检查你代码中的 <code>error.<wbr>stack</code>
      将会给出包含源代码的堆栈跟踪。这是如何在 node 中启用该设置（<code>--enable-<wbr>source-<wbr>maps</code> 标志
      必须在文件名之前）：

  - pre.sh: |
      node --enable-source-maps app.js

  - h3: 代码分割

  - warning: >
      代码分隔仍然处于开发状态。它现在仅支持 `esm` 输出 [格式](#format)。
      使用 `import` 语句来分割代码块也有一个已知的
      [排序问题](https://github.com/evanw/esbuild/issues/399) 。你可以关注
      [跟踪问题](https://github.com/evanw/esbuild/issues/16) 获取此特性的更新。

  - p: >
      启用 "代码分隔" 有两个目的：

  - ul:
      - >
        <p>
        多个入口点之间共享的代码被分割成两个入口点都导入的单独共享文件。
        这样，如果用户先浏览一个页面，然后再浏览另一个页面，如果共享部分已经被浏览器下载并缓存，
        他们就不必从头下载第二个页面的所有 JavaScript。
        </p>

      - >
        <p>
        通过异步 `import()` 表达式引用的代码将被分割到一个单独的文件中，
        仅在求值该表达式时才加载。这允许你通过在启动时只下载你需要的代码来改善应用程序的初始下载时间，
        然后在以后需要时延迟下载额外的代码。
        </p>
        <p>
        如果不启用代码分割，`import()` 表达式会变成
        <code>Promise<wbr>.resolve()<wbr>.then(() =&gt; <wbr>require())</code>。
        这仍然保留了表达式的异步语义，但这意味着导入的代码包含在同一个包中，而不是分离到单独的文件中。
        </p>

  - p: >
      当期启用代码分割时，你必须使用 [outdir](#outdir) 配置输出文件夹。

  - example:
      in:
        home.ts: "1 + 2"
        about.ts: "1 + 2"

      cli: |
        esbuild home.ts about.ts --bundle --splitting --outdir=out --format=esm

      js: |
        require('esbuild').buildSync({
          entryPoints: ['home.ts', 'about.ts'],
          bundle: true,
          splitting: true,
          outdir: 'out',
          format: 'esm',
        })

      go: |
        package main

        import "github.com/evanw/esbuild/pkg/api"
        import "os"

        func main() {
          result := api.Build(api.BuildOptions{
            EntryPoints: []string{"home.ts", "about.ts"},
            Bundle:      true,
            Splitting:   true,
            Outdir:      "out",
            Format:      api.FormatESModule,
            Write:       true,
          })

          if len(result.Errors) > 0 {
            os.Exit(1)
          }
        }

  - h3: Target

  - p: >
      此配置项设置生成 JavaScript 代码的目标环境。例如，你可以配置 esbuild 不要生成任何
      v10 版本的 node 不能处理的新的 JavaScript 代码。target 可以设置为类似于 `es2020`
      的 JavaScript 语言版本，或者一个引擎列表（目前可以是 `chrome`、`firefox`、`safari`、`edge`
      或者 `node`）。默认的 target 为 `esnext`，这意味着默认情况下，esbuild 将假设所有最新的 JavaScript
      特性都是受支持的。

  - p: >
      这里是在 esbuild 中使用所有可用 target 环境名称的例子。请注意你不需要指定所有这些；
      你可以仅仅指定你的项目关心的目标环境的子集。如果你愿意的话，你也可以更精确地描述版本号
      （例如 设置为 `node12.19.0` 而不仅仅是 `node12`）：

  - example:
      in:
        app.js: "1 + 2"

      cli: |
        esbuild app.js --target=es2020,chrome58,firefox57,safari11,edge16,node12

      js: |
        require('esbuild').buildSync({
          entryPoints: ['app.js'],
          target: [
            'es2020',
            'chrome58',
            'firefox57',
            'safari11',
            'edge16',
            'node12',
          ],
          outfile: 'out.js',
        })

      go: |
        package main

        import "github.com/evanw/esbuild/pkg/api"
        import "os"

        func main() {
          result := api.Build(api.BuildOptions{
            EntryPoints: []string{"app.js"},
            Target:      api.ES2020,
            Engines: []api.Engine{
              {Name: api.EngineChrome, Version: "58"},
              {Name: api.EngineFirefox, Version: "57"},
              {Name: api.EngineSafari, Version: "11"},
              {Name: api.EngineEdge, Version: "16"},
              {Name: api.EngineNode, Version: "12"},
            },
            Write: true,
          })

          if len(result.Errors) > 0 {
            os.Exit(1)
          }
        }

  - p: >
      你可以参考 [JavaScript loader](/content-types/#javascript) 获取更多关于哪个
      语言版本引入了哪些语法特性。请记住尽管像 `es2020` 的 JavaScript 语言版本是以年定义的，
      这是该规范被批准的年份。这与所有主流浏览器实现该规范的年份无关，因为实现该规范的时间往往
      早于或晚于那一年。

  - p: >
      请注意如果你使用了一个语法特性，esbuild 还不支持将其转为目标语言 target，esbuild 将会
      在不支持的语法位置生成一个错误。例如，当目标是 `es5` 语言版本时，经常会出现这种情况，
      因为 esbuild 只支持将大多数较新的 JavaScript 语法特性转换为 `es6`。

  - h3: Watch

  - p: >
      在 build API 中启用监听模式，告诉 esbuild 监听文件系统中的变化，并在可能导致构建失效的
      文件更改时重新构建。像这样使用它：

  - example:
      noCheck: true

      cli:
        - $: |
            esbuild app.js --outfile=out.js --bundle --watch
        - expect: |
            [watch] build finished, watching for changes...

      js: |
        require('esbuild').build({
          entryPoints: ['app.js'],
          outfile: 'out.js',
          bundle: true,
          watch: true,
        }).then(result => {
          console.log('watching...')
        })

      go: |
        package main

        import "fmt"
        import "github.com/evanw/esbuild/pkg/api"
        import "os"

        func main() {
          result := api.Build(api.BuildOptions{
            EntryPoints: []string{"app.js"},
            Outfile:     "out.js",
            Bundle:      true,
            Write:       true,
            Watch:       &api.WatchMode{},
          })

          if len(result.Errors) > 0 {
            os.Exit(1)
          }

          fmt.Printf("watching...\n")

          // Returning from main() exits immediately in Go.
          // Block forever so we keep watching and don't exit.
          <-make(chan bool)
        }

  - p: >
      如果你正在使用 JavaScript 或者 Go API，你可以选择性地提供一个回调函数，该函数将会在
      增量构建完成后调用。一旦构建完成，就可以使用它来做一些事情（例如 重新加载浏览器中的应用）：

  - example:
      noCheck: true

      js: |
        require('esbuild').build({
          entryPoints: ['app.js'],
          outfile: 'out.js',
          bundle: true,
          watch: {
            onRebuild(error, result) {
              if (error) console.error('watch build failed:', error)
              else console.log('watch build succeeded:', result)
            },
          },
        }).then(result => {
          console.log('watching...')
        })

      go: |
        package main

        import "fmt"
        import "github.com/evanw/esbuild/pkg/api"
        import "os"

        func main() {
          result := api.Build(api.BuildOptions{
            EntryPoints: []string{"app.js"},
            Outfile:     "out.js",
            Bundle:      true,
            Write:       true,
            Watch: &api.WatchMode{
              OnRebuild: func(result api.BuildResult) {
                if len(result.Errors) > 0 {
                  fmt.Printf("watch build failed: %d errors\n", len(result.Errors))
                } else {
                  fmt.Printf("watch build succeeded: %d warnings\n", len(result.Warnings))
                }
              },
            },
          })

          if len(result.Errors) > 0 {
            os.Exit(1)
          }

          fmt.Printf("watching...\n")

          // Returning from main() exits immediately in Go.
          // Block forever so we keep watching and don't exit.
          <-make(chan bool)
        }

  - p: >
      If you want to stop watch mode at some point in the future, you can call
      "stop" on the result object to terminate the file watcher:

  - example:
      noCheck: true

      js: |
        require('esbuild').build({
          entryPoints: ['app.js'],
          outfile: 'out.js',
          bundle: true,
          watch: true,
        }).then(result => {
          console.log('watching...')

          setTimeout(() => {
            result.stop()
            console.log('stopped watching')
          }, 10 * 1000)
        })

      go: |
        package main

        import "fmt"
        import "github.com/evanw/esbuild/pkg/api"
        import "os"
        import "time"

        func main() {
          result := api.Build(api.BuildOptions{
            EntryPoints: []string{"app.js"},
            Outfile:     "out.js",
            Bundle:      true,
            Write:       true,
            Watch:       &api.WatchMode{},
          })

          if len(result.Errors) > 0 {
            os.Exit(1)
          }

          fmt.Printf("watching...\n")

          time.Sleep(10 * time.Second)
          result.Stop()
          fmt.Printf("stopped watching\n")
        }

  - p: >
      为了实现可移植性，esbuild 中的监视模式使用轮询而不是特定于操作系统的文件系统 api 来实现的。
      与一次扫描整个目录树的更传统的轮询系统相比，轮询系统被设计为使用相对较少的 CPU。
      仍然会定期扫描文件系统，但每次扫描只检查文件的随机子集，这意味着在更改之后，文件的更改将很
      快被发现，但不一定是立即发现。

  - p: >
      使用当前的启发式方法，大型项目应该每 2 秒完全扫描一次，因此在最坏的情况下，可能需要 2 秒才能注意到变化。
      然而，在注意到变更后，变更的路径会出现在最近变更的路径的短列表中，每次扫描都会检查这些路径，所以对最近
      变更的文件的进一步变更应该几乎立即被注意到。

  - p: >
      请注意，如果你不想使用基于轮询的方法，你可以使用 esbuild 的 [增量构建 API](#incremental) 跟一个
      你选择的文件监听器来实现监听模式。

  - h3: Write

  - p: >
      build API 可以写入文件系统中，也可以返回本应作为内存缓冲区写入的文件。默认情况下 CLI 与 JavaScript API
      写入到文件系统，GO API 不是。使用内存缓冲区：

  - example:
      in:
        app.js: "1 + 2"

      js: |
        let result = require('esbuild').buildSync({
          entryPoints: ['app.js'],
          sourcemap: 'external',
          write: false,
          outdir: 'out',
        })

        for (let out of result.outputFiles) {
          console.log(out.path, out.contents)
        }

      go: |
        package main

        import "fmt"
        import "github.com/evanw/esbuild/pkg/api"
        import "os"

        func main() {
          result := api.Build(api.BuildOptions{
            EntryPoints: []string{"app.js"},
            Sourcemap:   api.SourceMapExternal,
            Write:       false,
            Outdir:      "out",
          })

          if len(result.Errors) > 0 {
            os.Exit(1)
          }

          for _, out := range result.OutputFiles {
            fmt.Printf("%v %v\n", out.Path, out.Contents)
          }
        }

  - h2: 高级配置

  - h3: Allow overwrite

  - p: >
      Enabling this setting allows output files to overwrite input files. It's
      not  enabled by default because doing so means overwriting your source
      code, which can lead to data loss if your code is not checked in. But
      supporting this makes certain workflows easier by avoiding the need for
      a temporary directory. So you can enable this when you want to deliberately
      overwrite your source code:

  - example:
      in:
        app.js: "1 + 2"

      cli: |
        esbuild app.js --outdir=. --allow-overwrite

      js: |
        require('esbuild').buildSync({
          entryPoints: ['app.js'],
          outdir: '.',
          allowOverwrite: true,
        })

      go: |
        package main

        import "github.com/evanw/esbuild/pkg/api"
        import "os"

        func main() {
          result := api.Build(api.BuildOptions{
            EntryPoints:    []string{"app.js"},
            Outdir:         ".",
            AllowOverwrite: true,
          })

          if len(result.Errors) > 0 {
            os.Exit(1)
          }
        }

  - h3: Analyze

  - p: >
      Using the analyze feature generates an easy-to-read report about the contents of your bundle:

  - example:
      install:
        react: '17.0.2'
        react-dom: '17.0.2'

      in:
        example.jsx: |
          import * as React from 'react'
          import * as Server from 'react-dom/server'

          let Greet = () => <h1>Hello, world!</h1>
          console.log(Server.renderToString(<Greet />))

      cli:
        - $: |
            esbuild --bundle example.jsx --outfile=out.js --minify --analyze

        - expect: |
            ...

              out.js                                                                    27.4kb  100.0%
               ├ node_modules/react-dom/cjs/react-dom-server.browser.production.min.js  19.2kb   70.1%
               ├ node_modules/react/cjs/react.production.min.js                          5.9kb   21.5%
               ├ node_modules/object-assign/index.js                                     965b     3.4%
               ├ example.jsx                                                             137b     0.5%
               ├ node_modules/react-dom/server.browser.js                                 50b     0.2%
               └ node_modules/react/index.js                                              50b     0.2%

      js: |
        (async () => {
          let esbuild = require('esbuild')

          let result = await esbuild.build({
            entryPoints: ['example.jsx'],
            outfile: 'out.js',
            minify: true,
            metafile: true,
          })

          let text = await esbuild.analyzeMetafile(result.metafile)
          console.log(text)
        })()

      go: |
        package main

        import "github.com/evanw/esbuild/pkg/api"
        import "fmt"
        import "os"

        func main() {
          result := api.Build(api.BuildOptions{
            EntryPoints:       []string{"example.jsx"},
            Outfile:           "out.js",
            MinifyWhitespace:  true,
            MinifyIdentifiers: true,
            MinifySyntax:      true,
            Metafile:          true,
          })

          if len(result.Errors) > 0 {
            os.Exit(1)
          }

          text := api.AnalyzeMetafile(result.Metafile, api.AnalyzeMetafileOptions{})
          fmt.Printf("%s", text)
        }

  - p: >
      The information shows which input files ended up in each output file as
      well as the percentage of the output file they ended up taking up. If you
      would like additional information, you can enable the "verbose" mode.
      This currently shows the import path from the entry point to each input
      file which tells you why a given input file is being included in the bundle:

  - example:
      install:
        react: '17.0.2'
        react-dom: '17.0.2'

      in:
        example.jsx: |
          import * as React from 'react'
          import * as Server from 'react-dom/server'

          let Greet = () => <h1>Hello, world!</h1>
          console.log(Server.renderToString(<Greet />))

      cli:
        - $: |
            esbuild --bundle example.jsx --outfile=out.js --minify --analyze=verbose

        - expect: |
            ...

              out.js ─────────────────────────────────────────────────────────────────── 27.4kb ─ 100.0%
               ├ node_modules/react-dom/cjs/react-dom-server.browser.production.min.js ─ 19.2kb ── 70.1%
               │  └ node_modules/react-dom/server.browser.js
               │     └ example.jsx
               ├ node_modules/react/cjs/react.production.min.js ───────────────────────── 5.9kb ── 21.5%
               │  └ node_modules/react/index.js
               │     └ example.jsx
               ├ node_modules/object-assign/index.js ──────────────────────────────────── 965b ──── 3.4%
               │  └ node_modules/react-dom/cjs/react-dom-server.browser.production.min.js
               │     └ node_modules/react-dom/server.browser.js
               │        └ example.jsx
               ├ example.jsx ──────────────────────────────────────────────────────────── 137b ──── 0.5%
               ├ node_modules/react-dom/server.browser.js ──────────────────────────────── 50b ──── 0.2%
               │  └ example.jsx
               └ node_modules/react/index.js ───────────────────────────────────────────── 50b ──── 0.2%
                  └ example.jsx

      js: |
        (async () => {
          let esbuild = require('esbuild')

          let result = await esbuild.build({
            entryPoints: ['example.jsx'],
            outfile: 'out.js',
            minify: true,
            metafile: true,
          })

          let text = await esbuild.analyzeMetafile(result.metafile, {
            verbose: true,
          })
          console.log(text)
        })()

      go: |
        package main

        import "github.com/evanw/esbuild/pkg/api"
        import "fmt"
        import "os"

        func main() {
          result := api.Build(api.BuildOptions{
            EntryPoints:       []string{"example.jsx"},
            Outfile:           "out.js",
            MinifyWhitespace:  true,
            MinifyIdentifiers: true,
            MinifySyntax:      true,
            Metafile:          true,
          })

          if len(result.Errors) > 0 {
            os.Exit(1)
          }

          text := api.AnalyzeMetafile(result.Metafile, api.AnalyzeMetafileOptions{
            Verbose: true,
          })
          fmt.Printf("%s", text)
        }

  - p: >
      This analysis is just a visualization of the information that can be found
      in the [metafile](#metafile). If this analysis doesn't exactly suit your
      needs, you are welcome to build your own visualization using the information
      in the metafile.

  - p: >
      Note that this formatted analysis summary is intended for humans, not
      machines. The specific formatting may change over time which will likely
      break any tools that try to parse it. You should not write a tool to parse
      this data. You should be using the information in the [JSON metadata file](#metafile)
      instead. Everything in this visualization is derived from the JSON metadata
      so you are not losing out on any information by not parsing esbuild's
      formatted analysis summary.

  - h3: 资源名称

  - p: >
      Using the analyze feature generates an easy-to-read report about the contents of your bundle:

  - example:
      install:
        react: "17.0.2"
        react-dom: "17.0.2"

      in:
        example.jsx: |
          import * as React from 'react'
          import * as Server from 'react-dom/server'

          let Greet = () => <h1>Hello, world!</h1>
          console.log(Server.renderToString(<Greet />))

      cli:
        - $: |
            esbuild --bundle example.jsx --outfile=out.js --minify --analyze

        - expect: |
            ...

              out.js                                                                    27.4kb  100.0%
               ├ node_modules/react-dom/cjs/react-dom-server.browser.production.min.js  19.2kb   70.2%
               ├ node_modules/react/cjs/react.production.min.js                          5.9kb   21.5%
               ├ node_modules/object-assign/index.js                                     962b     3.4%
               ├ example.jsx                                                             137b     0.5%
               ├ node_modules/react-dom/server.browser.js                                 50b     0.2%
               └ node_modules/react/index.js                                              50b     0.2%

      js: |
        (async () => {
          let esbuild = require('esbuild')

          let result = await esbuild.build({
            entryPoints: ['example.jsx'],
            outfile: 'out.js',
            minify: true,
            metafile: true,
          })

          let text = await esbuild.analyzeMetafile(result.metafile)
          console.log(text)
        })()

      go: |
        package main

        import "github.com/evanw/esbuild/pkg/api"
        import "fmt"
        import "os"

        func main() {
          result := api.Build(api.BuildOptions{
            EntryPoints:       []string{"example.jsx"},
            Outfile:           "out.js",
            MinifyWhitespace:  true,
            MinifyIdentifiers: true,
            MinifySyntax:      true,
            Metafile:          true,
          })

          if len(result.Errors) > 0 {
            os.Exit(1)
          }

          text := api.AnalyzeMetafile(result.Metafile, api.AnalyzeMetafileOptions{})
          fmt.Printf("%s", text)
        }

  - p: >
      The information shows which input files ended up in each output file as
      well as the percentage of the output file they ended up taking up. If you
      would like additional information, you can enable the "verbose" mode.
      This currently shows the import path from the entry point to each input
      file which tells you why a given input file is being included in the bundle:

  - example:
      install:
        react: "17.0.2"
        react-dom: "17.0.2"

      in:
        example.jsx: |
          import * as React from 'react'
          import * as Server from 'react-dom/server'

          let Greet = () => <h1>Hello, world!</h1>
          console.log(Server.renderToString(<Greet />))

      cli:
        - $: |
            esbuild --bundle example.jsx --outfile=out.js --minify --analyze=verbose

        - expect: |
            ...

              out.js ─────────────────────────────────────────────────────────────────── 27.4kb ─ 100.0%
               ├ node_modules/react-dom/cjs/react-dom-server.browser.production.min.js ─ 19.2kb ── 70.2%
               │  └ node_modules/react-dom/server.browser.js
               │     └ example.jsx
               ├ node_modules/react/cjs/react.production.min.js ───────────────────────── 5.9kb ── 21.5%
               │  └ node_modules/react/index.js
               │     └ example.jsx
               ├ node_modules/object-assign/index.js ──────────────────────────────────── 962b ──── 3.4%
               │  └ node_modules/react-dom/cjs/react-dom-server.browser.production.min.js
               │     └ node_modules/react-dom/server.browser.js
               │        └ example.jsx
               ├ example.jsx ──────────────────────────────────────────────────────────── 137b ──── 0.5%
               ├ node_modules/react-dom/server.browser.js ──────────────────────────────── 50b ──── 0.2%
               │  └ example.jsx
               └ node_modules/react/index.js ───────────────────────────────────────────── 50b ──── 0.2%
                  └ example.jsx

      js: |
        (async () => {
          let esbuild = require('esbuild')

          let result = await esbuild.build({
            entryPoints: ['example.jsx'],
            outfile: 'out.js',
            minify: true,
            metafile: true,
          })

          let text = await esbuild.analyzeMetafile(result.metafile, {
            verbose: true,
          })
          console.log(text)
        })()

      go: |
        package main

        import "github.com/evanw/esbuild/pkg/api"
        import "fmt"
        import "os"

        func main() {
          result := api.Build(api.BuildOptions{
            EntryPoints:       []string{"example.jsx"},
            Outfile:           "out.js",
            MinifyWhitespace:  true,
            MinifyIdentifiers: true,
            MinifySyntax:      true,
            Metafile:          true,
          })

          if len(result.Errors) > 0 {
            os.Exit(1)
          }

          text := api.AnalyzeMetafile(result.Metafile, api.AnalyzeMetafileOptions{
            Verbose: true,
          })
          fmt.Printf("%s", text)
        }

  - p: >
      This analysis is just a visualization of the information that can be found
      in the [metafile](#metafile). If this analysis doesn't exactly suit your
      needs, you are welcome to build your own visualization using the information
      in the metafile.

  - p: >
      Note that this formatted analysis summary is intended for humans, not
      machines. The specific formatting may change over time which will likely
      break any tools that try to parse it. You should not write a tool to parse
      this data. You should be using the information in the [JSON metadata file](#metafile)
      instead. Everything in this visualization is derived from the JSON metadata
      so you are not losing out on any information by not parsing esbuild's
      formatted analysis summary.

  - h3: 资源名称

  - p: >
      当 [loader](#loader) 设置为 [`file`](/content-types/#external-file) 时，该配置项
      控制额外生成的文件名称。它使用带有占位符的模板来配置输出路径，当生成输出路径时，占位符将被特定
      于文件的值替换。例如，例如，指定 <code>assets/<wbr>[name]-<wbr>[hash]</code> 的资源名
      称模板，将所有资源放入输出目录内名为 `assets` 的子目录中，并在文件名中包含资产的内容哈希。
      像这样使用它：

  - example:
      in:
        app.js: 'import "./file.png"'
        file.png: "a png file"

      cli: |
        esbuild app.js --asset-names=assets/[name]-[hash] --loader:.png=file --bundle --outdir=out

      js: |
        require('esbuild').buildSync({
          entryPoints: ['app.js'],
          assetNames: 'assets/[name]-[hash]',
          loader: { '.png': 'file' },
          bundle: true,
          outdir: 'out',
        })

      go: |
        package main

        import "github.com/evanw/esbuild/pkg/api"
        import "os"

        func main() {
          result := api.Build(api.BuildOptions{
            EntryPoints: []string{"app.js"},
            AssetNames:  "assets/[name]-[hash]",
            Loader: map[string]api.Loader{
              ".png": api.LoaderFile,
            },
            Bundle: true,
            Outdir: "out",
          })

          if len(result.Errors) > 0 {
            os.Exit(1)
          }
        }

  - p: >
<<<<<<< HEAD
      在资源路径模板中有三个可用占位符：
=======
      There are four placeholders that can be used in asset path templates:
>>>>>>> 2e131b091e6a1dd99b9a331f6f3c75534bf796be

  - ul:
      - >
        `[dir]`
        <p>
        This is the relative path from the directory containing the asset file to
        the [outbase](#outbase) directory. Its purpose is to help asset output
        paths look more aesthetically pleasing by mirroring the input directory
        structure inside of the output directory.
        </p>

      - >
        `[name]`
        <p>
        这是不带拓展名的原始资源文件名称。例如，如果一个资源原来名为 `image.png`，然后模板中的
        `[name]` 就会被 `image` 替换。没有必要使用该占位符；它的存在只是为了提供对人类友好的资源
        名称，使调试更容易。
        </p>

      - >
        `[hash]`
        <p>
        这是资源的内容哈希，可以避免命名冲突。例如，你的代码可能会导入 <code>components/<wbr>button/<wbr>icon.png</code>
        和 <code>components/<wbr>select/<wbr>icon.png</code> ，在这种情况下，
        你需要使用哈希值来区分这两个都命名为 icon 的资源。
        </p>

    - >
      `[ext]`
      <p>
      This is the file extension of the asset (i.e. everything after the end of
      the last `.` character). It can be used to put different types of assets
      into different directories. For example, <code>--asset-names=<wbr>assets/<wbr>[ext]/<wbr>[name]-[hash]</code>
      might write out an asset named `image.png` as <code>assets/<wbr>png/<wbr>image-CQFGD2NG.png</code>.
      </p>

  - p: >
      资源路径模板不需要包含文件拓展名。资源的原始拓展名将会在模板替换完成后添加到输出路径尾部。

  - p: >
      该配置项与 [chunk 名称](#chunk-names) 与 [入口名称](#entry-names) 相似。

  - h3: Banner

  - p: >
      使用它可以在生成的 JavaScript 和 CSS 文件的开头插入任意字符串。这一般被用来插入注释：

  - example:
      in:
        app.js: "1 + 2"

      cli: |
        esbuild app.js --banner:js=//comment --banner:css=/*comment*/

      js: |
        require('esbuild').buildSync({
          entryPoints: ['app.js'],
          banner: {
            js: '//comment',
            css: '/*comment*/',
          },
          outfile: 'out.js',
        })

      go: |
        package main

        import "github.com/evanw/esbuild/pkg/api"
        import "os"

        func main() {
          result := api.Build(api.BuildOptions{
            EntryPoints: []string{"app.js"},
            Banner: map[string]string{
              "js":  "//comment",
              "css": "/*comment*/",
            },
          })

          if len(result.Errors) > 0 {
            os.Exit(1)
          }
        }

  - p: >
      这与 [footer](#footer) 很相似，只不过它是在末尾插入而不是开头。

  - p: >
      请注意如果你在 CSS 文件中插入了一段非注释代码，CSS 会忽略 non-`@import` 规则后面的 `@import`
      规则（`@charset` 规则除外），所以使用 Banner 来注入 CSS 规则可能会意外地禁用外部样式表的导入。

  - h3: Charset

  - p: >
      默认情况下 esbuild 的输出是 ASCII-only。任何非 ASCII 字符都使用反斜杠转义序列进行转义。
      原因是默认情况下，非 ASCII 字符会被浏览器误读，导致混淆。你必须在你的 HTML 文件中明确添加
      <code>&lt;meta <wbr>charset=<wbr>"utf-8"&gt;</code>，或者为他提供正确的 <code>Content-<wbr>Type</code>
      头，以便浏览器不会损坏代码。另一个原因是，非 ASCII 字符会显著 [降低浏览器解析器的速度](https://v8.dev/blog/scanner)。
      然而，使用转义序列会使生成的输出稍微大一些，也会使其更难阅读。

  - p: >
      如果你想让 esbuild 在不使用转义序列的情况下打印原始字符，并且你已经确保浏览器将你的代码解释为 UTF-8，
      你可以通过设置字符集来禁用字符转义：

  - example:
      cli:
        - $: |
            echo 'let π = Math.PI' | esbuild
        - expect: |
            let \u03C0 = Math.PI;
        - $: |
            echo 'let π = Math.PI' | esbuild --charset=utf8
        - expect: |
            let π = Math.PI;

      js:
        - $: |
            let js = 'let π = Math.PI'
        - $: |
            require('esbuild').transformSync(js)
        - expect: |
            {
              code: 'let \\u03C0 = Math.PI;\n',
              map: '',
              warnings: []
            }
        - $: |
            require('esbuild').transformSync(js, {
              charset: 'utf8',
            })
        - expect: |
            {
              code: 'let π = Math.PI;\n',
              map: '',
              warnings: []
            }

      go: |
        package main

        import "fmt"
        import "github.com/evanw/esbuild/pkg/api"

        func main() {
          js := "let π = Math.PI"

          result1 := api.Transform(js, api.TransformOptions{})

          if len(result1.Errors) == 0 {
            fmt.Printf("%s", result1.Code)
          }

          result2 := api.Transform(js, api.TransformOptions{
            Charset: api.CharsetUTF8,
          })

          if len(result2.Errors) == 0 {
            fmt.Printf("%s", result2.Code)
          }
        }

  - p: >
      一些警告：

  - ul:
      - >
        <p>
        这还不会转义嵌入在正则表达式中的非 ASCII 字符。这是因为 esbuild 目前根本不解析正则表达式的内容。
        尽管有这个限制，但还是添加了这个标志，因为它对于不包含这种情况的代码仍然有用。
        </p>
      - >
        <p>
        此标志不适用于注释。我认为在注释中保留非 ASCII 数据应该没有问题，因为即使编码是错误的，
        运行时环境也应该完全忽略所有注释的内容。例如，[V8 的博文](https://v8.dev/blog/scanner) 
        提到了一种优化，可以完全避免对评论内容进行解码。esbuild 会剔除除与许可相关的所有注释。
        </p>
      - >
        <p>
        此选项同时适用于所有输出文件类型（JavaScript、CSS 和 JSON）。因此，如果你配置你的 web 
        服务器发送正确的 <code>Content-<wbr>Type</code> 头，并希望使用 UTF-8 字符集，
        请确保你的 web 服务器配置为将 `.js` 和 `.css`文件都作为 UTF-8 处理。
        </p>

  - h3: Chunk 名称

  - p: >
      此选项控制在启用 [代码分割](#splitting) 时自动生成的共享代码块的文件名。
      它使用带有占位符的模板来配置输出路径，当生成输出路径时，占位符将被特定于 chunk 的值替换。
      例如，指定 <code>chunks/<wbr>[name]-<wbr>[hash]</code> 的 chunk 名称模板，
      将所有生成的块放入输出目录内的名为 `chunks` 的子目录中，并在文件名中包含 chunk 的内容哈希。
      像这样使用它：

  - example:
      in:
        app.js: "1 + 2"

      cli: |
        esbuild app.js --chunk-names=chunks/[name]-[hash] --bundle --outdir=out --splitting --format=esm

      js: |
        require('esbuild').buildSync({
          entryPoints: ['app.js'],
          chunkNames: 'chunks/[name]-[hash]',
          bundle: true,
          outdir: 'out',
          splitting: true,
          format: 'esm',
        })

      go: |
        package main

        import "github.com/evanw/esbuild/pkg/api"
        import "os"

        func main() {
          result := api.Build(api.BuildOptions{
            EntryPoints: []string{"app.js"},
            ChunkNames:  "chunks/[name]-[hash]",
            Bundle:      true,
            Outdir:      "out",
            Splitting:   true,
            Format:      api.FormatESModule,
          })

          if len(result.Errors) > 0 {
            os.Exit(1)
          }
        }

  - p: >
<<<<<<< HEAD
      在 chunk 路径模板中有两个可用占位符：
=======
      There are three placeholders that can be used in chunk path templates:
>>>>>>> 2e131b091e6a1dd99b9a331f6f3c75534bf796be

  - ul:
      - >
        `[name]`
        <p>
        目前这将始终是 `chunk`，尽管这个占位符在将来的版本中可能会有额外的值。
        </p>

      - >
        `[hash]`
        <p>
        这是 chunk 的内容哈希。在生成多个共享代码块的情况下，内容哈希是区分不同 chunk 的必要条件。
        </p>

    - >
      `[ext]`
      <p>
      This is the file extension of the chunk (i.e. everything after the end of
      the last `.` character). It can be used to put different types of chunks
      into different directories. For example, <code>--chunk-names=<wbr>chunks/<wbr>[ext]/<wbr>[name]-[hash]</code>
      might write out a chunk as <code>chunks/<wbr>css/<wbr>chunk-DEFJT7KY.css</code>.
      </p>

  - p: >
      chunk 路径模板不需要包括一个文件拓展名。在模板替换之后，为适当内容类型配置的 
      [out extension](#out-extension) 将自动添加到输出路径的末尾。

  - p: >
      注意，这个配置项只控制自动生成的共享代码块的名称。它 _不_ 控制与入口点相关的输出文件的名称。
      它们的名称目前是从相对于 [outbase](#outbase) 目录的原始入口点文件的路径确定的，且无法更改此行为。
      将来会添加一个额外的API选项，允许你更改入口点输出文件的文件名。

  - p: >
      该配置项与 [资源名称](#asset-names) 和 [入口名称](#entry-names) 相似。

  - h3: 颜色

  - p: >
      该配置项启用或禁用 esbuild 写入终端中的 stderr 文件描述符中的错误和警告消息中的颜色。
      默认情况下，如果 stderr 是一个 TTY 会话，颜色将自动启用，否则将自动禁用。
      esbuild 中有颜色的输出就像是这样：

  - pre.raw: |
      <span class="color-yellow">▲ <span class="bg-yellow">[<span class="color-black">WARNING</span>]</span></span> <b>The "typeof" operator will never evaluate to "null"</b>

          example.js:2:16:
        <span class="color-dim">    2 │ log(typeof x == </span><span class="color-green">"null"</span><span class="color-dim">)</span>
        <span class="color-dim">      ╵                 </span><span class="color-green">~~~~~~</span>

        The expression "typeof x" actually evaluates to "object" in JavaScript, not "null". You need to
        use "x === null" to test for null.

      <span class="color-red">✘ <span class="bg-red">[<span class="color-white">ERROR</span>]</span></span> <b>Could not resolve "logger"</b>

          example.js:1:16:
        <span class="color-dim">    1 │ import log from </span><span class="color-green">"logger"</span>
        <span class="color-dim">      ╵                 </span><span class="color-green">~~~~~~~~</span>

        You can mark the path "logger" as external to exclude it from the bundle, which will remove this
        error.

      1 warning and 1 error

  - p: >
      将 color 设置为 `true` 可以强制启用有颜色的输出。
      如果你自己把 esbuild 的 stderr 输出管道到 TTY 中，这是很有用的：

  - example:
      cli: |
        echo 'typeof x == "null"' | esbuild --color=true 2> stderr.txt

      js: |
        let js = 'typeof x == "null"'
        require('esbuild').transformSync(js, {
          color: true,
        })

      go: |
        package main

        import "fmt"
        import "github.com/evanw/esbuild/pkg/api"

        func main() {
          js := "typeof x == 'null'"

          result := api.Transform(js, api.TransformOptions{
            Color: api.ColorAlways,
          })

          if len(result.Errors) == 0 {
            fmt.Printf("%s", result.Code)
          }
        }

  - p: >
      可以将 color 设置为 `false` 以禁用。

  - h3: Conditions

  - p: >
      此特性控制 `package.json` 中的 `exports` 字段是如何被解析的。通过 conditions 设置可以添加自定义条件。
      你可以指定任意数量的包，这些包的含义完全取决于包的作者。Node 目前只认可了推荐使用的 `development` 和
      `production` 定制条件。下面是一个添加自定义条件 `custom1` 和 `custom2` 的示例：

  - example:
      in:
        src/app.js: 'import "pkg"'
        src/node_modules/pkg/package.json: '{ "exports": { "custom1": "./foo.js" } }'
        src/node_modules/pkg/foo.js: "console.log(123)"

      cli: |
        esbuild src/app.js --bundle --conditions=custom1,custom2

      js: |
        require('esbuild').buildSync({
          entryPoints: ['src/app.js'],
          bundle: true,
          conditions: ['custom1', 'custom2'],
        })

      go: |
        package main

        import "github.com/evanw/esbuild/pkg/api"
        import "os"

        func main() {
          result := api.Build(api.BuildOptions{
            EntryPoints: []string{"src/app.js"},
            Bundle:      true,
            Conditions:  []string{"custom1", "custom2"},
          })

          if len(result.Errors) > 0 {
            os.Exit(1)
          }
        }

  - h4: conditions 是如何工作的

  - p: >
      Conditions 允许你在不同的情况下将相同的导入路径重定向到不同的文件位置。
      包含条件和路径的重定向映射存储在包的 `package.json` 的 exports 字段中。
      例如，在使用 `import` 与 `require` 条件下会重新映射 `require('pkg/foo')` 到 `pkg/required.cjs`，
      `import 'pkg/foo'` 到 `pkg/imported.mjs`：

  - pre.json: |
      {
        "name": "pkg",
        "exports": {
          "./foo": {
            "import": "./imported.mjs",
            "require": "./required.cjs",
            "default": "./fallback.js"
          }
        }
      }

  - p: >
      Conditions 按照它们在 JSON 文件中出现的顺序进行检查。
      所以上面的例子有点像这样：

  - pre.js: |
      if (importPath === './foo') {
        if (conditions.has('import')) return './imported.mjs'
        if (conditions.has('require')) return './required.cjs'
        return './fallback.js'
      }

  - p: >
      默认情况下，esbuild 有五种内置特定行为，并且不能被禁用：
  - ul:
      - >
        `default`
        <p>
        该条件总处于激活状态。它的目的是放在最后，让你在没有其他条件应用时提供兜底。
        </p>
      - >
        `import`
        <p>
        该条件仅在通过 ESM `import` 声明或者 `import()` 表达式导入路径时生效。
        可以用来提供特定于 ESM 的代码。
        </p>
      - >
        `require`
        <p>
        该条件仅在通过 CommonJS `require()` 调用导入路径时生效。
        可以用来提供特定于 CommonJS 的代码。
        </p>
      - >
        `browser`
        <p>
        该条件仅在 esbuild 的 [platform](#platform) 设置为 `browser` 有效。
        可以用来提供特定于浏览器的代码。
        </p>
      - >
        `node`
        <p>
        该条件仅在 esbuild 的 [platform](#platform) 设置为 `node` 有效。
        可以用来提供特定于 node 的代码。
        </p>

  - p: >
      请注意当你使用 `require` 与 `import` 条件时，_你的包可能会在 bundle 过程中多次终止！_
      这是一个微妙的问题，它可能会由于代码状态的重复副本而导致 bug，此外还会使结果包膨胀。
      这通常被称为 [dual package hazard](https://nodejs.org/docs/latest/api/packages.html#packages_dual_package_hazard)。
      避免这种情况的主要方法是将所有代码都放在 `require` 条件中，而 `import` 条件只是一个轻包装器，
      它调用包上的 `require` ，并使用 ESM 语法重新导出包。

<<<<<<< HEAD
  - h3: 入口名称
=======
  - h3: Drop

  - p: >
      This tells esbuild to edit your source code before building to drop
      certain constructs. There are currently two possible things that can be
      dropped:

  - ul:
    - >
      `debugger`
      <p>
      Passing this flag causes all [`debugger` statements](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/debugger)
      to be removed from the output. This is similar to the `drop_debugger: true`
      flag available in the popular [UglifyJS](https://github.com/mishoo/UglifyJS)
      and [Terser](https://github.com/terser/terser) JavaScript minifiers.
      </p>
      <p>
      JavaScript's `debugger` statements cause the active debugger to treat the
      statement as an automatically-configured breakpoint. Code containing this
      statement will automatically be paused when the debugger is open. If no
      debugger is open, the statement does nothing. Dropping these statements
      from your code just prevents the debugger from automatically stopping
      when your code runs.
      </p>
      <p>
      You can drop `debugger` statements like this:
      </p>

  - example:
      in:
        app.js: 'debugger'

      cli: |
        esbuild app.js --drop:debugger

      js: |
        require('esbuild').buildSync({
          entryPoints: ['app.js'],
          drop: ['debugger'],
        })

      go: |
        package main

        import "github.com/evanw/esbuild/pkg/api"
        import "os"

        func main() {
          result := api.Build(api.BuildOptions{
            EntryPoints: []string{"app.js"},
            Drop:        api.DropDebugger,
          })

          if len(result.Errors) > 0 {
            os.Exit(1)
          }
        }

  - ul:
    - >
      `console`
      <p>
      Passing this flag causes all [`console` API calls](https://developer.mozilla.org/en-US/docs/Web/API/console#methods)
      to be removed from the output. This is similar to the `drop_console: true`
      flag available in the popular [UglifyJS](https://github.com/mishoo/UglifyJS)
      and [Terser](https://github.com/terser/terser) JavaScript minifiers.
      </p>
      <p>
      WARNING: Using this flag can introduce bugs into your code! This flag
      removes the entire call expression including all call arguments. If any
      of those arguments had important side effects, using this flag will
      change the behavior of your code. Be very careful when using this flag.
      </p>
      <p>
      If you want to remove console API calls without removing the arguments
      with side effects (so you do not introduce bugs), you should mark the
      relevant API calls as [pure](#pure) instead. For example, you can mark
      `console.log` as pure using <code>--pure:<wbr>console.log</code>. This
      will cause these API calls to be removed safely when minification is
      enabled.
      </p>
      <p>
      You can drop `console` API calls like this:
      </p>

  - example:
      in:
        app.js: 'console.log()'

      cli: |
        esbuild app.js --drop:console

      js: |
        require('esbuild').buildSync({
          entryPoints: ['app.js'],
          drop: ['console'],
        })

      go: |
        package main

        import "github.com/evanw/esbuild/pkg/api"
        import "os"

        func main() {
          result := api.Build(api.BuildOptions{
            EntryPoints: []string{"app.js"},
            Drop:        api.DropConsole,
          })

          if len(result.Errors) > 0 {
            os.Exit(1)
          }
        }

  - h3: Entry names
>>>>>>> 2e131b091e6a1dd99b9a331f6f3c75534bf796be

  - p: >
      该配置项控制与每一个入口文件相对应的输出文件的名称。它使用带有占位符的模板来配置输出路径，
      占位符会在输出路径生成后被特定的值替换。例如，指定一个 <code>[dir]/<wbr>[name]-<wbr>[hash]</code> 的入口名称模板，
      其在文件名中包含输出文件的哈希值，并且将文件置于输出目录中，也可能在子目录下
      （查看下面关于 `[dir]` 的更多信息），像这样使用它：

  - example:
      in:
        src/main-app/app.js: "1 + 2"

      cli: |
        esbuild src/main-app/app.js --entry-names=[dir]/[name]-[hash] --outbase=src --bundle --outdir=out

      js: |
        require('esbuild').buildSync({
          entryPoints: ['src/main-app/app.js'],
          entryNames: '[dir]/[name]-[hash]',
          outbase: 'src',
          bundle: true,
          outdir: 'out',
        })

      go: |
        package main

        import "github.com/evanw/esbuild/pkg/api"
        import "os"

        func main() {
          result := api.Build(api.BuildOptions{
            EntryPoints: []string{"src/main-app/app.js"},
            EntryNames:  "[dir]/[name]-[hash]",
            Outbase:     "src",
            Bundle:      true,
            Outdir:      "out",
          })

          if len(result.Errors) > 0 {
            os.Exit(1)
          }
        }

  - p: >
<<<<<<< HEAD
      在入口路径模板中有三个可用占位符：
=======
      There are four placeholders that can be used in entry path templates:
>>>>>>> 2e131b091e6a1dd99b9a331f6f3c75534bf796be

  - ul:
      - >
        `[dir]`
        <p>
        这是从包含输入入口点文件的目录到 [outbase](#outbase) 目录的相对路径。
        它的目的是帮助你避免不同子目录中命名相同的入口点之间的冲突。
        </p>
        <p>
        例如，如果有两个入口点
        <code>src/<wbr>pages/<wbr>home/<wbr>index.ts</code> 与
        <code>src/<wbr>pages/<wbr>about/<wbr>index.ts</code>，outbase 文件夹为 `src`，
        入口名称模板为 `[dir]/[name]`，输出文件夹将会包含 <code>pages/<wbr>home/<wbr>index.js</code> 与
        <code>pages/<wbr>about/<wbr>index.js</code>。如果入口名称模板仅被设置为 `[name]`，打包将会失败，
        因为在输出文件夹中包含两个相同输出路径的输出文件。
        </p>

      - >
        `[name]`
        <p>
        这是不带拓展名的原始入口文件名称。例如，如果入口文件名为 `app.js`，那么模板中的 `[name]` 将会被
        替换为 `app`。
        </p>

      - >
        `[hash]`
        <p>
        这是输出文件的内容哈希，可以用来最大化利用浏览器缓存。在你的入口点名称中添加 `[hash]`，
        这就意味着 esbuild 会计算与相应输出文件有关系的所有内容的哈希值（如果 [代码分隔](#splitting) 
        激活状态，也包括他导入的任何输出文件）。当且仅当与该输出文件相关的任何输入文件被更改时哈希值才会发生变化。
        </p>
        <p>
        之后，你可以让 web 服务器告诉浏览器永久缓存这些文件（你可以说它们从现在起过期很长一段时间，比如一年）。
        你可以使用 [metafile](#metafile) 中的信息来确定哪个输出文件路径对应于哪个输入入口点，这样你就知道要在
        `<script>` 标签中引入哪个路径。
        </p>

    - >
      `[ext]`
      <p>
      This is the file extension that the entry point file will be written out to
      (i.e. the [out extension](#out-extension) setting, not the original file
      extension). It can be used to put different types of entry points into different
      directories. For example, <code>--entry-names=<wbr>entries/<wbr>[ext]/<wbr>[name]</code>
      might write the output file for `app.ts` to <code>entries/<wbr>js/<wbr>app.js</code>.
      </p>

  - p: >
      入口路径模板不需要包含一个文件拓展名。根据文件类型，适当的 [out 扩展名](#out-extension) 将在模板替换
      后自动添加到输出路径的末尾。

  - p: >
      该配置项与 [asset names](#asset-names) 和 [chunk names](#chunk-names) 相似。

  - h3: Footer

  - p: >
      使用它可以在生成的 JavaScript 和 CSS 文件的末尾插入任意字符串。这通常用于插入注释：

  - example:
      in:
        app.js: "1 + 2"

      cli: |
        esbuild app.js --footer:js=//comment --footer:css=/*comment*/

      js: |
        require('esbuild').buildSync({
          entryPoints: ['app.js'],
          footer: {
            js: '//comment',
            css: '/*comment*/',
          },
          outfile: 'out.js',
        })

      go: |
        package main

        import "github.com/evanw/esbuild/pkg/api"
        import "os"

        func main() {
          result := api.Build(api.BuildOptions{
            EntryPoints: []string{"app.js"},
            Footer: map[string]string{
              "js":  "//comment",
              "css": "/*comment*/",
            },
          })

          if len(result.Errors) > 0 {
            os.Exit(1)
          }
        }

  - p: >
      这与 [banner](#banner) 很相似，只不过它是在开头插入而不是末尾。

  - h3: 全局名称

  - p: >
      该配置项仅在 [format](#format) 设置为 `iife`（代表立即执行函数表达式）时有效。
      它设置了全局变量的名称，用于存储从入口点导出的文件：

  - example:
      cli: |
        echo 'module.exports = "test"' | esbuild --format=iife --global-name=xyz

      js: |
        let js = 'module.exports = "test"'
        require('esbuild').transformSync(js, {
          format: 'iife',
          globalName: 'xyz',
        })

      go: |
        package main

        import "fmt"
        import "github.com/evanw/esbuild/pkg/api"

        func main() {
          js := "module.exports = 'test'"

          result := api.Transform(js, api.TransformOptions{
            Format:     api.FormatIIFE,
            GlobalName: "xyz",
          })

          if len(result.Errors) == 0 {
            fmt.Printf("%s", result.Code)
          }
        }

  - p: >
      为 `iife` 格式指定全局名称将会生成下面的代码：

  - pre.js: |
      var xyz = (() => {
        ...
        var require_stdin = __commonJS((exports, module) => {
          module.exports = "test";
        });
        return require_stdin();
      })();

  - p: >
      全局名称也可以是一个复合属性表达式，在这种情况下，esbuild 将生成一个具有该属性的全局变量。
      冲突的现有全局变量将不会被覆盖。这可以用来实现“命名空间”，其中多个独立脚本将它们的导出添加到同一个全局对象中。
      示例：

  - example:
      cli: |
        echo 'module.exports = "test"' | esbuild --format=iife --global-name='example.versions["1.0"]'

      js: |
        let js = 'module.exports = "test"'
        require('esbuild').transformSync(js, {
          format: 'iife',
          globalName: 'example.versions["1.0"]',
        })

      go: |
        package main

        import "fmt"
        import "github.com/evanw/esbuild/pkg/api"

        func main() {
          js := "module.exports = 'test'"

          result := api.Transform(js, api.TransformOptions{
            Format:     api.FormatIIFE,
            GlobalName: `example.versions["1.0"]`,
          })

          if len(result.Errors) == 0 {
            fmt.Printf("%s", result.Code)
          }
        }

  - p: >
      上面使用的复合全局名称生成的代码如下：

  - pre.js: |
      var example = example || {};
      example.versions = example.versions || {};
      example.versions["1.0"] = (() => {
        ...
        var require_stdin = __commonJS((exports, module) => {
          module.exports = "test";
        });
        return require_stdin();
      })();

  - h3: Ignore annotations

  - p: >
      Since JavaScript is a dynamic language, identifying unused code is
      sometimes very difficult for a compiler, so the community has developed
      certain annotations to help tell compilers what code should be considered
      side-effect free and available for removal. Currently there are two forms
      of side-effect annotations that esbuild supports:

  - ul:
      - >
        <p>
        Inline `/* @__PURE__ */` comments before function calls tell esbuild that
        the function call can be removed if the resulting value isn't used. See
        the [pure](#pure) API option for more information.
        </p>

      - >
        <p>
        The `sideEffects` field in `package.json` can be used to tell esbuild
        which files in your package can be removed if all imports from that
        file end up being unused. This is a convention from Webpack and many
        libraries published to npm already have this field in their package
        definition. You can learn more about this field in
        [Webpack's documentation](https://webpack.js.org/guides/tree-shaking/)
        for this field.
        </p>

  - p: >
      These annotations can be problematic because the compiler depends
      completely on developers for accuracy, and developers occasionally
      publish packages with incorrect annotations. The `sideEffects` field is
      particularly error-prone for developers because by default it causes all
      files in your package to be considered dead code if no imports are used.
      If you add a new file containing side effects and forget to update that
      field, your package will likely break when people try to bundle it.

  - p: >
      This is why esbuild includes a way to ignore side-effect annotations.
      You should only enable this if you encounter a problem where the bundle
      is broken because necessary code was unexpectedly removed from the bundle:

  - example:
      in:
        app.js: "1 + 2"

      cli: |
        esbuild app.js --bundle --ignore-annotations

      js: |
        require('esbuild').buildSync({
          entryPoints: ['app.js'],
          bundle: true,
          ignoreAnnotations: true,
          outfile: 'out.js',
        })

      go: |
        package main

        import "github.com/evanw/esbuild/pkg/api"
        import "os"

        func main() {
          result := api.Build(api.BuildOptions{
            EntryPoints:       []string{"app.js"},
            Bundle:            true,
            IgnoreAnnotations: true,
          })

          if len(result.Errors) > 0 {
            os.Exit(1)
          }
        }

  - p: >
      Enabling this means esbuild will no longer respect `/* @__PURE__ */`
      comments or the `sideEffects` field. It will still do automatic
      [tree shaking](#tree-shaking) of unused imports, however, since that doesn't rely on
      annotations from developers. Ideally this flag is only a temporary
      workaround. You should report these issues to the maintainer of the
      package to get them fixed since they indicate a problem with the package
      and they will likely trip up other people too.

  - h3: 增量

  - p: >
      如果用例使用相同的选项重复调用 esbuild 的 [build API](#build-api)，你可能想要使用这个API。
      例如，如果你正在实现文件监听服务，这是很有用的。
      增量构建比常规构建更有效，因为一些数据被缓存，如果原始文件自上次构建以来没有更改，则可以重用这些数据。
      增量构建 API 目前使用两种形式的缓存：

  - ul:
      - >
        <p>
        文件存储在内存中，如果文件 metadata 自上次构建以来没有更改，则不会从文件系统中重新读取文件。
        此优化仅适用于文件系统路径。它不适用于由 [插件](/plugins/) 创建的虚拟模块。
        </p>

      - >
        <p>
        解析后的 [ASTs](https://en.wikipedia.org/wiki/Abstract_syntax_tree) 存储在内存中，
        如果文件内容自上次构建以来没有更改，则可以避免重新解析 AST。
        除了文件系统模块之外，这个优化还适用于插件创建的虚拟模块，只要虚拟模块路径保持不变。
        </p>

  - p: >
      下面是如何进行增量构建：

  - example:
      in:
        app.js: "1 + 2"

      js: |
        async function example() {
          let result = await require('esbuild').build({
            entryPoints: ['app.js'],
            bundle: true,
            outfile: 'out.js',
            incremental: true,
          })

          // Call "rebuild" as many times as you want
          for (let i = 0; i < 5; i++) {
            let result2 = await result.rebuild()
          }

          // Call "dispose" when you're done to free up resources.
          result.rebuild.dispose()
        }

        example()

      go: |
        package main

        import "github.com/evanw/esbuild/pkg/api"
        import "os"

        func main() {
          result := api.Build(api.BuildOptions{
            EntryPoints: []string{"app.js"},
            Bundle:      true,
            Outfile:     "out.js",
            Incremental: true,
          })
          if len(result.Errors) > 0 {
            os.Exit(1)
          }

          // Call "Rebuild" as many times as you want
          for i := 0; i < 5; i++ {
            result2 := result.Rebuild()
            if len(result2.Errors) > 0 {
              os.Exit(1)
            }
          }
        }

  - h3: JSX

  - p: >
      This option tells esbuild what to do about JSX syntax. You can either have
      esbuild transform JSX to JS (the default) or preserve the JSX syntax in the
      output. To preserve JSX syntax:

  - example:
      cli:
        - $: |
            echo '<div/>' | esbuild --jsx=preserve --loader=jsx
        - expect: |
            <div />;

      js:
        - $: |
            require('esbuild').transformSync('<div/>', {
              jsx: 'preserve',
              loader: 'jsx',
            })
        - expect: |
            {
              code: '<div />;\n',
              map: '',
              warnings: []
            }

      go: |
        package main

        import "fmt"
        import "github.com/evanw/esbuild/pkg/api"

        func main() {
          result := api.Transform("<div/>", api.TransformOptions{
            JSXMode: api.JSXModePreserve,
            Loader:  api.LoaderJSX,
          })

          if len(result.Errors) == 0 {
            fmt.Printf("%s", result.Code)
          }
        }

  - p: >
      Note that if you preserve JSX syntax, the output files are no longer valid
      JavaScript code. This feature is intended to be used when you want to
      transform the JSX syntax in esbuild's output files by another tool after
      bundling, usually one with a different JSX-to-JS transform than the one
      esbuild implements.

  - h3: JSX factory

  - p: >
      这将设置为每个 JSX 元素调用的函数。通常 JSX 表达式如下：

  - pre.xml: |
      <div>Example text</div>

  - p: >
      编译为一个 `React.createElement` 函数的调用，就像这样：

  - pre.js: |
      React.createElement("div", null, "Example text");

  - p: >
      除了 `React.createElement` 函数之外，你还可以通过改变 JSX 工厂函数来调用其他东西。
      例如，调用函数 `h`（在其他库中使用的函数，例如 [Preact](https://preactjs.com/)）：

  - example:
      cli:
        - $: |
            echo '<div/>' | esbuild --jsx-factory=h --loader=jsx
        - expect: |
            /* @__PURE__ */ h("div", null);

      js:
        - $: |
            require('esbuild').transformSync('<div/>', {
              jsxFactory: 'h',
              loader: 'jsx',
            })
        - expect: |
            {
              code: '/* @__PURE__ */ h("div", null);\n',
              map: '',
              warnings: []
            }

      go: |
        package main

        import "fmt"
        import "github.com/evanw/esbuild/pkg/api"

        func main() {
          result := api.Transform("<div/>", api.TransformOptions{
            JSXFactory: "h",
            Loader:     api.LoaderJSX,
          })

          if len(result.Errors) == 0 {
            fmt.Printf("%s", result.Code)
          }
        }

  - p: >
      另外，如果你正在使用 TypeScript，你可以把 JSX 添加到你的 `tsconfig.json` 文件中，
      从而为 TypeScript 配置 JSX，esbuild 应该会自动获取它，而不需要进行配置：

  - pre.json: |
      {
        "compilerOptions": {
          "jsxFactory": "h"
        }
      }

  - h3: JSX fragment

  - p: >
      这将设置为每个 JSX 片段调用的函数。通常 JSX 片段表达式如下：

  - pre.xml: |
      <>Stuff</>

  - p: >
      编译成像这样的 `React.Fragment` 组件的用法：

  - pre.js: |
      React.createElement(React.Fragment, null, "Stuff");

  - p: >
      除了 `React.Fragment` 之外，你还可以通过改变 JSX fragment 来使用其他组件。
      例如，使用 `Fragment` 组件（在像 [Preact](https://preactjs.com/) 这样的库中使用）：

  - example:
      cli:
        - $: |
            echo '<>x</>' | esbuild --jsx-fragment=Fragment --loader=jsx
        - expect: |
            /* @__PURE__ */ React.createElement(Fragment, null, "x");

      js:
        - $: |
            require('esbuild').transformSync('<>x</>', {
              jsxFragment: 'Fragment',
              loader: 'jsx',
            })
        - expect: |
            {
              code: '/* @__PURE__ */ React.createElement(Fragment, null, "x");\n',
              map: '',
              warnings: []
            }

      go: |
        package main

        import "fmt"
        import "github.com/evanw/esbuild/pkg/api"

        func main() {
          result := api.Transform("<>x</>", api.TransformOptions{
            JSXFragment: "Fragment",
            Loader:      api.LoaderJSX,
          })

          if len(result.Errors) == 0 {
            fmt.Printf("%s", result.Code)
          }
        }

  - p: >
      另外，如果你正在使用 Typescript，你可以通过添加该配置到你的 `tsconfig.json` 文件中
      来为 Typescript 配置 JSX，esbuild 应该会自动获取它，而不需要进行配置：

  - pre.json: |
      {
        "compilerOptions": {
          "jsxFragmentFactory": "Fragment"
        }
      }

  - h3: Keep names

  - p: >
      在 JavaScript 中，函数与类的 `name` 属性默认为源码中的附近标识符。这些语法形式都将函数
      的 `name` 属性设置为 `"fn"`：

  - pre.js: |
      function fn() {}
      let fn = function() {};
      fn = function() {};
      let [fn = function() {}] = [];
      let {fn = function() {}} = {};
      [fn = function() {}] = [];
      ({fn = function() {}} = {});

  - p: >
      然而，[压缩](#minify) 为了减小代码体积会进行重命名，并且 [打包](#bundle) 有时候也要通过
      重命名来避免冲突。在很多情况下都会改变 `name` 属性的值。这通常可以接受，因为 `name` 属性
      正常情况下仅用于 debug。然而，一些框架为了注册和绑定依赖于 `name` 属性。如果是这样的话，
      你可以启动该配置以保存原有的 `name` 值，甚至是在压缩的代码中：

  - example:
      in:
        app.js: "1 + 2"

      cli: |
        esbuild app.js --minify --keep-names

      js: |
        require('esbuild').buildSync({
          entryPoints: ['app.js'],
          minify: true,
          keepNames: true,
          outfile: 'out.js',
        })

      go: |
        package main

        import "github.com/evanw/esbuild/pkg/api"
        import "os"

        func main() {
          result := api.Build(api.BuildOptions{
            EntryPoints:       []string{"app.js"},
            MinifyWhitespace:  true,
            MinifyIdentifiers: true,
            MinifySyntax:      true,
            KeepNames:         true,
          })

          if len(result.Errors) > 0 {
            os.Exit(1)
          }
        }

  - h3: Legal comments

  - p: >
      A "legal comment" is considered to be any statement-level comment in JS
      or rule-level  comment in CSS that contains `@license` or `@preserve` or
      that starts with `//!` or `/*!`. These comments are preserved in output
      files by default since that follows the intent of the original authors
      of the code. However, this behavior can be configured by using one of
      the following options:

  - ul:
      - >
        <p>`none`<br>Do not preserve any legal comments.</p>

      - >
        <p>`inline`<br>Preserve all legal comments.</p>

      - >
        <p>`eof`<br>Move all legal comments to the end of the file.</p>

      - >
        <p>`linked`<br>Move all legal comments to a `.LEGAL.txt` file and link to them with a comment.</p>

      - >
        <p>`external`<br>Move all legal comments to a `.LEGAL.txt` file but to not link to them.</p>

  - p: >
      The default behavior is `eof` when [bundle](#bundle) is enabled and
      `inline` otherwise. Setting the legal comment mode looks like this:

  - example:
      in:
        app.js: "1 + 2"

      cli: |
        esbuild app.js --legal-comments=eof

      js: |
        require('esbuild').buildSync({
          entryPoints: ['app.js'],
          legalComments: 'eof',
        })

      go: |
        package main

        import "github.com/evanw/esbuild/pkg/api"
        import "os"

        func main() {
          result := api.Build(api.BuildOptions{
            EntryPoints:   []string{"app.js"},
            LegalComments: api.LegalCommentsEndOfFile,
          })

          if len(result.Errors) > 0 {
            os.Exit(1)
          }
        }

  - p: >
      Note that "statement-level" for JS and "rule-level" for CSS means the
      comment must appear in a context where multiple statements or rules
      are allowed such as in the top-level scope or in a statement or rule
      block. So comments inside expressions or at the declaration level are
      not considered license comments.

  - h3: 日志级别

  - p: >
      可以修改日志级别，以阻止 esbuild 在终端中打印警告/错误信息。
      六个日志级别分别是：

  - ul:
      - >
        <p>`silent`<br>Do not show any log output.</p>
      - >
        <p>`error`<br>Only show errors.</p>
      - >
        <p>`warning`<br>Only show warnings and errors.</p>
      - >
        <p>`info`<br>Show warnings, errors, and an output file summary. This is
        the default log level.</p>
      - >
        <p>`debug`<br>Log everything from `info` and some additional messages
        that may help you debug a broken bundle. This log level has a performance
        impact and some of the messages may be false positives, so this information
        is not shown by default.</p>
      - >
        <p>`verbose`<br>This generates a torrent of log messages and was added to
        debug issues with file system drivers. It's not intended for general use.</p>

  - p: >
      你可以通过如下方式设置日志级别：

  - example:
      cli: |
        echo 'typeof x == "null"' | esbuild --log-level=error

      js: |
        let js = 'typeof x == "null"'
        require('esbuild').transformSync(js, {
          logLevel: 'error',
        })

      go: |
        package main

        import "fmt"
        import "github.com/evanw/esbuild/pkg/api"

        func main() {
          js := "typeof x == 'null'"

          result := api.Transform(js, api.TransformOptions{
            LogLevel: api.LogLevelError,
          })

          if len(result.Errors) == 0 {
            fmt.Printf("%s", result.Code)
          }
        }

  - h3: 日志限制

  - p: >
      默认情况下，esbuild 会在已经报告 10 条信息的情况下停止报告日志信息。这避免了意外生成大量
      的日志消息，这些消息可以很容易地锁定较慢的终端模拟器，如 Windows 命令提示符。它也避免了
      意外地使用终端模拟器的整个滚动缓冲区有限的滚动缓冲区。

  - p: >
      日志限制可以改为另外一个值，并且可以通过设置为 0 将其完全禁用。这会显示所有日志消息：

  - example:
      in:
        app.js: "1 + 2"

      cli: |
        esbuild app.js --log-limit=0

      js: |
        require('esbuild').buildSync({
          entryPoints: ['app.js'],
          logLimit: 0,
          outfile: 'out.js',
        })

      go: |
        package main

        import "github.com/evanw/esbuild/pkg/api"
        import "os"

        func main() {
          result := api.Build(api.BuildOptions{
            EntryPoints: []string{"app.js"},
            LogLimit:    0,
          })

          if len(result.Errors) > 0 {
            os.Exit(1)
          }
        }

  - h3: Main fields

  - p: >
      当你在 node 中导入一个包时，包中的 `package.json` 文件的 `main` 字段会决定导入哪个文件
      （还有 [很多其他的规则](https://nodejs.org/api/modules.html#modules_all_together)）。
      包括 esbuild 在内的主流打包器允许你在解析包是额外指定一个 `package.json` 字段。
      通常至少有三个这样的字段：

  - ul:
      - >
        `main`
        <p>
        这是对于所有用于 node 中的包的 [标准字段](https://docs.npmjs.com/files/package.json#main)。
        `main` 这个名字被硬编码到 node 的模块解析逻辑中。因为它是用于与 node 一起使用的，
        所以可以合理地预期该字段中的文件路径是 commonjs 风格的模块。
        </p>

      - >
        `module`
        <p>
        这个字段来自于一个关于如何将 ECMAScript 模块集成到 node 中的[提案](https://github.com/dherman/defense-of-dot-js/blob/f31319be735b21739756b87d551f6711bd7aa283/proposal.md)。
        正因如此，可以合理地预期该字段中的文件路径是 ECMAScript 风格的模块。该提案没有被 node 接收（node 使用 <code>"type": <wbr>"module"</code>），
        但是它被主流打包器采纳，因为 ECMAScript 风格的模块可以更好的 [tree shaking](#tree-shaking) 或者无用代码移除。
        </p>
        <p>
        对包的作者：一些包错误的将 `module` 字段设置为了特定于浏览器的代码，`main` 字段的是
        特定于 node 端的代码。很有可能因为 node 忽略了 `module` 字段并且人们通常只对特定于
        浏览器的代码使用打包器。然而，打包特定于 node 的代码也很有价值（例如 它减少了下载和引导时间），
        并且那些把特定于浏览器的代码放到 `module` 中的包，会使捆绑器无法有效地进行 tree shaking 操作。
        如果你正在尝试发布特定于浏览器的代码，请使用 `browser` 字段。
        </p>

      - >
        `browser`
        <p>
        这个字段来自于[一个提案](https://gist.github.com/defunctzombie/4339901/49493836fb873ddaa4b8a7aa0ef2352119f69211)，
        该提案允许打包器替换特定于 node 端的文件或者模块为他们的浏览器友好版本
        它允许你指定另一个特定于浏览器的入口点。
        请注意，包可以同时使用 `browser` 和 `module` 字段（见下面的说明）。
        </p>

  - p: >
      默认的 main 字段依赖于当前 [platform](#platform) 设置，本质上是
      <code>browser,<wbr>module,<wbr>main</code>（浏览器）与 <code>main,<wbr>module</code>（node）。
      这些默认值应该与现有的包生态系统最广泛地兼容。但是如果你想的话，你可以像这样定制它们：

  - example:
      in:
        app.js: "1 + 2"

      cli: |
        esbuild app.js --bundle --main-fields=module,main

      js: |
        require('esbuild').buildSync({
          entryPoints: ['app.js'],
          bundle: true,
          mainFields: ['module', 'main'],
          outfile: 'out.js',
        })

      go: |
        package main

        import "github.com/evanw/esbuild/pkg/api"
        import "os"

        func main() {
          result := api.Build(api.BuildOptions{
            EntryPoints: []string{"app.js"},
            Bundle:      true,
            MainFields:  []string{"module", "main"},
            Write:       true,
          })

          if len(result.Errors) > 0 {
            os.Exit(1)
          }
        }

  - p: >
      对于包作者：如果你想发布一个使用 `browser` 字段结合 `module` 字段填充
      所有 CommonJS-vs-ESM 和 browser-vs-node 兼容性矩阵的包，你会想要使用 `browser` 字
      段的扩展形式字段映射，而不只是一个字符串：

  - pre.json: >
      {
        "main": "./node-cjs.js",
        "module": "./node-esm.js",
        "browser": {
          "./node-cjs.js": "./browser-cjs.js",
          "./node-esm.js": "./browser-esm.js"
        }
      }

  - h3: Mangle props

  - warning: >
      **Using this feature can break your code in subtle ways.** Do not use this
      feature unless you know what you are doing, and you know exactly how it
      will affect both your code and all of your dependencies.

  - p: >
      This setting lets you pass a regular expression to esbuild to tell
      esbuild to automatically rename all properties that match this regular
      expression. It's useful when you want to minify certain property names
      in your code either to make the generated code smaller or to somewhat
      obfuscate your code's intent.

  - p: >
      Here's an example that uses the regular expression `_$` to mangle all
      properties ending in an underscore, such as `foo_`. This mangles
      <code>print({ <wbr>foo_: 0 <wbr>}.foo_)</code>
      into <code>print({ <wbr>a: 0 <wbr>}.a)</code>:

  - example:
      in:
        app.js: '1 + 2'

      cli: |
        esbuild app.js --mangle-props=_$

      js: |
        require('esbuild').buildSync({
          entryPoints: ['app.js'],
          mangleProps: /_$/,
        })

      go: |
        package main

        import "github.com/evanw/esbuild/pkg/api"
        import "os"

        func main() {
          result := api.Build(api.BuildOptions{
            EntryPoints: []string{"app.js"},
            MangleProps: "_$",
          })

          if len(result.Errors) > 0 {
            os.Exit(1)
          }
        }

  - p: >
      Only mangling properties that end in an underscore is a reasonable
      heuristic because normal JS code doesn't typically contain identifiers
      like that. Browser APIs also don't use this naming convention so this
      also avoids conflicts with browser APIs. If you want to avoid mangling
      names such as [`__defineGetter__`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/__defineGetter__)
      you could consider using a more complex regular expression such as
      `[^_]_$` (i.e. must end in a non-underscore followed by an underscore).

  - p: >
      This is a separate setting instead of being part of the [minify](#minify)
      setting because it's an unsafe transformation that does not work on
      arbitrary JavaScript code. It only works if the provided regular
      expression matches all of the properties that you want mangled and does
      not match any of the properties that you don't want mangled. It also only
      works if you do not under any circumstances reference a mangled property
      indirectly. For example, it means you can't use `obj[prop]` to reference a
      property where `prop` is a string containing the property name. Specifically
      the following syntax constructs are the only ones eligible for property mangling:

  - table: |
      | Syntax                           | Example                                   |
      |----------------------------------|-------------------------------------------|
      | Dot property accesses            | `x.foo_`                                  |
      | Dot optional chains              | `x?.foo_`                                 |
      | Object properties                | `x = { foo_: y }`                         |
      | Object methods                   | `x = { foo_() {} }`                       |
      | Class fields                     | `class x { foo_ = y }`                    |
      | Class methods                    | `class x { foo_() {} }`                   |
      | Object destructuring bindings    | `let { foo_: x } = y`                     |
      | Object destructuring assignments | `({ foo_: x } = y)`                       |
      | JSX element member expression    | `<X.foo_></X.foo_>`                       |
      | JSX attribute names              | `<X foo_={y} />`                          |
      | TypeScript namespace exports     | `namespace x { export let foo_ = y }`     |
      | TypeScript parameter properties  | `class x { constructor(public foo_) {} }` |

  - p: >
      When using this feature, keep in mind that property names are only
      consistently mangled within a single esbuild API call but not across
      esbuild API calls. Each esbuild API call does an independent property
      mangling operation so output files generated by two different API calls
      may mangle the same property to two different names, which could cause
      the resulting code to behave incorrectly.

  - h4#mangle-quoted: >
      Quoted properties

  - p: >
      By default, esbuild doesn't modify the contents of string literals. This means
      you can avoid property mangling for an individual property by quoting it
      as a string. However, you must consistently use quotes or no quotes for
      a given property everywhere for this to work. For example,
      <code>print({ <wbr>foo_: 0 <wbr>}.foo_)</code> will be mangled into
      <code>print({ <wbr>a: 0 <wbr>}.a)</code> while
      <code>print({ <wbr>'foo_': 0 <wbr>}['foo_'])</code> will not be mangled.

  - p: >
      If you would like for esbuild to also mangle the contents of string literals,
      you can explicitly enable that behavior like this:

  - example:
      in:
        app.js: '1 + 2'

      cli: |
        esbuild app.js --mangle-props=_$ --mangle-quoted

      js: |
        require('esbuild').buildSync({
          entryPoints: ['app.js'],
          mangleProps: /_$/,
          mangleQuoted: true,
        })

      go: |
        package main

        import "github.com/evanw/esbuild/pkg/api"
        import "os"

        func main() {
          result := api.Build(api.BuildOptions{
            EntryPoints:  []string{"app.js"},
            MangleProps:  "_$",
            MangleQuoted: api.MangleQuotedTrue,
          })

          if len(result.Errors) > 0 {
            os.Exit(1)
          }
        }

  - p: >
      Enabling this makes the following syntax constructs also eligible for property
      mangling:

  - table: |
      | Syntax                                  | Example                   |
      |-----------------------------------------|---------------------------|
      | Quoted property accesses                | `x['foo_']`               |
      | Quoted optional chains                  | `x?.['foo_']`             |
      | Quoted object properties                | `x = { 'foo_': y }`       |
      | Quoted object methods                   | `x = { 'foo_'() {} }`     |
      | Quoted class fields                     | `class x { 'foo_' = y }`  |
      | Quoted class methods                    | `class x { 'foo_'() {} }` |
      | Quoted object destructuring bindings    | `let { 'foo_': x } = y`   |
      | Quoted object destructuring assignments | `({ 'foo_': x } = y)`     |
      | String literals to the left of `in`     | `'foo_' in x`             |

  - h4#reserve-props: >
      Preventing renaming

  - p: >
      If you would like to exclude certain properties from mangling, you can
      reserve them with an additional setting. For example, this uses the
      regular expression `^__.*__$` to reserve all properties that start and
      end with two underscores, such as `__foo__`:

  - example:
      in:
        app.js: '1 + 2'

      cli: |
        esbuild app.js --mangle-props=_$ "--reserve-props=^__.*__$"

      js: |
        require('esbuild').buildSync({
          entryPoints: ['app.js'],
          mangleProps: /_$/,
          reserveProps: /^__.*__$/,
        })

      go: |
        package main

        import "github.com/evanw/esbuild/pkg/api"
        import "os"

        func main() {
          result := api.Build(api.BuildOptions{
            EntryPoints:  []string{"app.js"},
            MangleProps:  "_$",
            ReserveProps: "^__.*__$",
          })

          if len(result.Errors) > 0 {
            os.Exit(1)
          }
        }

  - h4#mangle-cache: >
      Persisting renaming decisions

  - p: >
      Advanced usage of the property mangling feature involves storing the
      mapping from original name to mangled name in a persistent cache. When
      enabled, all mangled property renamings are recorded in the cache during
      the initial build. Subsequent builds reuse the renamings stored in the
      cache and add additional renamings for any newly-added properties. This
      has a few consequences:

  - ul:
    - >
      <p>
      You can customize what mangled properties are renamed to by editing the
      cache before passing it to esbuild.
      </p>

    - >
      <p>
      The cache serves as a list of all properties that were mangled. You can
      easily scan it to see if there are any unexpected property renamings.
      </p>

    - >
      <p>
      You can disable mangling for individual properties by setting the renamed
      value to `false` instead of to a string. This is similar to the [reserve props](#reserve-props)
      setting but on a per-property basis.
      </p>

    - >
      <p>
      You can ensure consistent renaming between builds (e.g. a main-thread
      file and a web worker, or a library and a plugin). Without this feature,
      each build would do an independent renaming operation and the mangled
      property names likely wouldn't be consistent.
      </p>

  - p: >
      For example, consider the following input file:

  - pre.js: |
      console.log({
        someProp_: 1,
        customRenaming_: 2,
        disabledRenaming_: 3
      });

  - p: >
      If we want `customRenaming_` to be renamed to `cR_` and we don't want
      `disabledRenaming_` to be renamed at all, we can pass the following
      mangle cache JSON to esbuild:

  - pre.json: |
      {
        "customRenaming_": "cR_",
        "disabledRenaming_": false
      }

  - p: >
      The mangle cache JSON can be passed to esbuild like this:

  - example:
      in:
        app.js: '1 + 2'

      cli: |
        esbuild app.js --mangle-props=_$ --mangle-cache=cache.json

      js: |
        let result = require('esbuild').buildSync({
          entryPoints: ['app.js'],
          mangleProps: /_$/,
          mangleCache: {
            customRenaming_: "cR_",
            disabledRenaming_: false
          },
        })

        console.log('updated mangle cache:', result.mangleCache)

      go: |
        package main

        import "fmt"
        import "github.com/evanw/esbuild/pkg/api"
        import "os"

        func main() {
          result := api.Build(api.BuildOptions{
            EntryPoints: []string{"app.js"},
            MangleProps: "_$",
            MangleCache: map[string]interface{}{
              "customRenaming_":   "cR_",
              "disabledRenaming_": false,
            },
          })

          if len(result.Errors) > 0 {
            os.Exit(1)
          }

          fmt.Println("updated mangle cache:", result.MangleCache)
        }

  - p: >
      When property naming is enabled, that will result in the following
      output file:

  - pre.js: |
      console.log({
        a: 1,
        cR_: 2,
        disabledRenaming_: 3
      });

  - p: >
      And the following updated mangle cache:

  - pre.json: |
      {
        "customRenaming_": "cR_",
        "disabledRenaming_": false,
        "someProp_": "a"
      }

  - h3: Metafile

  - p: >
      该配置告诉 esbuild 以 JSON 格式生成一些构建相关的元数据。
      下面的例子就是将元数据置于名为 `meta.json` 的文件中：

  - example:
      in:
        app.js: "1 + 2"

      cli: |
        esbuild app.js --bundle --metafile=meta.json --outfile=out.js

      js: |
        const result = require('esbuild').buildSync({
          entryPoints: ['app.js'],
          bundle: true,
          metafile: true,
          outfile: 'out.js',
        })
        require('fs').writeFileSync('meta.json',
          JSON.stringify(result.metafile))

      go: |
        package main

        import "io/ioutil"
        import "github.com/evanw/esbuild/pkg/api"
        import "os"

        func main() {
          result := api.Build(api.BuildOptions{
            EntryPoints: []string{"app.js"},
            Bundle:      true,
            Metafile:    true,
            Outfile:     "out.js",
            Write:       true,
          })

          if len(result.Errors) > 0 {
            os.Exit(1)
          }

          ioutil.WriteFile("meta.json", []byte(result.Metafile), 0644)
        }

  - p: >
      该数据可以被其他工具分析。例如，[bundle buddy](https://www.bundle-buddy.com/esbuild) 可以消费
      esbuild 生成的元数据格式，并且生成包中模块的 treemap 可视化，以及每个模块所占用的空间。

  - p: >
      元数据的 JSON 格式看起来像是这样（使用 TypeScript 接口进行描述）：

  - pre.ts: |
      interface Metadata {
        inputs: {
          [path: string]: {
            bytes: number
            imports: {
              path: string
              kind: string
            }[]
          }
        }
        outputs: {
          [path: string]: {
            bytes: number
            inputs: {
              [path: string]: {
                bytesInOutput: number
              }
            }
            imports: {
              path: string
              kind: string
            }[]
            exports: string[]
            entryPoint?: string
          }
        }
      }

  - h3: Node paths

  - p: >
      Node 的模块解析算法支持一个名为 [`NODE_PATH`](https://nodejs.org/api/modules.html#modules_loading_from_the_global_folders) 
      的环境变量，该变量包含在解析导入路径时使用的全局目录列表。除了所有父目录中的 `node_modules` 目录之外，
      还会在这些路径中搜索包。你可以在 CLI 中使用环境变量，在 JS 和 Go api 中使用数组将这个目录列表传递给 esbuild：

  - example:
      in:
        app.js: 'import {x} from "test"'
        someDir/test.js: "export let x"

      cli: |
        NODE_PATH=someDir esbuild app.js --bundle --outfile=out.js

      js: |
        require('esbuild').buildSync({
          nodePaths: ['someDir'],
          entryPoints: ['app.js'],
          bundle: true,
          outfile: 'out.js',
        })

      go: |
        package main

        import "github.com/evanw/esbuild/pkg/api"
        import "os"

        func main() {
          result := api.Build(api.BuildOptions{
            NodePaths:   []string{"someDir"},
            EntryPoints: []string{"app.js"},
            Bundle:      true,
            Outfile:     "out.js",
            Write:       true,
          })

          if len(result.Errors) > 0 {
            os.Exit(1)
          }
        }

  - p: >
      如果你正在使用 CLI 并且想要使用 `NODE_PATH` 传递多个文件夹的话，你必须在 `:` 或者在 Windows 中使用 `;` 分隔它们。
      这也是 Node 使用的格式。

  - h3: Out extension

  - p: >
      该配置项可以让你自定义文件的文件拓展名，这样 esbuild 可以生成布置 `.js` 或者 `.css` 文件。
      除此之外，`.mjs` 与 `.cjs` 拓展名在 Node 中有特殊含义（他们分别表示一个文件是 ESM 还是 CommonJS 格式）。
      如果你正在使用 esbuild 生成多个文件的话该配置项是非常有用的，并且比必须使用 [outdir](#outdir)
      配置项而不是 [outfile](#outfile)。你可以像这样使用它：

  - example:
      in:
        app.js: "1 + 2"

      cli: |
        esbuild app.js --bundle --outdir=dist --out-extension:.js=.mjs

      js: |
        require('esbuild').buildSync({
          entryPoints: ['app.js'],
          bundle: true,
          outdir: 'dist',
          outExtension: { '.js': '.mjs' },
        })

      go: |
        package main

        import "github.com/evanw/esbuild/pkg/api"
        import "os"

        func main() {
          result := api.Build(api.BuildOptions{
            EntryPoints: []string{"app.js"},
            Bundle:      true,
            Outdir:      "dist",
            OutExtensions: map[string]string{
              ".js": ".mjs",
            },
            Write: true,
          })

          if len(result.Errors) > 0 {
            os.Exit(1)
          }
        }

  - h3: Outbase

  - p: >
      如果你的构建包含多个入口点，这些入口点都在单独的文件夹中，目录结构将被复制到相对于 [output directory](#outdir) 目录的输出目录中。
      例如，如果有 <code>src/<wbr>pages/<wbr>home/<wbr>index.ts</code> 与
      <code>src/<wbr>pages/<wbr>about/<wbr>index.ts</code> 两个入口点，并且 outbase 目录为 `src`，
      输出目录将会包含 <code>pages/<wbr>home/<wbr>index.js</code> 与 <code>pages/<wbr>about/<wbr>index.js</code>。
      下面是如何使用它：

  - example:
      in:
        src/pages/home/index.ts: "1 + 2"
        src/pages/about/index.ts: "3 + 4"

      cli: |
        esbuild src/pages/home/index.ts src/pages/about/index.ts --bundle --outdir=out --outbase=src

      js: |
        require('esbuild').buildSync({
          entryPoints: [
            'src/pages/home/index.ts',
            'src/pages/about/index.ts',
          ],
          bundle: true,
          outdir: 'out',
          outbase: 'src',
        })

      go: |
        package main

        import "github.com/evanw/esbuild/pkg/api"
        import "os"

        func main() {
          result := api.Build(api.BuildOptions{
            EntryPoints: []string{
              "src/pages/home/index.ts",
              "src/pages/about/index.ts",
            },
            Bundle:  true,
            Outdir:  "out",
            Outbase: "src",
          })

          if len(result.Errors) > 0 {
            os.Exit(1)
          }
        }

  - p: >
      如果没有指定 outbase 文件夹，它默认为所有入口起点路径的 [最低共有祖先](https://en.wikipedia.org/wiki/Lowest_common_ancestor) 目录。
      上面的例子是 <code>src/<wbr>pages</code>，这意味着输出目录将会包含 <code>home/<wbr>index.js</code> 与 <code>about/<wbr>index.js</code>。

  - h3: Preserve symlinks

  - p: >
      这设置与 node 中的 [`--preserve-symlinks`](https://nodejs.org/api/cli.html#cli_preserve_symlinks) 设置相映射。
      如果你使用这个设置（或者是 webpack 中的相似配置 [`resolve.symlinks`](https://webpack.js.org/configuration/resolve/#resolvesymlinks)），
      你也会需要在 esbuild 中启用该设置。可以像这样启用：

  - example:
      in:
        app.js: "1 + 2"

      cli: |
        esbuild app.js --bundle --preserve-symlinks --outfile=out.js

      js: |
        require('esbuild').buildSync({
          entryPoints: ['app.js'],
          bundle: true,
          preserveSymlinks: true,
          outfile: 'out.js',
        })

      go: |
        package main

        import "github.com/evanw/esbuild/pkg/api"
        import "os"

        func main() {
          result := api.Build(api.BuildOptions{
            EntryPoints:      []string{"app.js"},
            Bundle:           true,
            PreserveSymlinks: true,
            Outfile:          "out.js",
          })

          if len(result.Errors) > 0 {
            os.Exit(1)
          }
        }

  - p: >
      启用此设置将导致 esbuild 根据原始文件路径（即没有符号链接的路径）而不是真实文件路径
      （即有符号链接的路径）确定文件标识。这对于某些目录结构是有益的。请记住，这意味着如果
      有多个符号链接指向一个文件，那么它可能被赋予多个身份，这可能导致它在生成的输出文件中出现多次。

  - p: >
      _注意：术语 "symlink" 的意思是 [symbolic link](https://en.wikipedia.org/wiki/Symbolic_link)，
      它指的是一种文件系统特性，其中路径可以重定向到另一个路径。_

  - h3: Public path

  - p: >
      这与 [external file](/content-types/#external-file) loader 结合会很有用。
      默认情况下，loader 使用 `default` 导出将导入文件的名称导出为字符串。public path 配置项
      允许你在这个 loader 加载的每个文件的导出字符串前添加一个基本路径：

  - example:
      in:
        app.js: |
          import url from './example.png'
          let image = new Image
          image.src = url
          document.body.appendChild(image)
        example.png: |
          this is some data

      cli: |
        esbuild app.js --bundle --loader:.png=file --public-path=https://www.example.com/v1 --outdir=out

      js: |
        require('esbuild').buildSync({
          entryPoints: ['app.js'],
          bundle: true,
          loader: { '.png': 'file' },
          publicPath: 'https://www.example.com/v1',
          outdir: 'out',
        })

      go: |
        package main

        import "github.com/evanw/esbuild/pkg/api"
        import "os"

        func main() {
          result := api.Build(api.BuildOptions{
            EntryPoints: []string{"app.js"},
            Bundle:      true,
            Loader: map[string]api.Loader{
              ".png": api.LoaderFile,
            },
            Outdir:     "out",
            PublicPath: "https://www.example.com/v1",
            Write:      true,
          })

          if len(result.Errors) > 0 {
            os.Exit(1)
          }
        }

=======
>>>>>>> 64a7cbf09ed21d61e6fe85529b31e5676fa14bfe
  - h3: Pure

  - p: >
      各种各样的 JavaScript 工具都有一个约定，如果在一个新的表达式调用之前有一个包含
      `/* @__PURE__ */` 或者 `/* #__PURE__ */` 的特殊注释，那么就意味着那个表达式
      在其返回值在没有使用的情况下可以被移除。就像是这样：

  - pre.js: |
      let button = /* @__PURE__ */ React.createElement(Button, null);

  - p: >
      像 esbuild 这类打包器在 tree shaking（又名 无用代码移除）期间使用该信息，
      在由于 JavaScript 代码的动态特性，打包器不能自己证明删除未使用的导入是安全的情况下，
      跨模块边界执行细粒度的删除。

  - p: >
      请注意，虽然注释说的是 "pure"，但令人困惑的是，它并没有表明被调用的函数是纯的。
      例如，它并不表示可以缓存对该函数的重复调用。
      这个名字本质上只是“如果不用就可以删除”的抽象简写。

  - p: >
<<<<<<< HEAD
      一些表达式，比如JSX和某些内置全局变量，在 esbuild 中会自动注释为 `/* @__PURE__ */`。
      你也可以配置其他的全局变量标记为 `/* @__PURE__ */`。例如，你可以将全局的 `console.log` 函数标记为这样，
      只要结果没有被使用，当 bundle 被缩小时，它就会自动从你的 bundle 中删除。

  - p: >
      值得一提的是，注释的效果只扩展到调用本身，而不扩展到参数。关于副作用的参数仍然保存：
=======
      Some expressions such as JSX and certain built-in globals are automatically
      annotated as `/* @__PURE__ */` in esbuild. You can also configure additional
      globals to be marked `/* @__PURE__ */` as well. For example, you can mark
      the global <code>document.<wbr>createElement</code> function as such to have
      it be automatically removed from your bundle when the bundle is minified as
      long as the result isn't used.

  - p: >
      It's worth mentioning that the effect of the annotation only extends to
      the call itself, not to the arguments. Arguments with side effects are
      still kept even when minification is enabled:
>>>>>>> 64a7cbf09ed21d61e6fe85529b31e5676fa14bfe

  - example:
      cli:
        - $: |
            echo 'document.createElement(elemName())' | esbuild --pure:document.createElement
        - expect: |
            /* @__PURE__ */ document.createElement(elemName());
        - $: |
            echo 'document.createElement(elemName())' | esbuild --pure:document.createElement --minify
        - expect: |
            elemName();

      mjs:
        - $: import * as esbuild from 'esbuild'
        - $: |
            let js = 'document.createElement(elemName())'
        - $: |
            (await esbuild.transform(js, {
              pure: ['document.createElement'],
            })).code
        - expect: |
            '/* @__PURE__ */ document.createElement(elemName());\n'
        - $: |
            (await esbuild.transform(js, {
              pure: ['document.createElement'],
              minify: true,
            })).code
        - expect: |
            'elemName();\n'

      go: |
        package main

        import "fmt"
        import "github.com/evanw/esbuild/pkg/api"

        func main() {
          js := "document.createElement(elemName())"

          result1 := api.Transform(js, api.TransformOptions{
            Pure: []string{"document.createElement"},
          })

          if len(result1.Errors) == 0 {
            fmt.Printf("%s", result1.Code)
          }

          result2 := api.Transform(js, api.TransformOptions{
            Pure:         []string{"document.createElement"},
            MinifySyntax: true,
          })

          if len(result2.Errors) == 0 {
            fmt.Printf("%s", result2.Code)
          }
        }

  - p: >
<<<<<<< HEAD
      [node 使用的解析算法](https://nodejs.org/api/modules.html#modules_file_modules)
      支持隐式的文件扩展名。你可以 <code>require(<wbr>'./file')</code>，然后他将会按照顺序检查
      `./file`、`./file.js`、`./file.json` 与 `./file.node`。包括 esbuild 在内的现代打包器
      将此概念拓展到了其他文件类型。在 esbuild 中可以使用解析插件设置对隐式文件拓展名进行自定义配置，
      默认为 <code>.tsx,<wbr>.ts,<wbr>.jsx,<wbr>.js,<wbr>.css,<wbr>.json</code>：

  - example:
      in:
        app.js: "1 + 2"

      cli: |
        esbuild app.js --bundle --resolve-extensions=.ts,.js

      js: |
        require('esbuild').buildSync({
          entryPoints: ['app.js'],
          bundle: true,
          resolveExtensions: ['.ts', '.js'],
          outfile: 'out.js',
        })

      go: |
        package main

        import "github.com/evanw/esbuild/pkg/api"
        import "os"

        func main() {
          result := api.Build(api.BuildOptions{
            EntryPoints:       []string{"app.js"},
            Bundle:            true,
            ResolveExtensions: []string{".ts", ".js"},
            Write:             true,
          })

          if len(result.Errors) > 0 {
            os.Exit(1)
          }
        }

  - p: >
      Note that esbuild deliberately does not include the new `.mjs` and `.cjs`
      extensions in this list. Node's resolution algorithm doesn't treat these
      as implicit file extensions, so esbuild doesn't either. If you want to
      import files with these extensions you should either explicitly add the
      extensions in your import paths or change this setting to include the
      additional extensions that you want to be implicit.

  - h3: Source root

  - p: >
      该特性仅在启用 [source maps](#sourcemap) 时才相关。它允许你在 source map 中设置 `sourceRoot` 字段的值，
      该值指定 source map 中所有其他路径的相对路径。如果该字段不存在，则 source map 中的所有路径将被解释为相对于
      包含 source map 的目录。

  - p: >
      你可以像这样配置 `sourceRoot`：

  - example:
      in:
        app.js: "1 + 2"

      cli: |
        esbuild app.js --sourcemap --source-root=https://raw.githubusercontent.com/some/repo/v1.2.3/

      js: |
        require('esbuild').buildSync({
          entryPoints: ['app.js'],
          sourcemap: true,
          sourceRoot: 'https://raw.githubusercontent.com/some/repo/v1.2.3/',
        })

      go: |
        package main

        import "github.com/evanw/esbuild/pkg/api"
        import "os"

        func main() {
          result := api.Build(api.BuildOptions{
            EntryPoints: []string{"app.js"},
            Sourcemap:   api.SourceMapInline,
            SourceRoot:  "https://raw.githubusercontent.com/some/repo/v1.2.3/",
          })

          if len(result.Errors) > 0 {
            os.Exit(1)
          }
        }

  - h3: Sourcefile

  - p: >
      该配置可以让你在使用一个没有文件名的输入时设置文件名。这将会在 stdin 中使用 transform API 以及
      build API 时会出现这种情况。配置的文件名反映在错误消息和 source maps 中。如果没有配置，该文件名默认为 `<stdin>`。
      你可以像这样配置：

  - example:
      in:
        app.js: "1 + 2"

      cli: |
        cat app.js | esbuild --sourcefile=example.js --sourcemap

      js: |
        let fs = require('fs')
        let js = fs.readFileSync('app.js', 'utf8')

        require('esbuild').transformSync(js, {
          sourcefile: 'example.js',
          sourcemap: 'inline',
        })

      go: |
        package main

        import "fmt"
        import "io/ioutil"
        import "github.com/evanw/esbuild/pkg/api"

        func main() {
          js, err := ioutil.ReadFile("app.js")
          if err != nil {
            panic(err)
          }

          result := api.Transform(string(js),
            api.TransformOptions{
              Sourcefile: "example.js",
              Sourcemap:  api.SourceMapInline,
            })

          if len(result.Errors) == 0 {
            fmt.Printf("%s", result.Code)
          }
        }

  - h3: Sources content

  - p: >
      使用 source map 格式的 [第三版](https://sourcemaps.info/spec.html) 生成 [source maps](#sourcemap)，
      这是目前最广泛支持的变体。每一个 source map 看起来像这样：

  - pre.json: |
      {
        "version": 3,
        "sources": ["bar.js", "foo.js"],
        "sourcesContent": ["bar()", "foo()\nimport './bar'"],
        "mappings": ";AAAA;;;ACAA;",
        "names": []
      }

  - p: >
      `sourcesContent` 为可选字段，其包含所有的源代码。这对 debug 非常有用，因为它意味着
      源代码在调试器上处于可用状态。

  - p: >
      但是，在某些场景中并不需要它。例如，如果你只是在生产环境中使用源代码映射来生成包含原始
      文件名的堆栈跟踪，那么你不需要原始源代码，因为没有涉及到调试器。
      在这种情况下，可以省略 `sourcesContent` 字段，使 source map 更小：

  - example:
      in:
        app.js: "1 + 2"

      cli: |
        esbuild --bundle app.js --sourcemap --sources-content=false

      js: |
        require('esbuild').buildSync({
          bundle: true,
          entryPoints: ['app.js'],
          sourcemap: true,
          sourcesContent: false,
          outfile: 'out.js',
        })

      go: |
        package main

        import "github.com/evanw/esbuild/pkg/api"
        import "os"

        func main() {
          result := api.Build(api.BuildOptions{
            Bundle:         true,
            EntryPoints:    []string{"app.js"},
            Sourcemap:      api.SourceMapInline,
            SourcesContent: api.SourcesContentExclude,
          })

          if len(result.Errors) > 0 {
            os.Exit(1)
          }
        }

  - h3: Stdin

  - p: >
      通常，build API 调用接受一个或多个文件名作为输入。但是，这个配置项可以用于在文件系统上根本不存在模块
      的情况下运行构建。它被称为 "stdin"，因为它对应于在命令行上用管道将文件连接到 stdin。

  - p: >
      除了指定 stdin 文件的内容之外，你还可以选择性地指定解析目录（用于确定相对导入的位置）、
      [sourcefile](#sourcefile)（在错误消息和源映射中使用的文件名）和 [loader](#loader)
      （用于确定如何解释文件内容）。CLI 没有指定解析目录的方法。相反，它被自动设置为当前工作目录。

  - p: >
      这里是如何使用该特性的方法：

  - example:
      in:
        another-file.js: "export let foo = 123"

      cli: |
        echo 'export * from "./another-file"' | esbuild --bundle --sourcefile=imaginary-file.js --loader=ts --format=cjs

      js: |
        let result = require('esbuild').buildSync({
          stdin: {
            contents: `export * from "./another-file"`,

            // These are all optional:
            resolveDir: require('path').join(__dirname, 'src'),
            sourcefile: 'imaginary-file.js',
            loader: 'ts',
          },
          format: 'cjs',
          write: false,
        })

      go: |
        package main

        import "github.com/evanw/esbuild/pkg/api"
        import "os"

        func main() {
          result := api.Build(api.BuildOptions{
            Stdin: &api.StdinOptions{
              Contents: "export * from './another-file'",

              // These are all optional:
              ResolveDir: "./src",
              Sourcefile: "imaginary-file.js",
              Loader:     api.LoaderTS,
            },
            Format: api.FormatCommonJS,
          })

          if len(result.Errors) > 0 {
            os.Exit(1)
          }
        }
=======
      Note that if you are trying to remove all calls to `console` API methods
      such as `console.log` and also want to remove the evaluation of arguments
      with side effects, there is a special case available for this: you can use
      the [drop feature](#drop) instead of marking `console` API calls as pure.
      However, this mechanism is specific to the `console` API and doesn't work
      with other call expressions.
>>>>>>> 64a7cbf09ed21d61e6fe85529b31e5676fa14bfe

  - h3: Tree shaking

  - p: >
      Tree shaking 是 JavaScript 社区用来描述无用代码消除的术语，
      这是一种常见的编译器优化，可以自动删除无法访问的代码。注意，esbuild 中的 tree shaking 
      在绑定期间总是启用的，而且不能关闭，因为在不改变可观察行为的情况下，移除未使用的代码会使结果文件变小。

  - p: >
      用一个例子来解释 tree shaking 是最简单的。考虑以下文件。有一个已使用的函数和一个未使用的函数：

  - pre.js: |
      // input.js
      function one() {
        console.log('one')
      }
      function two() {
        console.log('two')
      }
      one()

  - p: >
      如果你是用 <code>esbuild <wbr>--bundle <wbr>input.js <wbr>--outfile=<wbr>output.js</code> 打包该文件，
      没有使用到的函数将会自动销毁，并为你产生以下输出：

  - pre.js: |
      // input.js
      function one() {
        console.log("one");
      }
      one();

  - p: >
      即使我们将函数分割成一个单独的库文件并使用 `import` 语句导入它们也是有效的：

  - pre.js: |
      // lib.js
      export function one() {
        console.log('one')
      }
      export function two() {
        console.log('two')
      }

  - pre.js: |
      // input.js
      import * as lib from './lib.js'
      lib.one()

  - p: >
      如果你是用 <code>esbuild <wbr>--bundle <wbr>input.js <wbr>--outfile=<wbr>output.js</code> 打包该文件，
      没有使用到的函数将会自动销毁，并为你产生以下输出：

  - pre.js: |
      // lib.js
      function one() {
        console.log("one");
      }

      // input.js
      one();

  - p: >
<<<<<<< HEAD
      通过这种方式，esbuild 将只打包你实际使用的部分库，这有时可以节省大量的大小。
      注意，esbuild的 tree shaking 实现依赖于使用 ECMAScript 模块 `import`和 `export` 语句。
      它不能与 CommonJS 模块一起工作。npm 上的许多库都包含了这两种格式，esbuild 会在默认情况下选择适合 tree shaking 
      的格式。你可以使用 [main fields](#main-fields) 配置项自定义 esbuild 选择的格式。
=======
      This way esbuild will only bundle the parts of your packages that you
      actually use, which can sometimes be a substantial size savings. Note
      that esbuild's tree shaking implementation relies on the use of ECMAScript
      module `import` and `export` statements. It does not work with CommonJS
      modules. Many packages on npm include both formats and esbuild tries to
      pick the format that works with tree shaking by default. You can
      customize which format esbuild picks using the [main fields](#main-fields)
      and/or [conditions](#conditions) options depending on the package.
>>>>>>> 64a7cbf09ed21d61e6fe85529b31e5676fa14bfe

  - p: >
      由于 JavaScript 是一门动态语言，对于编译器来说确定未使用的代码是一件很困难的事情，所以
      社区发展出了某些注释来帮助编译器确定哪些代码是未使用的。目前 esbuild 支持两种 tree-shaking 注释：

  - ul:
      - >
        <p>
        函数调用前的行内 `/* @__PURE__ */` 注释告诉 esbuild 该函数调用如果在结果没有被使用的情况下可以被移除。
        查看 [pure](#pure) API 配置项获取更多信息。
        </p>

      - >
        <p>
        `package.json` 中的 `sideEffects` 字段也可以用来告诉 esbuild 在你的包中的哪些文件
        在始终没有使用的情况下可以被移除。这是一个来自 webpack 的公约，并且很多发布到 npm 的库已经在
        其包定义中包含此字段。你可以在 [Webpack 的文档](https://webpack.js.org/guides/tree-shaking/)
        中了解到更多关于该字段的信息。
        </p>

  - p: >
      这些注释可能会产生问题，因为编译器完全依赖于开发人员来确保准确性，而开发人员偶尔会发布带有
      不正确注释的包。`sideEffects` 字段对于开发人员来说特别容易出错，因为默认情况下，
      如果没有使用导入，它会导致包中的所有文件都被认为是无用代码。如果你添加了一个包含副作用的新文件，
      并且忘记更新该字段，那么当人们试图打包它时，你的包可能会崩溃。

  - p: >
      所以 esbuild 包含一种忽略 tree-shaking 注释的方法。只有当你遇到一个问题，
      bundle 因为意外地从 bundle 中删除了必要的代码而破坏时，你才应该启用这个功能：
      <!-- TODO: translation -->
      By default, tree shaking is only enabled either when [bundling](#bundle)
      is enabled or when the output [format](#format) is set to `iife`, otherwise
      tree shaking is disabled. You can force-enable tree shaking by setting it
      to `true`:

      By default, tree shaking is only enabled either when [bundling](#bundle)
      is enabled or when the output [format](#format) is set to `iife`, otherwise
      tree shaking is disabled. You can force-enable tree shaking by setting it
      to `true`:

  - example:
      in:
        app.js: "1 + 2"

      cli: |
        esbuild app.js --tree-shaking=true

      mjs: |
        import * as esbuild from 'esbuild'

        await esbuild.build({
          entryPoints: ['app.js'],
          treeShaking: true,
          outfile: 'out.js',
        })

      go: |
        package main

        import "github.com/evanw/esbuild/pkg/api"
        import "os"

        func main() {
          result := api.Build(api.BuildOptions{
            EntryPoints: []string{"app.js"},
            TreeShaking: api.TreeShakingTrue,
          })

          if len(result.Errors) > 0 {
            os.Exit(1)
          }
        }

  - p: >
      You can also force-disable tree shaking by setting it to `false`:

  - example:
      in:
        app.js: "1 + 2"

      cli: |
        esbuild app.js --tree-shaking=false

      mjs: |
        import * as esbuild from 'esbuild'

        await esbuild.build({
          entryPoints: ['app.js'],
          treeShaking: false,
          outfile: 'out.js',
        })

      go: |
        package main

        import "github.com/evanw/esbuild/pkg/api"
        import "os"

        func main() {
          result := api.Build(api.BuildOptions{
            EntryPoints: []string{"app.js"},
            TreeShaking: api.TreeShakingFalse,
          })

          if len(result.Errors) > 0 {
            os.Exit(1)
          }
        }

<<<<<<< HEAD
  - p: >
      启用该配置意味着 esbuild 不再支持 `/* @__PURE__ */` 注释与 `sideEffects` 字段。
      然而它仍会对未用到的导入做自动 tree shaking，因为这不会依赖开发者注释。理想情况下，
      这个标志只是一个临时的解决方案。你应该向包的维护者报告这些问题以修复它们，
      因为它们表明了包的一个问题，而且它们可能也会使其他人出错。
      <!-- TODO: translation -->
      Note that tree shaking automatically takes into account user-specified
      side-effect annotations. If you are bundling code with annotations that
      have been authored incorrectly, you may need to [ignore annotations](#ignore-annotations)
      to make sure the bundled code is correct.

      Note that tree shaking automatically takes into account user-specified
      side-effect annotations. If you are bundling code with annotations that
      have been authored incorrectly, you may need to [ignore annotations](#ignore-annotations)
      to make sure the bundled code is correct.

  - h3: Tsconfig

  - p: >
      正常情况下 [build API](#build-api) 会自动发现 `tsconfig.json` 文件，并且在构建时读取其内容。
      然而，你也可以配置使用一个自定义 `tsconfig.json` 文件。如果你需要对同一份代码针对不同的设置
      做多次打包时会非常有用：

  - example:
      in:
        app.ts: "1 + 2"
        custom-tsconfig.json: "{}"

      cli: |
        esbuild app.ts --bundle --tsconfig=custom-tsconfig.json
=======
  - h4: Tree shaking and side effects

  - p: >
      The side effect detection used for tree shaking is conservative, meaning
      that esbuild only considers code removable as dead code if it can be sure
      that there are no hidden side effects. For example, primitive literals
      such as `12.34` and `"abcd"` are side-effect free and can be removed while
      expressions such as `"ab" + cd` and `foo.bar` are not side-effect free
      (joining strings invokes `toString()` which can have side effects, and
      member access can invoke a getter which can also have side effects). Even
      referencing a global identifier is considered to be a side effect because
      it will throw a `ReferenceError` if there is no global with that name.
      Here's an example:

  - pre.js: |
      // These are considered side-effect free
      let a = 12.34;
      let b = "abcd";
      let c = { a: a };

      // These are not considered side-effect free
      // since they could cause some code to run
      let x = "ab" + cd;
      let y = foo.bar;
      let z = { [x]: x };

  - p: >
      Sometimes it's desirable to allow some code to be tree shaken even if that
      code can't be automatically determined to have no side effects. This can
      be done with a [pure annotation comment](#pure) which tells esbuild to
      trust the author of the code that there are no side effects within the
      annotated code. The annotation comment is `/* @__PURE__ */` and can only
      precede a new or call expression. You can annotate an immediately-invoked
      function expression and put arbitrary side effects inside the function
      body:

  - pre.js: |
      // This is considered side-effect free due to
      // the annotation, and will be removed if unused
      let gammaTable = /* @__PURE__ */ (() => {
        // Side-effect detection is skipped in here
        let table = new Uint8Array(256);
        for (let i = 0; i < 256; i++)
          table[i] = Math.pow(i / 255, 2.2) * 255;
        return table;
      })();

  - p: >
      While the fact that `/* @__PURE__ */` only works on call expressions
      can sometimes make code more verbose, a big benefit of this syntax is
      that it's portable across many other tools in the JavaScript ecosystem
      including the popular [UglifyJS](https://github.com/mishoo/uglifyjs) and
      [Terser](https://github.com/terser/terser) JavaScript minifiers (which are
      used by other major tools including [Webpack](https://github.com/webpack/webpack)
      and [Parcel](https://github.com/parcel-bundler/parcel)).

  - p: >
      Note that the annotations cause esbuild to assume that the annotated
      code is side-effect free. If the annotations are wrong and the code
      actually does have important side effects, these annotations can result
      in broken code. If you are bundling third-party code with annotations
      that have been authored incorrectly, you may need to enable
      [ignoring annotations](#ignore-annotations) to make sure the bundled
      code is correct.

  - h2: Source maps

  - h3: Source root

  - p: >
      This feature is only relevant when [source maps](#sourcemap) are enabled.
      It lets you set the value of the `sourceRoot` field in the source map,
      which specifies the path that all other paths in the source map are
      relative to. If this field is not present, all paths in the source map
      are interpreted as being relative to the directory containing the source
      map instead.

  - p: >
      You can configure `sourceRoot` like this:

  - example:
      in:
        app.js: '1 + 2'

      cli: |
        esbuild app.js --sourcemap --source-root=https://raw.githubusercontent.com/some/repo/v1.2.3/
>>>>>>> 64a7cbf09ed21d61e6fe85529b31e5676fa14bfe

      mjs: |
        import * as esbuild from 'esbuild'

        await esbuild.build({
          entryPoints: ['app.js'],
          sourcemap: true,
          sourceRoot: 'https://raw.githubusercontent.com/some/repo/v1.2.3/',
        })

      go: |
        package main

        import "github.com/evanw/esbuild/pkg/api"
        import "os"

        func main() {
          result := api.Build(api.BuildOptions{
            EntryPoints: []string{"app.js"},
            Sourcemap:   api.SourceMapInline,
            SourceRoot:  "https://raw.githubusercontent.com/some/repo/v1.2.3/",
          })

          if len(result.Errors) > 0 {
            os.Exit(1)
          }
        }

  - h3: Sourcefile

  - p: >
      This option sets the file name when using an input which has no file
      name. This happens when using the transform API and when using the build
      API with stdin. The configured file name is reflected in error messages
      and in source maps. If it's not configured, the file name defaults to
      `<stdin>`. It can be configured like this:

  - example:
      in:
        app.js: '1 + 2'

      cli: |
        cat app.js | esbuild --sourcefile=example.js --sourcemap

      mjs: |
        import * as esbuild from 'esbuild'
        import fs from 'node:fs'

        let js = fs.readFileSync('app.js', 'utf8')
        let result = await esbuild.transform(js, {
          sourcefile: 'example.js',
          sourcemap: 'inline',
        })

        console.log(result.code)

      go: |
        package main

        import "fmt"
        import "io/ioutil"
        import "github.com/evanw/esbuild/pkg/api"

        func main() {
          js, err := ioutil.ReadFile("app.js")
          if err != nil {
            panic(err)
          }

          result := api.Transform(string(js),
            api.TransformOptions{
              Sourcefile: "example.js",
              Sourcemap:  api.SourceMapInline,
            })

          if len(result.Errors) == 0 {
            fmt.Printf("%s %s", result.Code)
          }
        }

  - h3: Sourcemap

  - p: >
      Source maps can make it easier to debug your code. They encode the
      information necessary to translate from a line/column offset in a
      generated output file back to a line/column offset in the corresponding
      original input file. This is useful if your generated code is
      sufficiently different from your original code (e.g. your original code
      is TypeScript or you enabled [minification](#minify)). This is also useful
      if you prefer looking at individual files in your browser's developer
      tools instead of one big bundled file.

  - p: >
      Note that source map output is supported for both JavaScript and CSS, and
      the same options apply to both. Everything below that talks about `.js`
      files also applies similarly to `.css` files.

  - p: >
      There are four different modes for source map generation:

  - div: >
      <ol start="1"><li>
      <code>linked</code>
      <p>
      This mode means the source map is generated into a separate `.js.map`
      output file alongside the `.js` output file, and the `.js` output file contains
      a special `//# sourceMappingURL=` comment that points to the `.js.map` output file.
      That way the browser knows where to find the source map for a given file
      when you open the debugger. Use `linked` source map mode like this:
      </p>
      </li></ol>

  - example:
      in:
        app.ts: 'let x: number = 1'

      cli: |
        esbuild app.ts --sourcemap --outfile=out.js

      mjs: |
        import * as esbuild from 'esbuild'

        await esbuild.build({
          entryPoints: ['app.ts'],
          sourcemap: true,
          outfile: 'out.js',
        })

      go: |
        package main

        import "github.com/evanw/esbuild/pkg/api"
        import "os"

        func main() {
          result := api.Build(api.BuildOptions{
            EntryPoints: []string{"app.ts"},
            Sourcemap:   api.SourceMapLinked,
            Outfile:     "out.js",
            Write:       true,
          })

          if len(result.Errors) > 0 {
            os.Exit(1)
          }
        }

  - div: >
      <ol start="2"><li>
      <code>external</code>
      <p>
      This mode means the source map is generated into a separate `.js.map`
      output file alongside the `.js` output file, but unlike `linked` mode the `.js`
      output file does not contain a `//# sourceMappingURL=` comment. Use `external`
      source map mode like this:
      </p>
      </li></ol>

  - example:
      in:
        app.ts: 'let x: number = 1'

      cli: |
        esbuild app.ts --sourcemap=external --outfile=out.js

      mjs: |
        import * as esbuild from 'esbuild'

        await esbuild.build({
          entryPoints: ['app.ts'],
          sourcemap: 'external',
          outfile: 'out.js',
        })

      go: |
        package main

        import "github.com/evanw/esbuild/pkg/api"
        import "os"

        func main() {
          result := api.Build(api.BuildOptions{
            EntryPoints: []string{"app.ts"},
            Sourcemap:   api.SourceMapExternal,
            Outfile:     "out.js",
            Write:       true,
          })

          if len(result.Errors) > 0 {
            os.Exit(1)
          }
        }

  - div: >
      <ol start="3"><li>
      <code>inline</code>
      <p>
      This mode means the source map is appended to the end of the `.js` output
      file as a base64 payload inside a `//# sourceMappingURL=` comment. No
      additional `.js.map` output file is generated. Keep in mind that source
      maps are usually very big because they contain all of your original source
      code, so you usually do not want to ship code containing `inline` source
      maps. To remove the source code from the source map (keeping only the file
      names and the line/column mappings), use the [sources content](#sources-content) option.
      Use `inline` source map mode like this:
      </p>
      </li></ol>

  - example:
      in:
        app.ts: 'let x: number = 1'

      cli: |
        esbuild app.ts --sourcemap=inline --outfile=out.js

      mjs: |
        import * as esbuild from 'esbuild'

        await esbuild.build({
          entryPoints: ['app.ts'],
          sourcemap: 'inline',
          outfile: 'out.js',
        })

      go: |
        package main

        import "github.com/evanw/esbuild/pkg/api"
        import "os"

        func main() {
          result := api.Build(api.BuildOptions{
            EntryPoints: []string{"app.ts"},
            Sourcemap:   api.SourceMapInline,
            Outfile:     "out.js",
            Write:       true,
          })

          if len(result.Errors) > 0 {
            os.Exit(1)
          }
        }

  - div: >
      <ol start="4"><li>
      <code>both</code>
      <p>
      This mode is a combination of `inline` and `external`. The source map is
      appended inline to the end of the `.js` output file, and another copy of
      the same source map is written to a separate `.js.map` output file
      alongside the `.js` output file. Use `both` source map mode like this:
      </p>
      </li></ol>

  - example:
      in:
        app.ts: 'let x: number = 1'

      cli: |
        esbuild app.ts --sourcemap=both --outfile=out.js

      mjs: |
        import * as esbuild from 'esbuild'

        await esbuild.build({
          entryPoints: ['app.ts'],
          sourcemap: 'both',
          outfile: 'out.js',
        })

      go: |
        package main

        import "github.com/evanw/esbuild/pkg/api"
        import "os"

        func main() {
          result := api.Build(api.BuildOptions{
            EntryPoints: []string{"app.ts"},
            Sourcemap:   api.SourceMapInlineAndExternal,
            Outfile:     "out.js",
            Write:       true,
          })

          if len(result.Errors) > 0 {
            os.Exit(1)
          }
        }

  - p: >
<<<<<<< HEAD
      该配置项可以被用来将你的 `tsconfig.json` 文件传递给  [transform API](#transform-api)，
      其不会访问文件系统。像这样使用它：

  - example:
      cli: |
        echo 'class Foo { foo }' | esbuild --loader=ts --tsconfig-raw='{"compilerOptions":{"useDefineForClassFields":true}}'
=======
      The [build](#build) API supports all four source map modes listed above,
      but the [transform](#transform) API does not support the `linked` mode.
      This is because the output returned from the transform API does not have an
      associated filename. If you want the output of the transform API to have a
      source map comment, you can append one yourself. In addition, the CLI form
      of the transform API only supports the `inline` mode because the output is
      written to stdout so generating multiple output files is not possible.

  - p: >
      If you want to "peek under the hood" to see what a source map does (or to
      debug problems with your source map), you can upload the relevant output
      file and the associated source map here:
      [Source Map Visualization](https://evanw.github.io/source-map-visualization/).

  - h4: Using source maps

  - p: >
      In the browser, source maps should be automatically picked up by the
      browser's developer tools as long as the source map setting is enabled.
      Note that the browser only uses the source maps to alter the display of
      stack traces when they are logged to the console. The stack traces
      themselves are not modified so inspecting <code>error.<wbr>stack</code>
      in your code will still give the unmapped stack trace containing compiled
      code. Here's how to enable this setting in your browser's developer tools:

  - ul:
      - 'Chrome: ⚙ → Enable JavaScript source maps'
      - 'Safari: ⚙ → Sources → Enable source maps'
      - 'Firefox: ··· → Enable Source Maps'

  - p: >
      In node, source maps are supported natively starting with [version v12.12.0](https://nodejs.org/en/blog/release/v12.12.0/).
      This feature is disabled by default but can be enabled with a flag. Unlike
      in the browser, the actual stack traces are also modified in node so
      inspecting <code>error.<wbr>stack</code> in your code will give the mapped
      stack trace containing your original source code. Here's how to enable this
      setting in node (the <code>--enable-<wbr>source-<wbr>maps</code> flag must
      come before the script file name):

  - pre.sh: |
      node --enable-source-maps app.js

  - h3: Sources content

  - p: >
      [Source maps](#sourcemap) are generated using [version 3](https://sourcemaps.info/spec.html)
      of the source map format, which is by far the most widely-supported
      variant. Each source map will look something like this:

  - pre.json: |
      {
        "version": 3,
        "sources": ["bar.js", "foo.js"],
        "sourcesContent": ["bar()", "foo()\nimport './bar'"],
        "mappings": ";AAAA;;;ACAA;",
        "names": []
      }

  - p: >
      The `sourcesContent` field is an optional field that contains all of the
      original source code. This is helpful for debugging because it means the
      original source code will be available in the debugger.

  - p: >
      However, it's not needed in some scenarios. For example, if you are just
      using source maps in production to generate stack traces that contain the
      original file name, you don't need the original source code because there
      is no debugger involved. In that case it can be desirable to omit the
      `sourcesContent` field to make the source map smaller:

  - example:
      in:
        app.js: '1 + 2'

      cli: |
        esbuild --bundle app.js --sourcemap --sources-content=false

      mjs: |
        import * as esbuild from 'esbuild'

        await esbuild.build({
          bundle: true,
          entryPoints: ['app.js'],
          sourcemap: true,
          sourcesContent: false,
          outfile: 'out.js',
        })

      go: |
        package main

        import "github.com/evanw/esbuild/pkg/api"
        import "os"

        func main() {
          result := api.Build(api.BuildOptions{
            Bundle:         true,
            EntryPoints:    []string{"app.js"},
            Sourcemap:      api.SourceMapInline,
            SourcesContent: api.SourcesContentExclude,
          })

          if len(result.Errors) > 0 {
            os.Exit(1)
          }
        }

  - h2: Build metadata

  - h3: Analyze

  - info: >
      If you're looking for an interactive visualization, try esbuild's
      [Bundle Size Analyzer](/analyze/) instead. You can upload your esbuild
      [metafile](#metafile) to see a bundle size breakdown.

  - p: >
      Using the analyze feature generates an easy-to-read report about the contents of your bundle:

  - example:
      install:
        react: '17.0.2'
        react-dom: '17.0.2'

      in:
        example.jsx: |
          import * as React from 'react'
          import * as Server from 'react-dom/server'

          let Greet = () => <h1>Hello, world!</h1>
          console.log(Server.renderToString(<Greet />))

      cli:
        - $: |
            esbuild --bundle example.jsx --outfile=out.js --minify --analyze

        - expect: |2

              out.js                                                                    27.6kb  100.0%
               ├ node_modules/react-dom/cjs/react-dom-server.browser.production.min.js  19.2kb   69.8%
               ├ node_modules/react/cjs/react.production.min.js                          5.9kb   21.4%
               ├ node_modules/object-assign/index.js                                     962b     3.4%
               ├ example.jsx                                                             137b     0.5%
               ├ node_modules/react-dom/server.browser.js                                 50b     0.2%
               └ node_modules/react/index.js                                              50b     0.2%

            ...

      mjs: |
        import * as esbuild from 'esbuild'

        let result = await esbuild.build({
          entryPoints: ['example.jsx'],
          outfile: 'out.js',
          minify: true,
          metafile: true,
        })

        console.log(await esbuild.analyzeMetafile(result.metafile))

      go: |
        package main

        import "github.com/evanw/esbuild/pkg/api"
        import "fmt"
        import "os"

        func main() {
          result := api.Build(api.BuildOptions{
            EntryPoints:       []string{"example.jsx"},
            Outfile:           "out.js",
            MinifyWhitespace:  true,
            MinifyIdentifiers: true,
            MinifySyntax:      true,
            Metafile:          true,
          })

          if len(result.Errors) > 0 {
            os.Exit(1)
          }

          fmt.Printf("%s", api.AnalyzeMetafile(result.Metafile, api.AnalyzeMetafileOptions{}))
        }

  - p: >
      The information shows which input files ended up in each output file as
      well as the percentage of the output file they ended up taking up. If you
      would like additional information, you can enable the "verbose" mode.
      This currently shows the import path from the entry point to each input
      file which tells you why a given input file is being included in the bundle:

  - example:
      install:
        react: '17.0.2'
        react-dom: '17.0.2'

      in:
        example.jsx: |
          import * as React from 'react'
          import * as Server from 'react-dom/server'

          let Greet = () => <h1>Hello, world!</h1>
          console.log(Server.renderToString(<Greet />))

      cli:
        - $: |
            esbuild --bundle example.jsx --outfile=out.js --minify --analyze=verbose

        - expect: |2

              out.js ─────────────────────────────────────────────────────────────────── 27.6kb ─ 100.0%
               ├ node_modules/react-dom/cjs/react-dom-server.browser.production.min.js ─ 19.2kb ── 69.8%
               │  └ node_modules/react-dom/server.browser.js
               │     └ example.jsx
               ├ node_modules/react/cjs/react.production.min.js ───────────────────────── 5.9kb ── 21.4%
               │  └ node_modules/react/index.js
               │     └ example.jsx
               ├ node_modules/object-assign/index.js ──────────────────────────────────── 962b ──── 3.4%
               │  └ node_modules/react-dom/cjs/react-dom-server.browser.production.min.js
               │     └ node_modules/react-dom/server.browser.js
               │        └ example.jsx
               ├ example.jsx ──────────────────────────────────────────────────────────── 137b ──── 0.5%
               ├ node_modules/react-dom/server.browser.js ──────────────────────────────── 50b ──── 0.2%
               │  └ example.jsx
               └ node_modules/react/index.js ───────────────────────────────────────────── 50b ──── 0.2%
                  └ example.jsx

            ...

      mjs: |
        import * as esbuild from 'esbuild'

        let result = await esbuild.build({
          entryPoints: ['example.jsx'],
          outfile: 'out.js',
          minify: true,
          metafile: true,
        })

        console.log(await esbuild.analyzeMetafile(result.metafile, {
          verbose: true,
        }))

      go: |
        package main

        import "github.com/evanw/esbuild/pkg/api"
        import "fmt"
        import "os"

        func main() {
          result := api.Build(api.BuildOptions{
            EntryPoints:       []string{"example.jsx"},
            Outfile:           "out.js",
            MinifyWhitespace:  true,
            MinifyIdentifiers: true,
            MinifySyntax:      true,
            Metafile:          true,
          })

          if len(result.Errors) > 0 {
            os.Exit(1)
          }

          fmt.Printf("%s", api.AnalyzeMetafile(result.Metafile, api.AnalyzeMetafileOptions{
            Verbose: true,
          }))
        }

  - p: >
      This analysis is just a visualization of the information that can be found
      in the [metafile](#metafile). If this analysis doesn't exactly suit your
      needs, you are welcome to build your own visualization using the information
      in the metafile.

  - p: >
      Note that this formatted analysis summary is intended for humans, not
      machines. The specific formatting may change over time which will likely
      break any tools that try to parse it. You should not write a tool to parse
      this data. You should be using the information in the [JSON metadata file](#metafile)
      instead. Everything in this visualization is derived from the JSON metadata
      so you are not losing out on any information by not parsing esbuild's
      formatted analysis summary.

  - h3: Metafile

  - p: >
      This option tells esbuild to produce some metadata about the build in
      JSON format. The following example puts the metadata in a file called
      `meta.json`:

  - example:
      in:
        app.js: '1 + 2'

      cli: |
        esbuild app.js --bundle --metafile=meta.json --outfile=out.js

      mjs: |
        import * as esbuild from 'esbuild'
        import fs from 'node:fs'

        let result = await esbuild.build({
          entryPoints: ['app.js'],
          bundle: true,
          metafile: true,
          outfile: 'out.js',
        })

        fs.writeFileSync('meta.json', JSON.stringify(result.metafile))

      go: |
        package main

        import "io/ioutil"
        import "github.com/evanw/esbuild/pkg/api"
        import "os"

        func main() {
          result := api.Build(api.BuildOptions{
            EntryPoints: []string{"app.js"},
            Bundle:      true,
            Metafile:    true,
            Outfile:     "out.js",
            Write:       true,
          })

          if len(result.Errors) > 0 {
            os.Exit(1)
          }

          ioutil.WriteFile("meta.json", []byte(result.Metafile), 0644)
        }

  - p: >
      This data can then be analyzed by other tools. For an interactive
      visualization, you can use esbuild's own [Bundle Size Analyzer](/analyze/).
      For a quick textual analysis, you can use esbuild's build-in [analyze](#analyze)
      feature. Or you can write your own analysis which uses this information.

  - p: >
      The metadata JSON format looks like this (described using a TypeScript
      interface):

  - pre.ts: |
      interface Metafile {
        inputs: {
          [path: string]: {
            bytes: number
            imports: {
              path: string
              kind: string
              external?: boolean
              original?: string
            }[]
            format?: string
          }
        }
        outputs: {
          [path: string]: {
            bytes: number
            inputs: {
              [path: string]: {
                bytesInOutput: number
              }
            }
            imports: {
              path: string
              kind: string
              external?: boolean
            }[]
            exports: string[]
            entryPoint?: string
            cssBundle?: string
          }
        }
      }

  - h2: Logging

  - h3: Color

  - p: >
      This option enables or disables colors in the error and warning messages
      that esbuild writes to stderr file descriptor in the terminal. By
      default, color is automatically enabled if stderr is a TTY session and
      automatically disabled otherwise. Colored output in esbuild looks like this:

  - pre.raw: >
      {{ FORMAT_MESSAGES('import log from "logger"\nlog(typeof x == "null")', { sourcefile: 'example.js', bundle: true }) }}

  - p: >
      Colored output can be force-enabled by setting color to `true`. This is
      useful if you are piping esbuild's stderr output into a TTY yourself:

  - example:
      cli: |
        echo 'typeof x == "null"' | esbuild --color=true 2> stderr.txt
>>>>>>> 64a7cbf09ed21d61e6fe85529b31e5676fa14bfe

      mjs: |
        import * as esbuild from 'esbuild'

        let js = 'typeof x == "null"'
        await esbuild.transform(js, {
          color: true,
        })

      go: |
        package main

        import "fmt"
        import "github.com/evanw/esbuild/pkg/api"

        func main() {
          js := "typeof x == 'null'"

          result := api.Transform(js, api.TransformOptions{
            Color: api.ColorAlways,
          })

          if len(result.Errors) == 0 {
            fmt.Printf("%s", result.Code)
          }
        }

  - p: >
      Colored output can also be set to `false` to disable colors.

  - h3: Format messages

  - p: >
<<<<<<< HEAD
      这个 API 配置允许你指定用于构建的工作目录。它通常默认为用于调用 esbuild 的 API 的进程的 [当前工作目录](https://en.wikipedia.org/wiki/Working_directory)。
      esbuild 使用工作目录做一些不同的事情，包括将作为 API 配置给出的相对路径解析为绝对路径，
      以及将绝对路径解析为日志消息中的相对路径。下面是如何覆盖它：

  - example:
      in:
        file.js: "export let foo = 123"
=======
      This API call can be used to format the log errors and warnings returned
      by the [build](#build) API and [transform](#transform) APIs as a
      string using the same formatting that esbuild itself uses. This is useful
      if you want to customize the way esbuild's logging works, such as processing
      the log messages before they are printed or printing them to somewhere other
      than to the console. Here's an example:

  - example:
      in:
        app.js: '1 + 2'

      mjs: |
        import * as esbuild from 'esbuild'

        let formatted = await esbuild.formatMessages([
          {
            text: 'This is an error',
            location: {
              file: 'app.js',
              line: 10,
              column: 4,
              length: 3,
              lineText: 'let foo = bar',
            },
          },
        ], {
          kind: 'error',
          color: false,
          terminalWidth: 100,
        })

        console.log(formatted.join('\n'))

      go: |
        package main

        import "fmt"
        import "github.com/evanw/esbuild/pkg/api"
        import "strings"

        func main() {
          formatted := api.FormatMessages([]api.Message{
            {
              Text: "This is an error",
              Location: &api.Location{
                File:     "app.js",
                Line:     10,
                Column:   4,
                Length:   3,
                LineText: "let foo = bar",
              },
            },
          }, api.FormatMessagesOptions{
            Kind:          api.ErrorMessage,
            Color:         false,
            TerminalWidth: 100,
          })

          fmt.Printf("%s", strings.Join(formatted, "\n"))
        }

  - h4: Options

  - p: >
      The following options can be provided to control the formatting:

  - example:
      noCheck: true
>>>>>>> 64a7cbf09ed21d61e6fe85529b31e5676fa14bfe

      js: |
        interface FormatMessagesOptions {
          kind: 'error' | 'warning';
          color?: boolean;
          terminalWidth?: number;
        }

      go: |
        type FormatMessagesOptions struct {
          Kind          MessageKind
          Color         bool
          TerminalWidth int
        }

  - ul:
    - >
      `kind`
      <p>Controls whether these log messages are printed as errors or warnings.</p>
    - >
      `color`
      <p>If this is `true`, Unix-style terminal escape codes are included for
      colored output.</p>
    - >
      `terminalWidth`
      <p>Provide a positive value to wrap long lines so that they don't overflow
      past the provided column width. Provide `0` to disable word wrapping.</p>

  - h3: Log level

  - p: >
      The log level can be changed to prevent esbuild from printing warning
      and/or error messages to the terminal. The six log levels are:

  - ul:
    - >
      <p>`silent`<br>Do not show any log output. This is the default log level
      when using the JS [transform](#transform) API.</p>
    - >
      <p>`error`<br>Only show errors.</p>
    - >
      <p>`warning`<br>Only show warnings and errors. This is the default log
      level when using the JS [build](#build) API.</p>
    - >
      <p>`info`<br>Show warnings, errors, and an output file summary. This is
      the default log level when using the CLI.</p>
    - >
      <p>`debug`<br>Log everything from `info` and some additional messages
      that may help you debug a broken bundle. This log level has a performance
      impact and some of the messages may be false positives, so this information
      is not shown by default.</p>
    - >
      <p>`verbose`<br>This generates a torrent of log messages and was added to
      debug issues with file system drivers. It's not intended for general use.</p>

  - p: >
      The log level can be set like this:

  - example:
      cli: |
        echo 'typeof x == "null"' | esbuild --log-level=error

      mjs: |
        import * as esbuild from 'esbuild'

        let js = 'typeof x == "null"'
        await esbuild.transform(js, {
          logLevel: 'error',
        })

      go: |
        package main

        import "fmt"
        import "github.com/evanw/esbuild/pkg/api"

        func main() {
          js := "typeof x == 'null'"

          result := api.Transform(js, api.TransformOptions{
            LogLevel: api.LogLevelError,
          })

          if len(result.Errors) == 0 {
            fmt.Printf("%s", result.Code)
          }
        }

  - h3: Log limit

  - p: >
      By default, esbuild stops reporting log messages after 10 messages have
      been reported. This avoids the accidental generation of an overwhelming number
      of log messages, which can easily lock up slower terminal emulators such
      as Windows command prompt. It also avoids accidentally using up the
      whole scroll buffer for terminal emulators with limited scroll buffers.

  - p: >
      The log limit can be changed to another value, and can also be disabled
      completely by setting it to zero. This will show all log messages:

  - example:
      in:
        app.js: '1 + 2'

      cli: |
        esbuild app.js --log-limit=0

      mjs: |
        import * as esbuild from 'esbuild'

        await esbuild.build({
          entryPoints: ['app.js'],
          logLimit: 0,
          outfile: 'out.js',
        })

      go: |
        package main

        import "github.com/evanw/esbuild/pkg/api"
        import "os"

        func main() {
          result := api.Build(api.BuildOptions{
            EntryPoints: []string{"app.js"},
            LogLimit:    0,
          })

          if len(result.Errors) > 0 {
            os.Exit(1)
          }
        }

<<<<<<< HEAD
  - h2: JS 特殊细节

  - p: >
      由于 JavaScript 是单线程的，因此有几种不同的方法来调用 API，这些方法具有不同的性能和方便性。
      重要的是要意识到这些差异，以正确选择的一个适合你的情况。

  - p: >
      首先是同步 API。这是最方便的选项，因为单线程 JavaScript 代码具有最干净的语法。
      如果你所需要做的只是运行 esbuild 然后退出，那么它也是最佳性能的。
      但是，它阻塞了主线程，所以如果你在此期间有其他工作要执行，你就不希望使用它。
      这也是唯一不能使用插件的选项（因为插件是异步的）。它是这样的：

  - h4: Sync API
=======
  - h3: Log override

  - p: >
      This feature lets you change the log level of individual types of log
      messages. You can use it to silence a particular type of warning, to
      enable additional warnings that aren't enabled by default, or even to
      turn warnings into errors.
>>>>>>> 64a7cbf09ed21d61e6fe85529b31e5676fa14bfe

  - p: >
      For example, when targeting older browsers, esbuild automatically
      transforms regular expression literals which use features that are
      too new for those browsers into <code>new <wbr>RegExp()</code> calls
      to allow the generated code to run without being considered a syntax
      error by the browser. However, these calls will still throw at runtime
      if you don't add a polyfill for `RegExp` because that regular
      expression syntax is still unsupported. If you want esbuild to generate
      a warning when you use newer unsupported regular expression syntax, you
      can do that like this:

  - example:
      in:
        app.js: '/./d'

      cli: |
        esbuild app.js --log-override:unsupported-regexp=warning --target=chrome50

      mjs: |
        import * as esbuild from 'esbuild'

        await esbuild.build({
          entryPoints: ['app.js'],
          logOverride: {
            'unsupported-regexp': 'warning',
          },
          target: 'chrome50',
        })

      go: |
        package main

        import "github.com/evanw/esbuild/pkg/api"
        import "os"

        func main() {
          result := api.Build(api.BuildOptions{
            EntryPoints: []string{"app.js"},
            LogOverride: map[string]api.LogLevel{
              "unsupported-regexp": api.LogLevelWarning,
            },
            Engines: []api.Engine{
              {Name: api.EngineChrome, Version: "50"},
            },
          })

          if len(result.Errors) > 0 {
            os.Exit(1)
          }
        }

  - p: >
<<<<<<< HEAD
      然后是异步 API。每个调用返回一个 promise，而不是立即完成。在底层，esbuild 二进制文件作为一个子进程生成，
      在宿主进程中的所有调用之间共享。主机使用自定义二进制协议通过 stdin、stdout 和 stderr 管道与子进程通信。
      如果你只需要运行esbuild一次，但又需要在后台做其他工作，那么这是理想的。
      它还允许你并发地运行许多 esbuild API 调用，然后将这些调用分散到所有可用的核心上，以获得最佳性能。
      使用它看起来像这样：      
      Pros:
=======
      The log level for each message type can be overridden to any value
      supported by the [log level](/api/#log-level) setting. All
      currently-available message types are listed below (click on each one
      for an example log message):
>>>>>>> 64a7cbf09ed21d61e6fe85529b31e5676fa14bfe

  - p: |
      <ul>
        <li>
          **JS:**
          <ul>
            <li><details><summary>`assign-to-constant`</summary><pre>{{ FORMAT_MESSAGES('const foo = 1; foo = 2', { sourcefile: 'example.js' }) }}</pre></details></li>
            <li><details><summary>`assign-to-import`</summary><pre>{{ FORMAT_MESSAGES('import foo from "foo"; foo = null', { sourcefile: 'example.js' }) }}</pre></details></li>
            <li><details><summary>`call-import-namespace`</summary><pre>{{ FORMAT_MESSAGES('import * as foo from "foo"; foo()', { sourcefile: 'example.js', format: 'esm' }) }}</pre></details></li>
            <li><details><summary>`commonjs-variable-in-esm`</summary><pre>{{ FORMAT_MESSAGES('exports.foo = 1; export let bar = 2', { sourcefile: 'example.js', format: 'esm' }) }}</pre></details></li>
            <li><details><summary>`delete-super-property`</summary><pre>{{ FORMAT_MESSAGES('class Foo extends Object { foo() { delete super.foo } }', { sourcefile: 'example.js' }) }}</pre></details></li>
            <li><details><summary>`duplicate-case`</summary><pre>{{ FORMAT_MESSAGES('switch (foo) { case 1: return 1; case 1: return 2 }', { sourcefile: 'example.js' }) }}</pre></details></li>
            <li><details><summary>`duplicate-object-key`</summary><pre>{{ FORMAT_MESSAGES('foo = { bar: 1, bar: 2 }', { sourcefile: 'example.js' }) }}</pre></details></li>
            <li><details><summary>`empty-import-meta`</summary><pre>{{ FORMAT_MESSAGES('foo = import.meta', { sourcefile: 'example.js', target: 'chrome50' }) }}</pre></details></li>
            <li><details><summary>`equals-nan`</summary><pre>{{ FORMAT_MESSAGES('foo = foo.filter(x => x !== NaN)', { sourcefile: 'example.js' }) }}</pre></details></li>
            <li><details><summary>`equals-negative-zero`</summary><pre>{{ FORMAT_MESSAGES('foo = foo.filter(x => x !== -0)', { sourcefile: 'example.js' }) }}</pre></details></li>
            <li><details><summary>`equals-new-object`</summary><pre>{{ FORMAT_MESSAGES('foo = foo.filter(x => x !== [])', { sourcefile: 'example.js' }) }}</pre></details></li>
            <li><details><summary>`html-comment-in-js`</summary><pre>{{ FORMAT_MESSAGES('<!-- comment -->', { sourcefile: 'example.js' }) }}</pre></details></li>
            <li><details><summary>`impossible-typeof`</summary><pre>{{ FORMAT_MESSAGES('foo = foo.map(x => typeof x !== "null")', { sourcefile: 'example.js' }) }}</pre></details></li>
            <li><details><summary>`indirect-require`</summary><pre>{{ FORMAT_MESSAGES('let r = require, fs = r("fs")', { sourcefile: 'example.js', bundle: true, logOverride: { 'indirect-require': 'warning' } }) }}</pre></details></li>
            <li><details><summary>`private-name-will-throw`</summary><pre>{{ FORMAT_MESSAGES('class Foo { get #foo() {} bar() { this.#foo++ } }', { sourcefile: 'example.js' }) }}</pre></details></li>
            <li><details><summary>`semicolon-after-return`</summary><pre>{{ FORMAT_MESSAGES('return\nx', { sourcefile: 'example.js' }) }}</pre></details></li>
            <li><details><summary>`suspicious-boolean-not`</summary><pre>{{ FORMAT_MESSAGES('if (!foo in bar) {\n}', { sourcefile: 'example.js' }) }}</pre></details></li>
            <li><details><summary>`this-is-undefined-in-esm`</summary><pre>{{ FORMAT_MESSAGES('this.foo = 1; export let bar = 2', { sourcefile: 'example.js', bundle: true, logOverride: { 'this-is-undefined-in-esm': 'warning' } }) }}</pre></details></li>
            <li><details><summary>`unsupported-dynamic-import`</summary><pre>{{ FORMAT_MESSAGES('import(foo)', { sourcefile: 'example.js', bundle: true, logOverride: { 'unsupported-dynamic-import': 'warning' } }) }}</pre></details></li>
            <li><details><summary>`unsupported-jsx-comment`</summary><pre>{{ FORMAT_MESSAGES('// @jsx 123', { sourcefile: 'example.jsx', loader: 'jsx' }) }}</pre></details></li>
            <li><details><summary>`unsupported-regexp`</summary><pre>{{ FORMAT_MESSAGES('/./d', { sourcefile: 'example.js', target: 'chrome50', logOverride: { 'unsupported-regexp': 'warning' } }) }}</pre></details></li>
            <li><details><summary>`unsupported-require-call`</summary><pre>{{ FORMAT_MESSAGES('require(foo)', { sourcefile: 'example.js', bundle: true, logOverride: { 'unsupported-require-call': 'warning' } }) }}</pre></details></li>
          </ul>
          <br>
        </li>

        <li>
          **CSS:**
          <ul>
            <li><details><summary>`css-syntax-error`</summary><pre>{{ FORMAT_MESSAGES('div[] {\n}', { sourcefile: 'example.css', loader: 'css' }) }}</pre></details></li>
            <li><details><summary>`invalid-@charset`</summary><pre>{{ FORMAT_MESSAGES('div { color: red } @charset "UTF-8";', { sourcefile: 'example.css', loader: 'css' }) }}</pre></details></li>
            <li><details><summary>`invalid-@import`</summary><pre>{{ FORMAT_MESSAGES('div { color: red } @import "foo.css";', { sourcefile: 'example.css', loader: 'css' }) }}</pre></details></li>
            <li><details><summary>`invalid-@nest`</summary><pre>{{ FORMAT_MESSAGES('& div {\n}', { sourcefile: 'example.css', loader: 'css' }) }}</pre></details></li>
            <li><details><summary>`invalid-@layer`</summary><pre>{{ FORMAT_MESSAGES('@layer initial {\n}', { sourcefile: 'example.css', loader: 'css' }) }}</pre></details></li>
            <li><details><summary>`invalid-calc`</summary><pre>{{ FORMAT_MESSAGES('div { z-index: calc(-(1+2)); }', { sourcefile: 'example.css', loader: 'css' }) }}</pre></details></li>
            <li><details><summary>`js-comment-in-css`</summary><pre>{{ FORMAT_MESSAGES('// comment', { sourcefile: 'example.css', loader: 'css' }) }}</pre></details></li>
            <li><details><summary>`unsupported-@charset`</summary><pre>{{ FORMAT_MESSAGES('@charset "ASCII";', { sourcefile: 'example.css', loader: 'css' }) }}</pre></details></li>
            <li><details><summary>`unsupported-@namespace`</summary><pre>{{ FORMAT_MESSAGES('@namespace "ns";', { sourcefile: 'example.css', loader: 'css' }) }}</pre></details></li>
            <li><details><summary>`unsupported-css-property`</summary><pre>{{ FORMAT_MESSAGES('div { widht: 1px }', { sourcefile: 'example.css', loader: 'css' }) }}</pre></details></li>
          </ul>
          <br>
        </li>

        <li>
          **Bundler:**
          <ul>
            <li><details><summary>`ambiguous-reexport`</summary><pre>{{ FORMAT_MESSAGES({ 'example.js': 'export * from "./a"; export * from "./b"', 'a.js': 'export let foo = 1', 'b.js': 'export let foo = 2' }, { bundle: true, logOverride: { 'ambiguous-reexport': 'warning' } }) }}</pre></details></li>
            <li><details><summary>`different-path-case`</summary><pre>{{ FORMAT_MESSAGES({ 'example.js': 'import "./foo.js"\nimport "./Foo.js"', 'foo.js': '' }, { bundle: true }) }}</pre></details></li>
            <li><details><summary>`ignored-bare-import`</summary><pre>{{ FORMAT_MESSAGES({ 'example.js': 'import "foo"', 'node_modules/foo/index.js': 'foo', 'node_modules/foo/package.json': '{\n  "sideEffects": false\n}' }, { bundle: true }) }}</pre></details></li>
            <li><details><summary>`ignored-dynamic-import`</summary><pre>{{ FORMAT_MESSAGES({ 'example.js': 'import("foo").catch(e => {\n})' }, { bundle: true, logOverride: { 'ignored-dynamic-import': 'warning' } }) }}</pre></details></li>
            <li><details><summary>`import-is-undefined`</summary><pre>{{ FORMAT_MESSAGES({ 'example.js': 'import { foo } from "./foo"', 'foo.js': 'let foo = 1' }, { bundle: true, logOverride: { 'import-is-undefined': 'warning' } }) }}</pre></details></li>
            <li><details><summary>`require-resolve-not-external`</summary><pre>{{ FORMAT_MESSAGES({ 'example.js': 'let foo = require.resolve("foo")' }, { bundle: true, format: 'cjs' }) }}</pre></details></li>
          </ul>
          <br>
        </li>

        <li>
          **Source maps:**
          <ul>
            <li><details><summary>`invalid-source-mappings`</summary><pre>{{ FORMAT_MESSAGES({ 'example.js': '//# sourceMappingURL=example.js.map', 'example.js.map': '{ "version": 3, "sources": ["example.js"],\n  "mappings": "aAAFA,UAAU;;"\n}' }, { bundle: true, sourcemap: true }) }}</pre></details></li>
            <li><details><summary>`sections-in-source-map`</summary><pre>{{ FORMAT_MESSAGES({ 'example.js': '//# sourceMappingURL=example.js.map', 'example.js.map': '{\n  "sections": []\n}' }, { bundle: true, sourcemap: true }) }}</pre></details></li>
            <li><details><summary>`missing-source-map`</summary><pre>{{ FORMAT_MESSAGES({ 'example.js': '//# sourceMappingURL=.' }, { bundle: true, sourcemap: true }) }}</pre></details></li>
            <li><details><summary>`unsupported-source-map-comment`</summary><pre>{{ FORMAT_MESSAGES({ 'example.js': '//# sourceMappingURL=data:application/json,"%"' }, { bundle: true, sourcemap: true }) }}</pre></details></li>
          </ul>
          <br>
        </li>

        <li>
          **Resolver:**
          <ul>
            <li><details><summary>`package.json`</summary><pre>{{ FORMAT_MESSAGES({ 'example.js': '', 'package.json': '{ "type": "esm" }' }, { bundle: true }) }}</pre></details></li>
            <li><details><summary>`tsconfig.json`</summary><pre>{{ FORMAT_MESSAGES({ 'example.ts': '', 'tsconfig.json': '{ "compilerOptions": { "target": "ES4" } }' }, { bundle: true }) }}</pre></details></li>
          </ul>
          <br>
        </li>
      </ul>

  - p: >
<<<<<<< HEAD
      Cons:

  - ul:
    - >
      You can't use [plugins](/plugins/) with the synchronous API since plugins are asynchronous
    - >
      It blocks the current thread so you can't perform other work in the meantime
    - >
      Using the synchronous API prevents esbuild from parallelizing esbuild API calls

  - h4: Async API

  - p: >
      Asynchronous API calls return their results using a promise:

  - pre.js: |
      let esbuild = require('esbuild')
      esbuild.transform(code, options).then(result => { ... })
      esbuild.build(options).then(result => { ... })

  - h3: 在浏览器中运行

  - p: >
      Pros:

  - ul:
    - >
      You can use [plugins](/plugins/) with the asynchronous API
    - >
      The current thread is not blocked so you can perform other work in the meantime
    - >
      You can run many simultaneous esbuild API calls concurrently which are
      then spread across all available CPUs for maximum performance

  - p: >
      Cons:

  - ul:
    - >
      Using promises can result in messier code, especially in CommonJS where
      [top-level await](https://v8.dev/features/top-level-await) is not available
    - >
      Doesn't work in situations that must be synchronous such as within
      <a href="https://nodejs.org/api/modules.html#requireextensions"><code>require<wbr>.extensions</code></a>

  - p: >
      esbuild API 也可以在 Web Worker 中使用 WebAssembly 运行。为了使用它你需要安装
      `esbuild-wasm` 而不是 `esbuild`：

  - pre: |
      npm install esbuild-wasm

  - p: >
      esbuild 在浏览器中的 API 与 node 中的类似，你需要首先调用 `initialize()`，然后你需要传递
      WebAssembly 二进制文件的 URL。API 的同步版本也是不可用的。假如你正在使用一个打包器，那么它看起来应该是这样：

  - pre.js: |
      let esbuild = require('esbuild-wasm')

      esbuild.initialize({
        wasmURL: './node_modules/esbuild-wasm/esbuild.wasm',
      }).then(() => {
        esbuild.transform(code, options).then(result => { ... })
        esbuild.build(options).then(result => { ... })
      })

  - p: >
      如果你已经在 worker 中运行改代码而不像运行 `initialize` 创建另一个 worker，你可以向其传递
      <code>worker: <wbr>false</code>。然后，它会在调用 `initialize` 的线程中创建一个 WebAssembly 模块。

  - p: >
      你还可以在 HTML 文件中将 esbuild 的 API 作为 script 标签使用，而不需要通过注入 `lib/browser.min.js` 
      文件来使用打包器。在这种情况下，API 创建了一个全局变量 esbuild，它保存了API对象：

  - pre.html: |
      <script src="./node_modules/esbuild-wasm/lib/browser.min.js"></script>
      <script>
        esbuild.initialize({
          wasmURL: './node_modules/esbuild-wasm/esbuild.wasm',
        }).then(() => { ... })
      </script>

  - p: >
      如果你需要通过 ECMAScript 模块使用 API，你应该导入 `esm/browser.min.js` 文件：

  - pre.html: |
      <script type="module">
        import * as esbuild from './node_modules/esbuild-wasm/esm/browser.min.js'

        esbuild.initialize({
          wasmURL: './node_modules/esbuild-wasm/esbuild.wasm',
        }).then(() => { ... })
      </script>
=======
      These message types should be reasonably stable but new ones may be added
      and old ones may occasionally be removed in the future. If a message type
      is removed, any overrides for that message type will just be silently ignored.
>>>>>>> 64a7cbf09ed21d61e6fe85529b31e5676fa14bfe
